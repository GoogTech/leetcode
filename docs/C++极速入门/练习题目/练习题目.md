## 简介

* `Author` : *GoogTech*
* `Website` : *https://algorithm.show*
* `Email` : *GoogTech@qq.com*
* `Date` :  *2021,6,15 ~ 2021,6,22*



---



## 目录

[TOC]

---



## 基础选择题

### 1. C++基本语法
1. C++源程序文件的缺省扩展名为(    )。
        A. cpp       B. exe       C. obj       D. lik
    
    >答案 : A
    
    
    
2. 由C++源程序文件编译而成的目标文件的缺省扩展名为(    )。
        A. cpp       B. exe       C. obj       D. lik

    >答案 : C

    

3. 由C++目标文件连接而成的可执行文件的缺省扩展名为(    )。
       A. cpp       B. exe       C. obj       D. lik

   >答案 : B



4. 编写C++程序一般需经过的几个步骤依次是(  	   )。
       A. 编译、编辑、连接、调试
       B. 编辑、编译、连接、调试
       C. 编译、调试、编辑、连接
       D. 编辑、调试、编辑、连接

   >答案 : B



5. 在多文件结构的程序中，通常把类的定义单独存放于（   ）中。
       A. 主文件      B. 实现文件      C. 库文件      D. 头文件

   >答案 : D

   

6. 在多文件结构的程序中，通常把类中所有非内联函数的定义单独存放于（   ）中。
       A. 主文件      B. 实现文件      C. 库文件      D. 头文件

   >答案 :  A

   

7. 在多文件结构的程序中，通常把含有main()函数的文件称为（   ）。
       A. 主文件      B. 实现文件      C. 程序文件     D. 头文件

   >答案 : C

   

8. 一个C++程序文件的扩展名为（   ）。
       A. .h         B. .c           C. .cpp       D. .cp

   >答案 : C

   

9. 在C++程序中使用的cin标识符是系统类库中定义的（   ）类中的一个对象。
       A. istream    B. ostream      C. iostream   D. fstream

   >答案 : A

   

10. 在C++程序中使用的cout标识符是系统类库中定义的（   ）类中的一个对象。
        A. istream    B. ostream      C. iostream   D. fstream  

    >答案 : B

    

11. 程序中主函数的名字为（    ）。
        A. main       B. MAIN         C. Main       D. 任意标识符

    >答案 : A

    

12. 采用重载函数的目的是（    ）。
        A. 实现共享        B. 减少空间
        C. 提高速度        D. 使用方便，提高可读性

    >答案 : D

    

13. int i=0,s=0; while(s<20) {i++; s+=i;}
       A. 4      B. 5      C. 6      D. 7

    >题目有误, 请跳过哈~

    

14. 在下面循环语句中循环体执行的次数为（  A  ）。
        int i=0; do i++; while(i*i<10);
        A. 4      B. 3      C. 5      D. 2

    >答案 : A

    

15. 当处理特定问题时的循环次数已知时，通常采用（   ）来解决。
        A. for循环      B. while循环      C. do循环      D. switch语句

    >答案 : A

    

16. 循环体至少被执行一次的语句为（   ）。
        A. for循环      B. while循环      C. do循环      D. 任一种循环

    >答案 : C

    

17. switch语句能够改写为（    ）语句。
        A. for              B. if                     C. do              D. while

    >答案 : B

    

18. 函数重载是指（    ）。
        A. 两个或两个以上的函数取相同的函数名，但形参的个数或类型不同
        B. 两个以上的函数取相同的名字和具有相同的参数个数，但形参的类型可以不同
        C. 两个以上的函数名字不同，但形参的个数或类型相同
        D. 两个以上的函数取相同的函数名，并且函数的返回类型相同

    >答案 : A

    

19. 下列（    ）的调用方式是引用调用。
        A. 形参和实参都是变量              B.形参是指针，实参是地址值
        C. 形参是引用，实参是变量      D.形参是变量，实参是地址值

    >答案 : C

    

20. 用new运算符创建一个含10个元素的一维整型数组的正确语句是(   )。
        A. int *p=new a[10];                  B. int *p=new float[10];
        C. int *p=new int[10];                D. int *p=new int[10]={1,2,3,4,5}

    >答案 : C

    

21. 假定变量m定义为“int m=7;”，则定义变量p的正确语句为（   ）。
        A. int p=&m;               B. int *p=&m;              C. int &p=*m;               D. int *p=m;

    >答案 : B  
    >
    >题目描述不清晰.

    

22. 变量s的定义为“char *s=”Hello world!”;”，要使变量p指向s所指向的同一个字符串，则应选取（   ）。
        A. char *p=s;                       B. char *p=&s;    
        C. char *p;p=*s;                      D. char *p; p=&s;

    >答案 : A

    

23. 假定一条定义语句为“int a[10], x, *pa=a;”，若要把数组a中下标为3的元素值赋给x，则不正确的语句为（   ）。

       A. x=pa[3]                  B. x=*（a+3）               C. x=a[3]                    D.  x=*pa+3

    >答案 : D

    

24. 假定指针变量p定义为“int *p=new int(100);”，要释放p所指向的动态内存，应使用语句（ ）。
       A. delete p;                B. delete *p;                C. delete &p;             D. delete []p;

    >答案 : A

    

---



### 2. 类的封装
1. 关于封装，下列说法中不正确的是（   ）。
        A. 通过封装，对象的全部属性和操作结合在一起，形成一个整体
        B. 通过封装，一个对象的实现细节被尽可能地隐藏起来（不可见）
        C. 通过封装，每个对象都成为相对独立的实体
        D. 通过封装，对象的属性都是不可见的
    
    >答案 : D
    
    
    
2. 面向对象方法的多态性是指（   ）。
        A. 一个类可以派生出多个特殊类
        B. 一个对象在不同的运行环境中可以有不同的变体
        C. 针对一消息，不同的对象可以以适合自身的方式加以响应
        D. 一个对象可以是由多个其他对象组合而成的

    >答案 : C

    

3. 在一个类的定义中，包含有（   ）成员的定义。
        A. 数据      B. 函数      C. 数据和函数      D. 数据或函数

    >答案 : C

    

4. 在类作用域中能够通过直接使用该类的（   ）成员名进行访问。
        A. 私有      B. 公用      C. 保护      D. 任何

    >答案 : D

    

5. 在关键字public后面定义的成员为类的（   ）成员。
        A. 私有      B. 公用      C. 保护      D. 任何

    >答案 : B

    

6. 在关键字private后面定义的成员为类的（   ）成员。
        A. 私有      B. 公用      C. 保护      D. 任何

    >答案 : A

    

7. 当类中一个字符指针成员指向具有n个字节的存储空间时，它所能存储字符串的最大长度为(   )。
        A. n      B. n+1      C. n-1      D. n-2

    >答案 : C

    

8. 对于一个类的构造函数，其函数名与类名(    )。
        A. 完全相同      B. 基本相同      C. 不相同      D. 无关系

    >答案 : A

    

9. 对于一个类的`析构函数`，其函数名与类名(    )。
        A. 完全相同      B. 完全不同      C. 只相差一个字符      D. 无关系

    >答案 : C

    

10. 类的构造函数是在定义该类的一个(    )时被自动调用执行的。
        A. 成员函数      B. 数据成员      C. 对象      D. 友元函数

    >答案 : C

    

11. 类的`析构函数`是一个对象被(    )时自动调用的。
         A. 建立      B. 撤消      C. 赋值        D. 引用

     >答案 : B

     

12. 一个类的`构造函数`通常被定义为该类的(    )成员。
         A. 公用      B. 保护      C. 私有      D. 友元

     >答案 : B

     

13. 一个类的`析构函数`通常被定义为该类的(    )成员。
         A. 私有      B. 保护      C. 公用      D. 友元

     >答案 : C

     


---



### 3. 继承

1. 从一个基类派生出的各个类的对象之间(    )。
       A. 共享所有数据成员，每个对象还包含基类的所有属性
       B. 共享部分数据成员，每个对象还包含基类的所有属性
       C. 不共享任何数据成员，但每个对象还包含基类的所有属性
       D. 共享部分数据成员和函数成员
   
   >答案 : C
   
   
   
2. 如果是类B在类A的基础上构造，那么，就称（   ）。
       A. 类A为基类或父类，类B为超类或子类
       B. 类A为基类、父类或超类，类B为派生类或子类 
       C. 类A为派生类，类B为基类
       D. 类A为派生类或子类，类B为基类、父类或超类

   >答案 : B

   

3. C++的继承性允许派生类继承基类的（   ）。
       A. 部分特性，并允许增加新的特性或重定义基类的特性
       B. 部分特性，但不允许增加新的特性或重定义基类的特性 
       C. 所有特性，并允许增加新的特性或重定义基类的特性
       D. 所有特性，但不允许增加新的特性或重定义基类的特性

   >答案 : A

   

4. 派生类的成员函数可以直接访问基类的（   ）成员。
       A. 所有         B. 公有和保护         C. 保护和私有         D. 私有

   >答案 : B

   

5. 对于公有继承，基类的公有和保护成员在派生类中将(   )成员。
       A. 全部变成公有                  B. 全部变成保护 
       C. 全部变成私有                  D. 仍然相应保持为公有和保护

   >答案 : D

   

6. 对于公有继承，基类中的私有成员在派生类中将 (   )。
       A. 能够直接使用成员名访问        B. 能够通过成员运算符访问
       C. 仍然是基类的私有成员            D. 变为派生类的私有成员

   >答案 : C

   

7. 当保护继承时，基类的（    ）在派生类中成为保护成员，在类作用域外不能够通过派生类的对象来直接访问该成员。
       A. 任何成员                                  B.公有成员和保护成员 
       C. 保护成员和私有成员               D.私有成员

   >答案 : B

   

8. 在定义一个派生类时，若不使用保留字显式地规定采用何种继承方式，则默认为（   ）方式。
       A. 私有继承                      B. 非私有继承
       C. 保护继承                      D. 公有继承

   >答案 : A

   

9. 建立包含有类对象成员的派生类对象时，自动调用构造函数的执行顺序依次为（    ）的构造函数。
       A. 自己所属类、对象成员所属类、基类
       B. 对象成员所属类、基类、自己所属类
       C. 基类、对象成员所属类、自己所属类
       D. 基类、自己所属类、对象成员所属类

   >答案 : C

   

10. 当派生类中有和基类一样名字的成员时，一般来说，（  ）。
      A. 将产生二义性              B. 派生类的同名成员将覆盖基类的成员
      C. 是不能允许的              D. 基类的同名成员将覆盖派生类的成员

   >答案 : B

   

11. C++中的`虚基类机制`可以保证：（  ）。
        A. 限定基类只通过一条路径派生出派生类
        B. 允许基类通过多条路径派生出派生类，派生类也就能多次继承该基类
        C. 当一个类多次间接从基类派生以后，派生类对象能保留多份间接基类的成员
        D. 当一个类多次间接从基类派生以后，其基类只被一次继承

    >答案 : D

    

12. 下列对派生类的描述中错误的说法是：（    ）。
        A. 派生类至少有一个基类
        B. 派生类可作为另一个派生类的基类
        C. 派生类除了包含它直接定义的成员外，还包含其基类的成员
        D. 派生类所继承的基类成员的访问权限保持不变

    >答案 : D

    

13. 派生类的对象对其基类中（    ）可直接访问。
        A. 公有继承的公有成员
        B. 公有继承的私有成员
        C. 公有继承的保护成员
        D. 私有继承的公有成员

    >答案 : A

    

---



### 4. 多态 

1.在派生类中重新定义虚函数时，除了（    ），其他方面都必须与基类中相应的`虚函数`保持一致。
   A.参数个数     B.参数类型     C.函数名称   D.函数体

>答案 : D



2.在`重载一个运算符`时，其参数表中没有任何参数，这表明该运算符是（    ）。
    A. 作为友元函数重载的1元运算符         B. 作为成员函数重载的1元运算符
    C. 作为友元函数重载的2元运算符         D. 作为成员函数重载的2元运算符

>答案 : B



3.在成员函数中进行`双目运算符重载`时，其参数表中应带有（    ）个参数。
    A. 0      B. 1      C. 2      D. 3

>答案 : B



4.`双目运算符重载`为普通函数时，其参数表中应带有（    ）个参数。
    A. 0      B. 1      C. 2      D. 3

>答案 : C



5.关于运算符重载，下列说法正确的是（   ）。
    A. 重载时，运算符的优先级可以改变。
    B. 重载时，运算符的结合性可以改变。
    C. 重载时，运算符的功能可以改变。
    D. 重载时，运算符的操作数个数可以改变。

>答案 : C



6.关于运算符重载，下列说法正确的是（   ）。
    A. 所有的运算符都可以重载。
    B. 通过重载，可以使运算符应用于自定义的数据类型。
    C. 通过重载，可以创造原来没有的运算符。
    D. 通过重载，可以改变运算符的优先级。

>答案 : B



7.假定M是一个类名，且M中重载了操作符=，可以实现M对象间的连续赋值，如“m1=m2=m3;”。`重载操作符`=的函数原型最好是（  ）。
    A. int operaotor=(M);           B.  int operator=(M&);
    C. M operator=(M&);            D.  M& operator=(M);

>答案 : D



8.在`重载一运算符`时，若运算符函数的形参表中没有参数，则不可能的情况是（   ）。
    A. 该运算符是一个单目运算符。       
    B. 该运算符函数有一个隐含的参数this。
    C. 该运算符函数是类的成员函数。
    D. 该运算符函数是类的友元函数。

>答案 : D



9.在C++中，用于实现`运行时多态性`的是（ ）。
    A）内联函数 
    B）重载函数 
    C）模板函数
    D）虚函数

>答案 : D



10.如果一个类至少有一个`纯虚函数`，那么就称该类为（  ）。
    (a)抽象类     (b)派生类      (c)虚基类      (d)以上都不对

>答案 : A



11.下列关于`抽象类`的说明中不正确的是（  ）。
    (a)含有纯虚函数的类称为抽象类
    (b)抽象类不能被实例化，但可声明抽象类的指针变量
    (c)抽象类的派生类可以实例化
    (d)纯虚函数可以被继承

>答案 : C



12.下面描述中，正确的是（　 ）。
    A．`virtual`可以用来声明虚函数
    B．含有纯虚函数的类是不可以用来创建对象的，因为它是虚基类
    C．即使基类的构造函数没有参数，派生类也必须建立构造函数
    D．静态数据成员可以通过成员初始化列表来初始化

>答案 :  A



13.关于`虚函数`的描述中，正确的是（）。
    A．虚函数是一个静态成员函数
    B．虚函数是一个非成员函数
    C．虚函数即可以在函数说明定义，也可以在函数实现时定义
    D．派生类的虚函数与基类中对应的虚函数具有相同的参数个数和类型

>答案 : D



14.要实现动态联编，可以通过（ ）调用`虚函数`。
    A．对象指针
    B．成员名限定
    C．对象名
    D．派生类名

>答案 : A



15.以下（ ）成员函数表示`纯虚函数`。
    A．virtual int vf(int);
    B．void vf(int)=0;
    C．virtual void vf()=0;
    D．virtual void vf(int) { };

>答案 : C



16.下列关于`动态联编`的描述中，错误的是（）。
    A．动态联编是以虚函数为基础
    B．动态联编是运行时确定所调用的函数代码的
    C．动态联编调用函数操作是指向对象的指针或对象引用
    D．动态联编是在编译时确定操作函数的

>答案 : D



---



## 基础编程题

### 1. 两数相加

#### 方法一

```c++
/**
 * 1.两数相加
 *
 * 法一: 最简单的方法如下所示, 缺点为数据类型固定(可利用模板方法改进哈), 且无异常捕获.
 */
#include "iostream"

using namespace std;

int main() {
    int a, b;
    
    cout << "Please input a number: ";
    cin >> a;
    cout << "Please input a number again: ";
    cin >> b;
    
    cout << "The result: " << a + b;
}
```

```
// 运行结果如下:
Please input a number: 1
Please input a number again: 2
The result: 3
```

#### 方法二

```c++
/**
 * 1.两数相加
 *
 * 法二: 利用函数模板进行改进, 这里就不加异常捕获了哈
 */
#include "iostream"

using namespace std;

// 自定义函数模板, 返回不同类型数据中的最大值
template <typename T1, typename T2>
inline T1 sum(T1 t1, T2 t2) {
    return t1 + t2;
}

int main() {
    cout << "Int type: "<< sum(1, 2) << endl;
    cout << "Double type: " << sum(1.1, 2.2) << endl;
    cout << "Int and Double type: " << sum(1, 2.2) << endl;
    return 0;
}
```

```
// 运行结果如下所示:
Int type: 3
Double type: 3.3
Int and Double type: 3
```

> ​	在 c/c++ 中, 为了解决一些频繁调用的小函数大量消耗栈空间(栈内存)的问题,特别的引入了 **inline** 修饰符,表示为内联函数.



---



### 2. 求 N 阶乘

#### 方法一

```c++
/**
 * 2. 求 n 阶乘
 *
 * 法一: 最简单的方法是利用 for / while 循环求阶乘. 当然最好利用递归法哈
 */
#include "iostream"

using namespace std;

int main() {
    int n;
    long double result = 1; // int 类型易益出, 即错得结果0

    cout << "Please input a number: ";
    cin >> n;

    for (int i = n; i > 0; i --) {
        result =  result * i;
    }

    cout << result;

    return 0;
}
```

```
// 运行结果如下:
Please input a number: 5
The result: 120
```

#### 方法二

```c++
/**
 * 2. 求 n 阶乘
 *
 * 法二: 利用递归求阶乘
 */
#include "iostream"

using namespace std;

inline int func(int n) {
    return (n == 1 || n == 0) ? n : n * func(n - 1);
}

int main() {
    cout << "The result: " << func(5);
}
```

```
// 运行结果如下:
The result: 120
```



---



### 3. swap()

*题目要求 : 求两个数交换函数`swap()`*

#### 方法一

```c++
/**
 * 3.求两个数得交换函数 swap()
 *
 * 法一: 利用引用 &, 其比指针易理解哈
 * 当实参占据内存较大时,用引用代替传值( 需要复制 )可提高效率
 */
#include "iostream"

using namespace std;

void swap(int &x, int &y) {
    int t = x; x = y; y = t;
}

int main() {
    int a = 1, b = 2;

    cout << "Before a: " << a << " and b: " << b << endl;
    swap(a, b);
    cout << "After a: " << a << " and b: " << b;

    return 0;
}
```

```
// 运行结果如下:
Before a: 1 and b: 2
After a: 2 and b: 1
```

#### 方法二

```c++
/**
 * 3.求两个数得交换函数 swap()
 *
 * 法二: 利用指针
 */
#include "iostream"

using namespace std;

inline void swap(int *x, int *y) {
    int t = *x; *x = *y; *y = t;
}

int main() {
    int a = 3, b = 4;
    cout << "Before a value: " << a << " and b value: " << b << endl;
    // &a 将 a 值赋值给 x, x 为 int* 指针, 指向 a
    swap(&a, &b);
    cout << "After a value: " << a << " and b value: " << b;

    return 0;
}
```

```
// 运行结果如下:
Before a value: 3 and b value: 4
After a value: 4 and b value: 3
```

#### 方法三

```c++
// 加减法: a = a + b; b = a - b; a = a - b;
// 缺点: 处理浮点型的时候有可能出现精度的损失

// 乘除法: a = a * b; b = a / b; a = a / b;
// 缺点: 在处理浮点型变量时也存在精度损失问题,而且乘除的溢出比加减法严重

// 异或法: 
// a ^= b; // a = a ^ b
// b ^= a; // b = b ^ (a ^ b) = b ^ a ^ b = b ^ b ^ a = 0 ^ a = a
// a ^= b; // a = (a ^ b) ^ a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b
// 缺点: 异或法可以完成对整型变量的交换,对于浮点型变量它无法完成交换
```

#### swap源码分析

*以下 C++ 标准库源码来摘自`bits/move.h`*

```c++
#if __cplusplus >= 201103L
#define _GLIBCXX_MOVE(__val) std::move(__val)
#else
#define _GLIBCXX_MOVE(__val) (__val)
#endif
 
template<typename _Tp>
inline void swap(_Tp& __a, _Tp& __b {
    
      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
```

分析: 

* 使用 `inline`, 即声明为内联函数来优化函数调用的开销

* 使用`右值引用(move)`, 进而节省拷贝所引发的不必要的资源浪费

  

---



### 4. 使用new运算符

*题目要求 : 使用 `new` 运算符生成一个数组, 其长度为 6*

```c++
int *p = new int[6]; 
```

> 删除所申请得空间 : `delete[] p`



---



### 5. 设计一个类

*题目要求 : 设计一个类, 包含得属性学号(`string ID`) 和姓名 (`string name`)*

```c++
/**
 * 5.设计一个类, 包含得属性学号(string ID) 和姓名 (string name)
 */
#include "iostream"

using namespace std;

class Student {
public:
    string id;
    string name;
public:
    void print() {
        cout << "id: " << id << " and name: " << name;
    }
};

int main() {
    Student student;
    student.id = "Z001";
    student.name = "GoogTech";
    student.print();
}
```

```
// 运行结果如下:
id: Z001 and name: GoogTech
```



---



### 6. 派生一个矩形类

*题目要求 : 设计一个形状类, 其`派生`一个矩形类*

```c++
#include "iostream"

using namespace std;

// 形状类
class Shape {
protected:
    int width;
    int height;
public:
    void setWidth(int w) {
        width = w;
    }
    void setHeight(int h) {
        height = h;
    }
};

// 继承形状类的矩形类
class Rectangle: public Shape{
public:
    int getArea() {
        return width * height;
    }
};

int main() {
    Rectangle rectangle;
    rectangle.setHeight(10);
    rectangle.setWidth(20);

    cout << "The area of rectangle :" << rectangle.getArea() << endl;

    return 0;
}
```

```
// 运行结果如下:
The area of rectangle : 200
```



---



### 7. 重载"+"运算符

*题目要求 : 编写程序定义类PT, 有数据成员ab, 为其重载 `+` 运算符, 实现两个PT类对象相加*

```c++
/**
 * 7.编写程序定义类 PT, 有数据成员 ab,
 * 为其重载 `+` 运算符, 实现两个 PT 类对象相加.
 */
#include "iostream"

using namespace std;

class Box {
private:
    double length;
    double width;
public:
    double getAare() {
        return length * width;
    }

    void setLength(double len) {
        length = len;
    }

    void setWidth(double wid) {
        width = wid;
    }

    // 重载运算符 "+", 用于把两个 Box 对象相加
    Box operator+(const Box& b) {
        Box box;
        box.width = this -> width + b.width;
        box.length = this -> length + b.length;
        return box;
    }
};

int main() {
    Box box1;
    Box box2;
    Box box3;

    // 初始化 box1 对象中的属性值
    box1.setWidth(10);
    box1.setLength(20);

    // 初始化 box2 对象中的属性值
    box2.setWidth(30);
    box2.setLength(40);

    // 输出 box1, box2 的面积
    cout << "The area of box1: " << box1.getAare() << endl;
    cout << "The area of box2: " << box2.getAare() << endl;

    // 把两个对象相加得到 b3, 然后输出其体积
    box3 = box1 + box2;
    cout << "The area of box3: " << box3.getAare() << endl;

    return 0;
}
```

```
// 运行结果如下:
The area of box1: 200
The area of box2: 1200
The area of box3: 2400
```



---



## 基础程序分析题

*阅读如下程序, 回答指定问题 .*

```c++
/**
 * 8.阅读程序如下程序, 回答指定问题.
 */
#include <iostream>

using namespace std;

class one {
public:
    virtual void f() {
        cout << "1";
    }
};

class two : public one {
public:
    two() {
        cout << "2";
    }
};

class three : public two {
public:
    void f() {
        two::f();
        cout << "3";
    }
};

int main() {
    // aa, bb not used
    one aa, *p;
    two bb;

    three cc;
    p = &cc;
    p -> f();

    return 0;
}
```

1. 上述程序中定义了几个类 ? 这几个类具有怎样的关系 ?

   ```
   答: 定义了三个类, 其中 one 为基类, two 和 three 为派生类, 即 two 继承自 one, 而 three 继承自 two.
   ```

2. 面向对象具有哪三大特点 ? 

   ```
   答: 那你要问 "封继多" 这个人了嘿嘿, 即封装、继承、多态.
   ```

3. 类 three 中, 函数`f()`是虚函数吗 ? 为什么 ?

   ```
   答: 是, 因为函数名前有 virtual 关键字哈.
   ```

4. 类 two 中, 有函数`f()`吗 ? 如果有, 其访问权限是怎么样的 ?

   ```
   答: 有的, 因为 two 类继承自 one 类. 其访问权限为 public.
   ```

5. main函数中, `p -> f()`的输出结果是什么 ? 这体现了面向对象的哪个特点 ?

   ```
   答: 2213
   
   two bb;
   (1).初始化 two 类时会自动调用 two 中的无参构造函数, 输出: 2
   
   three cc;
   (2).因 three 类继承自 two 类, 故初始化 three 类时会自动调用 two 类的无参构造函数, 输出: 2
   
   two::f();
   (3).调用 two 类中继承自 one 类的 f() 函数, 输出 1
   
   cout << "3";
   (4).最后输出: 3
   
   体现了面向对象的继承与多态的特点哈.
   ```




---

