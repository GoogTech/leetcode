## 简介

* `Author` : *GoogTech*
* `Website` : *https://algorithm.show*
* `Email` : *GoogTech@qq.com*
* `Date` :  *2021,6,15 ~ 2021,6,22*



---



## 基础编程题

### 1. 两数相加

#### 方法一

```cpp
/**
 * 1.两数相加
 *
 * 法一: 最简单的方法如下所示, 缺点为数据类型固定(可利用模板方法改进哈), 且无异常捕获.
 */
#include "iostream"

using namespace std;

int main() {
    int a, b;
    
    cout << "Please input a number: ";
    cin >> a;
    cout << "Please input a number again: ";
    cin >> b;
    
    cout << "The result: " << a + b;
}
```

```
// 运行结果如下:
Please input a number: 1
Please input a number again: 2
The result: 3
```

#### 方法二

```cpp
/**
 * 1.两数相加
 *
 * 法二: 利用函数模板进行改进, 这里就不加异常捕获了哈
 */
#include "iostream"

using namespace std;

// 自定义函数模板, 返回不同类型数据中的最大值
template <typename T1, typename T2>
inline T1 sum(T1 t1, T2 t2) {
    return t1 + t2;
}

int main() {
    cout << "Int type: "<< sum(1, 2) << endl;
    cout << "Double type: " << sum(1.1, 2.2) << endl;
    cout << "Int and Double type: " << sum(1, 2.2) << endl;
    return 0;
}
```

```
// 运行结果如下所示:
Int type: 3
Double type: 3.3
Int and Double type: 3
```

> ​	在 c/cpp 中, 为了解决一些频繁调用的小函数大量消耗栈空间(栈内存)的问题,特别的引入了 **inline** 修饰符,表示为内联函数.



---



### 2. 求 N 阶乘

#### 方法一

```cpp
/**
 * 2. 求 n 阶乘
 *
 * 法一: 最简单的方法是利用 for / while 循环求阶乘. 当然最好利用递归法哈
 */
#include "iostream"

using namespace std;

int main() {
    int n;
    long double result = 1; // int 类型易益出, 即错得结果0

    cout << "Please input a number: ";
    cin >> n;

    for (int i = n; i > 0; i --) {
        result =  result * i;
    }

    cout << result;

    return 0;
}
```

```
// 运行结果如下:
Please input a number: 5
The result: 120
```

#### 方法二

```cpp
/**
 * 2. 求 n 阶乘
 *
 * 法二: 利用递归求阶乘
 */
#include "iostream"

using namespace std;

inline int func(int n) {
    return (n == 1 || n == 0) ? n : n * func(n - 1);
}

int main() {
    cout << "The result: " << func(5);
}
```

```
// 运行结果如下:
The result: 120
```



---



### 3. swap()

*题目要求 : 求两个数交换函数`swap()`*

#### 方法一

```cpp
/**
 * 3.求两个数得交换函数 swap()
 *
 * 法一: 利用引用 &, 其比指针易理解哈
 * 当实参占据内存较大时,用引用代替传值( 需要复制 )可提高效率
 */
#include "iostream"

using namespace std;

void swap(int &x, int &y) {
    int t = x; x = y; y = t;
}

int main() {
    int a = 1, b = 2;

    cout << "Before a: " << a << " and b: " << b << endl;
    swap(a, b);
    cout << "After a: " << a << " and b: " << b;

    return 0;
}
```

```
// 运行结果如下:
Before a: 1 and b: 2
After a: 2 and b: 1
```

#### 方法二

```cpp
/**
 * 3.求两个数得交换函数 swap()
 *
 * 法二: 利用指针
 */
#include "iostream"

using namespace std;

inline void swap(int *x, int *y) {
    int t = *x; *x = *y; *y = t;
}

int main() {
    int a = 3, b = 4;
    cout << "Before a value: " << a << " and b value: " << b << endl;
    // &a 将 a 值赋值给 x, x 为 int* 指针, 指向 a
    swap(&a, &b);
    cout << "After a value: " << a << " and b value: " << b;

    return 0;
}
```

```
// 运行结果如下:
Before a value: 3 and b value: 4
After a value: 4 and b value: 3
```

#### 方法三

```cpp
// 加减法: a = a + b; b = a - b; a = a - b;
// 缺点: 处理浮点型的时候有可能出现精度的损失

// 乘除法: a = a * b; b = a / b; a = a / b;
// 缺点: 在处理浮点型变量时也存在精度损失问题,而且乘除的溢出比加减法严重

// 异或法: 
// a ^= b; // a = a ^ b
// b ^= a; // b = b ^ (a ^ b) = b ^ a ^ b = b ^ b ^ a = 0 ^ a = a
// a ^= b; // a = (a ^ b) ^ a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b
// 缺点: 异或法可以完成对整型变量的交换,对于浮点型变量它无法完成交换
```

#### swap源码分析

*以下 C++ 标准库源码来摘自`bits/move.h`*

```cpp
#if __cplusplus >= 201103L
#define _GLIBCXX_MOVE(__val) std::move(__val)
#else
#define _GLIBCXX_MOVE(__val) (__val)
#endif
 
template<typename _Tp>
inline void swap(_Tp& __a, _Tp& __b {
    
      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
```

分析: 

* 使用 `inline`, 即声明为内联函数来优化函数调用的开销

* 使用`右值引用(move)`, 进而节省拷贝所引发的不必要的资源浪费

  

---



### 4. 使用new运算符

*题目要求 : 使用 `new` 运算符生成一个数组, 其长度为 6*

```cpp
int *p = new int[6]; 
```

> 删除所申请得空间 : `delete[] p`



---



### 5. 设计一个类

*题目要求 : 设计一个类, 包含得属性学号(`string ID`) 和姓名 (`string name`)*

```cpp
/**
 * 5.设计一个类, 包含得属性学号(string ID) 和姓名 (string name)
 */
#include "iostream"

using namespace std;

class Student {
public:
    string id;
    string name;
public:
    void print() {
        cout << "id: " << id << " and name: " << name;
    }
};

int main() {
    Student student;
    student.id = "Z001";
    student.name = "GoogTech";
    student.print();
}
```

```
// 运行结果如下:
id: Z001 and name: GoogTech
```



---



### 6. 派生一个矩形类

*题目要求 : 设计一个形状类, 其`派生`一个矩形类*

```cpp
#include "iostream"

using namespace std;

// 形状类
class Shape {
protected:
    int width;
    int height;
public:
    void setWidth(int w) {
        width = w;
    }
    void setHeight(int h) {
        height = h;
    }
};

// 继承形状类的矩形类
class Rectangle: public Shape{
public:
    int getArea() {
        return width * height;
    }
};

int main() {
    Rectangle rectangle;
    rectangle.setHeight(10);
    rectangle.setWidth(20);

    cout << "The area of rectangle :" << rectangle.getArea() << endl;

    return 0;
}
```

```
// 运行结果如下:
The area of rectangle : 200
```



---



### 7. 重载"+"运算符

*题目要求 : 编写程序定义类PT, 有数据成员ab, 为其重载 `+` 运算符, 实现两个PT类对象相加*

```cpp
/**
 * 7.编写程序定义类 PT, 有数据成员 ab,
 * 为其重载 `+` 运算符, 实现两个 PT 类对象相加.
 */
#include "iostream"

using namespace std;

class Box {
private:
    double length;
    double width;
public:
    double getAare() {
        return length * width;
    }

    void setLength(double len) {
        length = len;
    }

    void setWidth(double wid) {
        width = wid;
    }

    // 重载运算符 "+", 用于把两个 Box 对象相加
    Box operator+(const Box& b) {
        Box box;
        box.width = this -> width + b.width;
        box.length = this -> length + b.length;
        return box;
    }
};

int main() {
    Box box1;
    Box box2;
    Box box3;

    // 初始化 box1 对象中的属性值
    box1.setWidth(10);
    box1.setLength(20);

    // 初始化 box2 对象中的属性值
    box2.setWidth(30);
    box2.setLength(40);

    // 输出 box1, box2 的面积
    cout << "The area of box1: " << box1.getAare() << endl;
    cout << "The area of box2: " << box2.getAare() << endl;

    // 把两个对象相加得到 b3, 然后输出其体积
    box3 = box1 + box2;
    cout << "The area of box3: " << box3.getAare() << endl;

    return 0;
}
```

```
// 运行结果如下:
The area of box1: 200
The area of box2: 1200
The area of box3: 2400
```



---



## 基础程序分析题

*阅读如下程序, 回答指定问题 .*

```cpp
/**
 * 8.阅读程序如下程序, 回答指定问题.
 */
#include <iostream>

using namespace std;

class one {
public:
    virtual void f() {
        cout << "1";
    }
};

class two : public one {
public:
    two() {
        cout << "2";
    }
};

class three : public two {
public:
    void f() {
        two::f();
        cout << "3";
    }
};

int main() {
    // aa, bb not used
    one aa, *p;
    two bb;

    three cc;
    p = &cc;
    p -> f();

    return 0;
}
```

1. 上述程序中定义了几个类 ? 这几个类具有怎样的关系 ?

   ```
   答: 定义了三个类, 其中 one 为基类, two 和 three 为派生类, 即 two 继承自 one, 而 three 继承自 two.
   ```

2. 面向对象具有哪三大特点 ? 

   ```
   答: 那你要问 "封继多" 这个人了嘿嘿, 即封装、继承、多态.
   ```

3. 类 three 中, 函数`f()`是虚函数吗 ? 为什么 ?

   ```
   答: 是, 因为函数名前有 virtual 关键字哈.
   ```

4. 类 two 中, 有函数`f()`吗 ? 如果有, 其访问权限是怎么样的 ?

   ```
   答: 有的, 因为 two 类继承自 one 类. 其访问权限为 public.
   ```

5. main函数中, `p -> f()`的输出结果是什么 ? 这体现了面向对象的哪个特点 ?

   ```
   答: 2213
   
   two bb;
   (1).初始化 two 类时会自动调用 two 中的无参构造函数, 输出: 2
   
   three cc;
   (2).因 three 类继承自 two 类, 故初始化 three 类时会自动调用 two 类的无参构造函数, 输出: 2
   
   two::f();
   (3).调用 two 类中继承自 one 类的 f() 函数, 输出 1
   
   cout << "3";
   (4).最后输出: 3
   
   体现了面向对象的继承与多态的特点哈.
   ```
