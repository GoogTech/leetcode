{"./":{"url":"./","title":"简介","keywords":"","body":" --> 😎 大三狗带你从零开始刷LeetCode ! const gitalk = new Gitalk({ clientID: '', clientSecret: '', repo: 'leetcode', owner: 'GoogTech', admin: ['GoogTech'], id: location.pathname, distractionFreeMode: false }); gitalk.render('gitalk-container'); --> Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/":{"url":"LeetCode刷题之旅及题目解析/","title":"LeetCode","keywords":"","body":" 📝 LeetCode刷题之旅及题目解析 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1.两数之和/1.两数之和.html":{"url":"LeetCode刷题之旅及题目解析/1.两数之和/1.两数之和.html","title":"1.两数之和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 两数之和 Java Python 1. 两数之和 https://leetcode-cn.com/problems/two-sum/ Java /* * @Author: Goog Tech * @Date: 2020-07-13 21:36:25 * @Description: #1. Two Sum * @FilePath: \\leetcode-googtech\\#1. Two Sum\\Solution.java */ import java.util.Arrays; class Solution { // 暴力法 public int[] twoSum(final int[] nums, final int target) { for (int i = 0; i Python ''' @Author: Goog Tech @Date: 2020-07-13 21:49:08 @Description: #1. Two Sum @FilePath: \\leetcode-googtech\\#1. Two Sum\\Solution.py ''' class Solution: ''' 暴力法 ''' def twoSum(self, nums, target): n = len(nums) for x in range(n): for y in range(x + 1, n): if (nums[x] + nums[y] == target): return x, y break else: continue ''' 测试 ''' print(Solution().twoSum([2, 7, 11, 15], 9)) # (0, 1) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/2.两数相加/2.两数相加.html":{"url":"LeetCode刷题之旅及题目解析/2.两数相加/2.两数相加.html","title":"2.两数相加","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 2. 两数相加 Java Python @lc app=leetcode.cn id=2 lang=python [2] 两数相加 @lc code=start 2. 两数相加 https://leetcode-cn.com/problems/add-two-numbers/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 09:54:24 * @LastEditTime: 2020-08-24 10:33:26 * @Description: https://leetcode-cn.com/problems/add-two-numbers/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\2.两数相加.java * @WebSite: https://algorithm.show/ * @Reference: https://leetcode-cn.com/problems/add-two-numbers/solution/hua-jie-suan-fa-2-liang-shu-xiang-jia-by-guanpengc/ */ /* * @lc app=leetcode.cn id=2 lang=java * * [2] 两数相加 */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { // 初始化预先指针pre,该指针的下一个节点指向真正的头结点head ListNode pre = new ListNode(0); ListNode currentNode = pre; // 初始化进位值,因每一位计算的同时需要考虑上一位的进位问题 int carry = 0; // 循环遍历链表节点,若两个链表遍历完毕后进位值为1,则将其作为新链表的尾节点 while(l1 != null || l2 != null || carry != 0) { int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry; // 舍去最后一位数值进而获得进位值 carry = sum / 10; // 获取最后一位数值并将其作为下一个节点的值,其中 1 % 10 = 1 currentNode.next = new ListNode(sum % 10); // 向后移动一位当前指针 currentNode = currentNode.next; // 判断当前链表节点是否为空 if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; } // 返回结果链表 return pre.next; } } // @lc code=end] Python ''' Author: Goog Tech Date: 2020-08-24 10:38:58 LastEditTime: 2020-08-24 10:58:47 Description: https://leetcode-cn.com/problems/add-two-numbers/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\2.两数相加.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=2 lang=python # # [2] 两数相加 # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" # 初始化预先指针pre,该指针的下一个节点指向真正的头结点head pre = ListNode(None) currentNode = pre # 初始化两链表节点与进位值之和 s = 0 # 循环遍历链表节点,若两个链表遍历完毕后进位值不为0,则将其作为新链表的尾节点 while l1 or l2 or s: s += (l1.val if l1 else 0) + (l2.val if l2 else 0) # 获取个位数值并将其作为下一个节点的值,其中 1 % 10 = 1 currentNode.next = ListNode(s % 10) # 向后移动一位当前指针 currentNode = currentNode.next # 舍去最后一位数值进而获得进位值 s //= 10 # 判断当前链表节点是否为空 l1 = l1.next if l1 else None l2 = l2.next if l2 else None # 返回结果链表 return pre.next # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/9.回文数/9.回文数.html":{"url":"LeetCode刷题之旅及题目解析/9.回文数/9.回文数.html","title":"9.回文数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 9.回文数 Java Python 9.回文数 https://leetcode-cn.com/problems/palindrome-number/ Java /* * @Author: Goog Tech * @Date: 2020-07-15 18:31:44 * @Description: https://leetcode-cn.com/problems/palindrome-number/ * @Reference: https://leetcode-cn.com/problems/palindrome-number/solution/chao-xiang-xi-tu-jie-san-chong-jie-fa-9-hui-wen-sh/ * @FilePath: \\leetcode-googtech\\#9. Palindrome Number\\Solution.java */ class Solution{ // 取模运算 public boolean isPalindrome(int x){ final int ans = x; if(ans Python ''' @Author: Goog Tech @Date: 2020-07-15 18:31:53 @Description: https://leetcode-cn.com/problems/palindrome-number/ @Reference: https://leetcode-cn.com/problems/palindrome-number/solution/chao-xiang-xi-tu-jie-san-chong-jie-fa-9-hui-wen-sh/ @FilePath: \\leetcode-googtech\\#9. Palindrome Number\\Solution.py ''' class Solution: # 反转一半数字 def isPalindrome(self, x): if x ans: ans = ans * 10 + x % 10 x = x // 10 return x == ans or x == (ans // 10) # test print(Solution().isPalindrome(121)) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/11.盛最多水的容器/11.盛最多水的容器.html":{"url":"LeetCode刷题之旅及题目解析/11.盛最多水的容器/11.盛最多水的容器.html","title":"11.盛最多水的容器","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 11. 盛最多水的容器 Java Python @lc app=leetcode.cn id=11 lang=python [11] 盛最多水的容器 @lc code=start 11. 盛最多水的容器 https://leetcode-cn.com/problems/container-with-most-water/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 12:02:50 * @LastEditTime: 2020-08-24 12:17:53 * @Description: https://leetcode-cn.com/problems/container-with-most-water/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\11.盛最多水的容器.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=11 lang=java * * [11] 盛最多水的容器 */ // @lc code=start class Solution { // 双指针法 public int maxArea(int[] height) { // 初始化左右指针及结果面积的值 int left = 0, right = height.length - 1, result = 0; // 通过移动左右指针来循环遍历数组元素 while(left Python ''' Author: Goog Tech Date: 2020-08-24 11:45:49 LastEditTime: 2020-08-24 12:06:36 Description: FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\11.盛最多水的容器.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=11 lang=python # # [11] 盛最多水的容器 # # @lc code=start class Solution(object): # 双指针法 def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" # 初始化双指针及最值面积的值 left, right, result = 0, len(height) - 1, 0 # 通过移动左右指针来循环遍历数组元素 while left Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/14.最长公共前缀/14.最长公共前缀.html":{"url":"LeetCode刷题之旅及题目解析/14.最长公共前缀/14.最长公共前缀.html","title":"14.最长公共前缀","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 14. 最长公共前缀 Java Python @lc app=leetcode.cn id=14 lang=python [14] 最长公共前缀 @lc code=start 14. 最长公共前缀 https://leetcode-cn.com/problems/longest-common-prefix/ Java /* * @Author: Goog Tech * @Date: 2020-08-23 21:57:58 * @LastEditTime: 2020-08-23 22:28:04 * @Description: https://leetcode-cn.com/problems/longest-common-prefix/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\14.最长公共前缀.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=14 lang=java * * [14] 最长公共前缀 */ // @lc code=start class Solution { public String longestCommonPrefix(String[] strs) { // 待解. . . } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-23 22:07:22 LastEditTime: 2020-08-23 22:11:34 Description: https://leetcode-cn.com/problems/longest-common-prefix/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\14.最长公共前缀.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=14 lang=python # # [14] 最长公共前缀 # # @lc code=start class Solution(object): # 解题思路: 先找出数组中字典序最小和最大的字符串, # 而最长公共前缀即为这两个字符串的公共前缀哟 def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if not strs: return '' minStr, maxStr = min(strs), max(strs) for i in range(len(minStr)): if minStr[i] != maxStr[i]: return minStr[:i] return minStr # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/19.删除链表的倒数第N个节点/19.删除链表的倒数第N个节点.html":{"url":"LeetCode刷题之旅及题目解析/19.删除链表的倒数第N个节点/19.删除链表的倒数第N个节点.html","title":"19.删除链表的倒数第N个节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 19. 删除链表的倒数第N个节点 Java Python 19. 删除链表的倒数第N个节点 https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ Java /* * @Author: Goog Tech * @Date: 2020-07-22 19:59:46 * @Description: https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ * @FilePath: \\leetcode-googtech\\#19. Remove Nth Node From End of List\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 双指针法 public ListNode removeNthFromEnd(final ListNode head, final int n) { // 判断头节点是否为空 if(head==null) { return null; } // fastNode指向待删节点的后节点,slowNode指向待删节点的前节点 ListNode fastNode = head; ListNode slowNode = head; // 移动快指针,使其指待删节点的前节点 for(int i=0;i Python ''' @Author: Goog Tech @Date: 2020-07-22 19:59:53 @Description: https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ @FilePath: \\leetcode-googtech\\#19. Remove Nth Node From End of List\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # 双指针法 def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" # 快指针指向待删节点的后一个节点 # 慢指针指向待删节点的前一个节点 firstNode, slowNode = head, head # 移动快指针,使其指向待删节点的前一个节点 for i in range(n): firstNode = firstNode.next # 待删节点即为第一个节点 if firstNode is None: return head.next # 同时移动快慢指针 # 当快指针指向尾节点时,慢指针指向待删节点的前一个节点 while firstNode.next != None: firstNode = firstNode.next slowNode = slowNode.next # 更新待删节点的前节点的指针,即移除待删节点 slowNode.next = slowNode.next.next return head Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/20.有效的括号/20.有效的括号.html":{"url":"LeetCode刷题之旅及题目解析/20.有效的括号/20.有效的括号.html","title":"20.有效的括号","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 20. 有效的括号 Java Python 20. 有效的括号 https://leetcode-cn.com/problems/valid-parentheses/ Java /* * @Author: Goog Tech * @Date: 2020-07-16 20:45:04 * @Description: https://leetcode-cn.com/problems/valid-parentheses/ * @FilePath: \\leetcode-googtech\\#20. Valid Parentheses\\Solution.java */ class Solution { public boolean isValid(String s) { // 初始化栈 Stack stack = new Stack(); // 遍历字符串,逐个比较字符 for(char c:s.toCharArray()){ // 将左括号压入栈中 if(c=='('){ stack.push(')'); }else if(c=='['){ stack.push(']'); }else if(c=='{'){ stack.push('}'); // 弹出左括号并与右括号相比较 }else if(stack.isEmpty()||c!=stack.pop()){ return false; } } // 如果左右括号全部匹配完毕则栈为空 return stack.isEmpty(); } } Python ''' @Author: Goog Tech @Date: 2020-07-16 20:45:17 @Description: https://leetcode-cn.com/problems/valid-parentheses/ @FilePath: \\leetcode-googtech\\#20. Valid Parentheses\\Solution.py ''' class Solution(object): def isValid(self, symbolString): \"\"\" :type s: str :rtype: bool \"\"\" index = 0 stack = [] opens = \"([{\" closers = \")]}\" balanced = True # 遍历字符串中的字符(括号) while index Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/21.合并两个有序链表/21.合并两个有序链表.html":{"url":"LeetCode刷题之旅及题目解析/21.合并两个有序链表/21.合并两个有序链表.html","title":"21.合并两个有序链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 21. 合并两个有序链表 Video Java Python @lc app=leetcode.cn id=21 lang=python [21] 合并两个有序链表 @lc code=start 21. 合并两个有序链表 https://leetcode-cn.com/problems/merge-two-sorted-lists/ Video Java /* * @Author: Goog Tech * @Date: 2020-07-27 18:38:24 * @Description: https://leetcode-cn.com/problems/merge-two-sorted-lists/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\21.合并两个有序链表.java */ /* * @lc app=leetcode.cn id=21 lang=java * * [21] 合并两个有序链表 */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { // 迭代法 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 判断链表是否为空 if(l1 == null) return l2; if(l2 == null) return l1; // 初始化哨兵节点与其头指针 ListNode preHead = new ListNode(-1); ListNode currentNode = preHead; // 遍历链表并逐个比较两节点大小,通过移动哨兵节点头指针来构建新链表 while(l1 != null && l2 != null) { if(l1.val >= l2.val) { currentNode.next = l2; l2 = l2.next; }else { currentNode.next = l1; l1 = l1.next; } // 每比较一次,哨兵头指针都需要往后移动一位 currentNode = currentNode.next; } //l1与l2合并结束后,最多还剩一个链表是非空的,这时需将链表末尾指向未合并完的链表 currentNode.next = l2 == null ? l1 : l2; return preHead.next; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-27 18:37:11 @Description: https://leetcode-cn.com/problems/merge-two-sorted-lists/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\21.合并两个有序链表.py ''' # # @lc app=leetcode.cn id=21 lang=python # # [21] 合并两个有序链表 # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): # 迭代法 def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" # 判断链表是否为空 if not l1 or not l2: return l2 or l1 # 初始化哨兵节点与其头指针 preHead = ListNode(-1) currentNode = preHead # 遍历链表并逐个比较两个节点大小,通过移动哨兵节点指针来构建新链表 while l1 and l2: if l1.val >= l2.val: currentNode.next, l2 = l2, l2.next else: currentNode.next, l1 = l1, l1.next # 每比较一次,哨兵头指针都需要往后移动一位 currentNode = currentNode.next #l1与l2合并结束后,最多还剩一个链表是非空的,这时需将链表末尾指向未合并完的链表 currentNode.next = l2 if l2 is not None else l1 return preHead.next # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/22.括号生成/22.括号生成.html":{"url":"LeetCode刷题之旅及题目解析/22.括号生成/22.括号生成.html","title":"22.括号生成","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 22. 括号生成 Java Python 22. 括号生成 https://leetcode-cn.com/problems/generate-parentheses/ Java /* * @Author: Goog Tech * @Date: 2020-10-27 16:14:11 * @LastEditTime: 2020-10-27 16:15:23 * @Description: https://leetcode-cn.com/problems/generate-parentheses/ * @FilePath: \\leetcode-googtech\\#22. Generate Parentheses\\Solution.java * @WebSite: https://algorithm.show/ * @Reference: https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/ */ class Solution { List result = new ArrayList<>(); public List generateParenthesis(int n) { dfs(n, n, \"\"); return result; } // DFS : 深度优先搜索算法 private void dfs(int left, int right, String str) { // 在左边和右边剩余的括号数都等于 0 的时候结算 if(left == 0 && right == 0) { result.add(str); return; } // 生成左枝叶的条件是: 左括号剩余数量大于 0 if(left > 0) { dfs(left - 1, right, str + \"(\"); } // 生成右枝叶的条件是: 左括号剩余数量小于右括号剩余数量 if(right > left) { dfs(left, right - 1, str + \")\"); } } } Python ''' Author: Goog Tech Date: 2020-10-27 16:14:18 LastEditTime: 2020-10-27 16:15:08 Description: https://leetcode-cn.com/problems/generate-parentheses/ FilePath: \\leetcode-googtech\\#22. Generate Parentheses\\Solution.py WebSite: https://algorithm.show/ Reference: https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/ ''' class Solution(object): # DFS : 深度优先搜索算法 def generateParenthesis(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" result, string = [], '' def dfs(left, right, string): # 在左边和右边剩余的括号数都等于 0 的时候结算 if left == 0 and right == 0: result.append(string) return # 生成右枝叶的条件是: 左括号剩余数量小于右括号剩余数量 if right 0: dfs(left - 1, right, string + '(') if right > 0: dfs(left, right - 1, string + ')') dfs(n, n , string) return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/26.删除排序数组中的重复项/26.删除排序数组中的重复项.html":{"url":"LeetCode刷题之旅及题目解析/26.删除排序数组中的重复项/26.删除排序数组中的重复项.html","title":"26.删除排序数组中的重复项","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 26. 删除排序数组中的重复项 Java Python @lc app=leetcode.cn id=26 lang=python [26] 删除排序数组中的重复项 @lc code=start 26. 删除排序数组中的重复项 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 08:01:32 * @LastEditTime: 2020-08-04 08:09:33 * @Description: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.java * @Reference: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/ */ /* * @lc app=leetcode.cn id=26 lang=java * * [26] 删除排序数组中的重复项 */ // @lc code=start class Solution { // 双指针法 public int removeDuplicates(int[] nums) { // 判断数组长度及是否为空 if(nums == null || nums.length == 0) return 0; // 初始化前后指针 int left = 0, right = 1; // 通过移动前后指针来遍历数组中的元素 while(right Python ''' Author: Goog Tech Date: 2020-08-04 07:46:24 LastEditTime: 2020-08-04 08:11:09 Description: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.py Reference: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/ ''' # # @lc app=leetcode.cn id=26 lang=python # # [26] 删除排序数组中的重复项 # # @lc code=start class Solution(object): # 双指针法 def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # 判断数组长度及是否为空 if not nums or len(nums) == 0: return 0 # 初始化前后指针 left, right = 0, 1 # 通过移动后指针来遍历数组的中元素 while right Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/27.移除元素/27.移除元素.html":{"url":"LeetCode刷题之旅及题目解析/27.移除元素/27.移除元素.html","title":"27.移除元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 27. 移除元素 Java Python 27. 移除元素 https://leetcode-cn.com/problems/remove-element/ Java /* * @Author: Goog Tech * @Date: 2020-07-22 21:58:21 * @Description: https://leetcode-cn.com/problems/remove-element/ * @FilePath: \\leetcode-googtech\\#27. Remove Element\\Solution.java */ class Solution { public int removeElement(int[] nums, int val) { int count = 0; for(int i=0;i Python ''' @Author: Goog Tech @Date: 2020-07-22 21:58:29 @Description: https://leetcode-cn.com/problems/remove-element/ @FilePath: \\leetcode-googtech\\#27. Remove Element\\Solution.py ''' class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" while val in nums: nums.remove(val) return len(nums) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/28.实现strStr/28.实现strStr.html":{"url":"LeetCode刷题之旅及题目解析/28.实现strStr/28.实现strStr.html","title":"28.实现strStr()","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 28. 实现 strStr() Java Python 28. 实现 strStr() https://leetcode-cn.com/problems/implement-strstr/ Java /* * @Author: Goog Tech * @Date: 2020-08-25 16:42:06 * @LastEditTime: 2020-08-25 16:42:32 * @Description: https://leetcode-cn.com/problems/implement-strstr/ * @FilePath: \\leetcode-googtech\\#28. Implement strStr()\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // &#x1F605;理应使用 KMP 算法,这里简单使用 API 啦 public int strStr(String haystack, String needle) { // 分别获取两个字符串的长度 int needleLength = needle.length(); int haystackLength = haystack.length(); // 遍历字符串,其中 haystackLength - needleLength 是为了防止 substring 下标越界 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-25 16:42:12 LastEditTime: 2020-08-25 16:42:51 Description: https://leetcode-cn.com/problems/implement-strstr/ FilePath: \\leetcode-googtech\\#28. Implement strStr()\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # &#x1F605;理应使用 KMP 算法,这里简单使用 API 啦 def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" # 判断 needle 字符串是否为空 if needle == \"\": return 0 # 分别获取两个字符串的长度 haystackLength, needleLength = len(haystack), len(needle) # 遍历字符串,其中 len(haystack) - len(needle) 是为了防止 haystack[i : i + needleLength] 下标越界 for i in range(0, haystackLength - needleLength + 1): # 判断 needle 字符串是否与下标范围为 i 到 i + needleLength 所分割的字符串相等 if haystack[i : i + needleLength] == needle: # 若相等则返回 needle 字符串出现的第一个位置的下标值 return i # 无果 return -1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/35.搜索插入位置/35.搜索插入位置.html":{"url":"LeetCode刷题之旅及题目解析/35.搜索插入位置/35.搜索插入位置.html","title":"35.搜索插入位置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 35. 搜索插入位置 Java Python 35. 搜索插入位置 https://leetcode-cn.com/problems/search-insert-position/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 12:32:36 * @LastEditTime: 2020-08-04 12:33:09 * @Description: https://leetcode-cn.com/problems/search-insert-position/ * @FilePath: \\leetcode-googtech\\#35. Search Insert Position\\Solution.java */ class Solution { public int searchInsert(int[] nums, int target) { for(int i = 0; i = target) { return i; } } return nums.length; } } Python ''' Author: Goog Tech Date: 2020-08-04 12:32:42 LastEditTime: 2020-08-04 12:33:35 Description: https://leetcode-cn.com/problems/search-insert-position/ FilePath: \\leetcode-googtech\\#35. Search Insert Position\\Solution.py ''' class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" for i in range(len(nums)): if nums[i] >= target: return i return len(nums) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/41.缺失的第一个正数/41.缺失的第一个正数.html":{"url":"LeetCode刷题之旅及题目解析/41.缺失的第一个正数/41.缺失的第一个正数.html","title":"41.缺失的第一个正数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 41. 缺失的第一个正数 Java Python 41. 缺失的第一个正数 https://leetcode-cn.com/problems/first-missing-positive/ Java /* * @Author: Goog Tech * @Date: 2020-08-27 17:33:58 * @LastEditTime: 2020-08-27 17:34:17 * @Description: https://leetcode-cn.com/problems/first-missing-positive/ * @FilePath: \\leetcode-googtech\\#41. First Missing Positive\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 原地修改法 public int firstMissingPositive(int[] nums) { // 获取数组的长度 int n = nums.length; // 遍历数组,将所有小于等于零的数修改成任意一个大于 N 的数,例如 N + 1 for(int i = 0; i 0) { return i + 1; } } return n + 1; } } Python ''' Author: Goog Tech Date: 2020-08-27 17:34:02 LastEditTime: 2020-08-27 17:34:43 Description: https://leetcode-cn.com/problems/first-missing-positive/ FilePath: \\leetcode-googtech\\#41. First Missing Positive\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 原地修改法 def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # 获取数组的长度 n = len(nums) # 遍历数组,将所有小于等于零的数修改成任意一个大于 N 的数,例如 N + 1 for i in range(n): if nums[i] 0: return i + 1 return n + 1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/46.全排列/46.全排列.html":{"url":"LeetCode刷题之旅及题目解析/46.全排列/46.全排列.html","title":"46.全排列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 46. 全排列 Java Python 46. 全排列 https://leetcode-cn.com/problems/permutations/ Java /* * @Author: Goog Tech * @Date: 2020-10-27 15:42:40 * @LastEditTime: 2020-10-27 15:43:10 * @Description: https://leetcode-cn.com/problems/permutations/ * @FilePath: \\leetcode-googtech\\#46. Permutations\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public List> permute(int[] nums) { List> result = new ArrayList<>(); List list = new ArrayList<>(); backtrack(result, list, nums); return result; } // BackTrack : 回溯算法 public void backtrack(List> result, List list, int[] nums) { if(list.size() == nums.length) { result.add(new ArrayList(list)); return; } for(int num : nums) { if(!list.contains(num)) { list.add(num); backtrack(result, list, nums); // 继续递归填下一个数 list.remove(list.size() - 1); } } } } Python ''' Author: Goog Tech Date: 2020-10-27 15:42:46 LastEditTime: 2020-10-27 15:43:29 Description: https://leetcode-cn.com/problems/permutations/ FilePath: \\leetcode-googtech\\#46. Permutations\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def permute(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" # 使用内置函数 return list(itertools.permutations(nums)) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/53.最大子序和/53.最大子序和.html":{"url":"LeetCode刷题之旅及题目解析/53.最大子序和/53.最大子序和.html","title":"53.最大子序和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 53. 最大子序和 Java Python 53. 最大子序和 https://leetcode-cn.com/problems/maximum-subarray/ Java /* * @Author: Goog Tech * @Date: 2020-09-15 13:44:15 * @LastEditTime: 2020-09-15 13:44:36 * @Description: https://leetcode-cn.com/problems/maximum-subarray/ * @FilePath: \\leetcode-googtech\\#53. Maximum Subarray\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // DP : 动态规划,解题思路如下所示: // 1. 首先对数组进行遍历,设当前最大连续子序列和为 sum, 结果为 result // 2. 若 sum > 0,则说明 sum 对结果有增益效果,进而将当前所遍历的数字累加到 sum // 3. 若 sum 0) sum += num; else sum = num; result = Math.max(result, sum); } return result; } } Python ''' Author: Goog Tech Date: 2020-09-15 13:44:20 LastEditTime: 2020-09-15 13:44:46 Description: https://leetcode-cn.com/problems/maximum-subarray/ FilePath: \\leetcode-googtech\\#53. Maximum Subarray\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # DP : 动态规划 def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" for i in range(1, len(nums)): if nums[i - 1] > 0: nums[i] += nums[i - 1] return max(nums) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/58.最后一个单词的长度/58.最后一个单词的长度.html":{"url":"LeetCode刷题之旅及题目解析/58.最后一个单词的长度/58.最后一个单词的长度.html","title":"58.最后一个单词的长度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 58. 最后一个单词的长度 Java Python 58. 最后一个单词的长度 https://leetcode-cn.com/problems/length-of-last-word/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 14:34:03 * @LastEditTime: 2020-08-24 14:34:15 * @Description: https://leetcode-cn.com/problems/length-of-last-word/ * @FilePath: \\leetcode-googtech\\#58. Length of Last Word\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int lengthOfLastWord(String s) { // 初始化字符串尾部指针及结果值 int result = 0, tail = s.length() - 1; // 首先删除字符串尾部空格 while(tail >= 0 && s.charAt(tail) == ' ') { tail -= 1; } // 计数最后一个单词的长度 while(tail >= 0 && s.charAt(tail) != ' ') { result += 1; tail -= 1; } // 返回结果 return result; } } Python ''' Author: Goog Tech Date: 2020-08-24 14:34:07 LastEditTime: 2020-08-24 14:34:36 Description: https://leetcode-cn.com/problems/length-of-last-word/ FilePath: \\leetcode-googtech\\#58. Length of Last Word\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\" # 初始化字符串尾部指针及结果值 result, tail = 0, len(s) - 1 # 首先删除字符串末尾空格 while tail >= 0 and s[tail] == ' ': tail -= 1 # 计数最后一个单词的长度 while tail >= 0 and s[tail] != ' ': result += 1 tail -= 1 # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/66.加一/66.加一.html":{"url":"LeetCode刷题之旅及题目解析/66.加一/66.加一.html","title":"66.加一","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 66. 加一 Java Python 66. 加一 https://leetcode-cn.com/problems/plus-one/ Java /* * @Author: Goog Tech * @Date: 2020-08-25 11:46:53 * @LastEditTime: 2020-08-25 11:47:15 * @Description: https://leetcode-cn.com/problems/plus-one/ * @FilePath: \\leetcode-googtech\\#66. Plus One\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int[] plusOne(int[] digits) { // 从尾到头遍历数组 for(int i = digits.length - 1; i >= 0; i--) { // 尾部元素数值加一 digits[i]++; // 取元素的个位数值 digits[i] = digits[i] % 10; // 若无进位即 digits[i] != 0 则返回修改后的 digits, // 反之继续遍历直到判断没有再进位,然后退出遍历并返回结果 if(digits[i] != 0) return digits; } // 针对一些特殊情况,例如遇到 99 之类的数字时,循环到最后还是需要进位 // 出现这种情况时需要手动将它进一位,然后返回结果 digits = new int[digits.length + 1]; digits[0] = 1; return digits; } } Python ''' Author: Goog Tech Date: 2020-08-25 11:46:58 LastEditTime: 2020-08-25 11:49:44 Description: https://leetcode-cn.com/problems/plus-one/ FilePath: \\leetcode-googtech\\#66. Plus One\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\" # 从尾到头遍历数组 for i in range(len(digits) - 1, -1, -1): # 若当前元素数值为 9 则用 0 替换 if digits[i] == 9: digits[i] = 0 # 反之尾部元素数值加一,然后退出循环并返回结果 else: digits[i] = digits[i] + 1 return digits # 针对一些特殊情况,例如遇到 99 之类的数字时,循环进位到最后导致首位为 0 # 出现这种情况时需要手动将它进一位,然后返回结果 if digits[0] == 0: digits.insert(0, 1) return digits Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/70.爬楼梯/70.爬楼梯.html":{"url":"LeetCode刷题之旅及题目解析/70.爬楼梯/70.爬楼梯.html","title":"70.爬楼梯","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 70. 爬楼梯 Java Python 70. 爬楼梯 https://leetcode-cn.com/problems/climbing-stairs/ Java /* * @Author: Goog Tech * @Date: 2020-09-16 13:39:46 * @LastEditTime: 2020-09-16 13:40:07 * @Description: https://leetcode-cn.com/problems/climbing-stairs/ * @FilePath: \\leetcode-googtech\\#70. Climbing Stairs\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // DP : 动态规划 // 解题思路 : 爬 i 层楼梯的方式数 = 爬 i-2 层楼梯的方式数 + 爬 i-1 层楼梯的方式数, // 所以我们得到公式 dp[n] = dp[n-1] + dp[n-2] public int climbStairs(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for(int i = 2; i Python ''' Author: Goog Tech Date: 2020-09-16 13:39:52 LastEditTime: 2020-09-16 13:40:15 Description: https://leetcode-cn.com/problems/climbing-stairs/ FilePath: \\leetcode-googtech\\#70. Climbing Stairs\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # DP : 动态规划 # 解题思路 : 爬 i 层楼梯的方式数 = 爬 i-2 层楼梯的方式数 + 爬 i-1 层楼梯的方式数, # 所以我们得到公式 dp[n] = dp[n-1] + dp[n-2] def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" # 还是 DP,只不过只存储了前两个元素,将空间复杂度降低到 O(1) if n == 1 or n == 2: return n n_1, n_2, result = 1, 2, 0 for i in range(3, n + 1): result = n_1 + n_2 n_1 = n_2 n_2 = result return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/78.子集/78.子集.html":{"url":"LeetCode刷题之旅及题目解析/78.子集/78.子集.html","title":"78.子集","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 78. 子集 Java Python 78. 子集 https://leetcode-cn.com/problems/subsets/ Java /* * @Author: Goog Tech * @Date: 2020-10-27 14:18:51 * @LastEditTime: 2020-10-27 14:24:07 * @Description: https://leetcode-cn.com/problems/subsets/ * @FilePath: \\leetcode-googtech\\#78. Subsets\\Solution.java * @WebSite: https://algorithm.show/ * @Reference: https://leetcode-cn.com/problems/subsets/solution/hui-su-wei-yun-suan-di-gui-deng-gong-4chong-fang-s/ */ class Solution { // 迭代 public List> subsets(int[] nums) { List> result = new ArrayList<>(); // 首先添加一个空集合 result.add(new ArrayList<>()); // 遍历原数组中的元素 for(int i = 0; i temp = new ArrayList<>(result.get(j)); // 然后在新的子集后面追加这个元素 temp.add(nums[i]); // 最后把这个新的子集添加到结果集合中 result.add(temp); } } // 返回结果集合 return result; } } Python ''' Author: Goog Tech Date: 2020-10-27 14:18:56 LastEditTime: 2020-10-27 14:20:21 Description: https://leetcode-cn.com/problems/subsets/ FilePath: \\leetcode-googtech\\#78. Subsets\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 迭代 def subsets(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" result = [[]] for i in nums: result = result + [[i] + num for num in result] return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/82.删除排序链表中的重复元素II/82.删除排序链表中的重复元素II.html":{"url":"LeetCode刷题之旅及题目解析/82.删除排序链表中的重复元素II/82.删除排序链表中的重复元素II.html","title":"82.删除排序链表中的重复元素II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 82. 删除排序链表中的重复元素II Java Python @lc app=leetcode.cn id=82 lang=python [82] 删除排序链表中的重复元素 II @lc code=start 82. 删除排序链表中的重复元素II https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 16:48:30 * @LastEditTime: 2020-08-15 17:33:33 * @Description: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/ * @FilePath: \\leetcode-googtech\\#82. Remove Duplicates from Sorted List II\\Solution.java * @Reference: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/cai-niao-di-yi-ci-xie-ti-jie-zhi-shi-dui-jie-ti-gu/ * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=82 lang=java * * [82] 删除排序链表中的重复元素 II */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { // 初始化辅助节点 ListNode listNode = new ListNode(0); listNode.next = head; // 初始化辅助节点指针 ListNode currentNode = listNode; // 通过移动当前指针 currrentNode 来循环遍历链表 while(currentNode.next != null && currentNode.next.next != null) { // 判断当前节点的下一个节点(真实链表的头节点)的值与下下个节点的值是否相同 if(currentNode.next.val == currentNode.next.next.val) { // 初始化待删节点,即将重复的节点视为单独的一个链表 // 有重复就将指向待删节点的指针往后移,直到指向待删链表的最后一个节点 ListNode tempNode = currentNode.next; while(tempNode != null && tempNode.next != null && tempNode.val == tempNode.next.val) { tempNode = tempNode.next; } // 将待删接节点的前节点指针指向 tempNode 的后一个节点,即可实现删除所有重复节点 currentNode.next = tempNode.next; }else { // 继续移动当前节点指针,进入下一个循环来继续判断链表中是否有相邻重复的节点 currentNode = currentNode.next; } } // 返回真实链表的头节点 return listNode.next; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-15 17:13:45 LastEditTime: 2020-08-15 17:33:03 Description: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/ FilePath: \\leetcode-googtech\\#82. Remove Duplicates from Sorted List II\\Solution.py Reference: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/cai-niao-di-yi-ci-xie-ti-jie-zhi-shi-dui-jie-ti-gu/ WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=82 lang=python # # [82] 删除排序链表中的重复元素 II # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 初始化辅助节点 listNode = ListNode() listNode.next = head # 初始化辅助节点指针 currentNode = listNode # 通过移动当前节点指针 currentNode 来循环遍历链表 while currentNode.next is not None and currentNode.next.next is not None: # 判断当前节点的下一个节点(真实链表的头节点)的值与下下个节点的值是否相同 if currentNode.next.val == currentNode.next.next.val: # 初始化待删节点,即将重复的节点视为单独的一个链表 # 有重复就将指向待删节点的指针往后移,直到指向待删链表的最后一个节点 tempNode = currentNode.next while tempNode is not None and tempNode.next is not None and tempNode.val == tempNode.next.val: tempNode = tempNode.next # 将待删节点的前节点指针指向 tempNode 的后一个节点,即可实现删除所有重复节点 currentNode.next = tempNode.next # 继续移动当前节点指针,进入下一个循环来继续判断链表中是否有相邻重复的节点 else: currentNode = currentNode.next return listNode.next # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/83.删除排序链表中的重复元素/83.删除排序链表中的重复元素.html":{"url":"LeetCode刷题之旅及题目解析/83.删除排序链表中的重复元素/83.删除排序链表中的重复元素.html","title":"83.删除排序链表中的重复元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 83. 删除排序链表中的重复元素 Java Python 83. 删除排序链表中的重复元素 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ Java /* * @Author: Goog Tech * @Date: 2020-07-18 21:48:10 * @Description: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ * @FilePath: \\leetcode-googtech\\#83. Remove Duplicates from Sorted List\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode currentNode = head; // 判断头节点是否为空 if(head==null || head.next==null){ return head; } // 遍历寻找并删除重复节点 while(currentNode.next!=null){ if(currentNode.val == currentNode.next.val){ currentNode.next = currentNode.next.next; }else{ currentNode = currentNode.next; } } // 返回头节点 return head; } } Python ''' @Author: Goog Tech @Date: 2020-07-18 21:48:22 @Description: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ @FilePath: \\leetcode-googtech\\#83. Remove Duplicates from Sorted List\\Soultion.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" currentNode = head # 判断头节点是否为空 if not head: return head # 遍历寻找及删除重复节点 while currentNode.next: if currentNode.val == currentNode.next.val: currentNode.next = currentNode.next.next else: currentNode = currentNode.next # 返回头节点 return head Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/88.合并两个有序数组/88.合并两个有序数组.html":{"url":"LeetCode刷题之旅及题目解析/88.合并两个有序数组/88.合并两个有序数组.html","title":"88.合并两个有序数组","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 88. 合并两个有序数组 Java Python @lc app=leetcode.cn id=88 lang=python [88] 合并两个有序数组 @lc code=start 88. 合并两个有序数组 https://leetcode-cn.com/problems/merge-sorted-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 08:55:36 * @LastEditTime: 2020-08-24 09:08:00 * @Description: https://leetcode-cn.com/problems/merge-sorted-array/ * @FilePath: \\leetcode-googtech\\#88. Merge Sorted Array\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=88 lang=java * * [88] 合并两个有序数组 */ // @lc code=start class Solution { // 先合并后排序: 但这种方法没有利用两个数组本身已经有序这一点 public void merge(int[] nums1, int m, int[] nums2, int n) { // arraycopy(Object src,int srcPos,Object dest, int destPos,int length)； System.arraycopy(nums2, 0, nums1, m , n); Arrays.sort(nums1); } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-24 08:49:22 LastEditTime: 2020-08-24 09:03:04 Description: https://leetcode-cn.com/problems/merge-sorted-array/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\88.合并两个有序数组.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=88 lang=python # # [88] 合并两个有序数组 # # @lc code=start class Solution(object): # 先合并后排序: 但这种方法没有利用两个数组本身已经有序这一点 def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. \"\"\" # nums1[:] 等价于 nums1[0 : len(nums1)] 相当于取 nums1 对应的对象的一个视图 nums1[0 : len(nums1)] = sorted(nums1[:m] + nums2[:n]) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/94.二叉树的中序遍历/94.二叉树的中序遍历.html":{"url":"LeetCode刷题之旅及题目解析/94.二叉树的中序遍历/94.二叉树的中序遍历.html","title":"94.二叉树的中序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 94. 二叉树的中序遍历 Java Python @lc app=leetcode.cn id=94 lang=python [94] 二叉树的中序遍历 @lc code=start 94. 二叉树的中序遍历 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-26 21:00:03 * @Description: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/comments/ * @FilePath: \\leetcode-googtech\\#94. Binary Tree Inorder Traversal\\Solution.java */ /* * @lc app=leetcode.cn id=94 lang=java * * [94] 二叉树的中序遍历 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归法 List list = new ArrayList<>(); public List inorderTraversal(TreeNode root) { if(root != null) { inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right); } // [] + [1] + [3,2] return list; } // 迭代法 public List inorderTraversal(TreeNode root) { // 初始化辅助栈及结果列表 Stack stack = new Stack<>(); List result = new LinkedList<>(); // 判断头节点是否为空 if(root == null) return result; // 遍历辅助栈 while(root != null || !stack.isEmpty()) { // 遍历根节点的左孩子节点并将其依次压入栈中,直到为空然后进入操作2 if(root != null) { // 操作1 stack.push(root); root = root.left; // 弹出栈顶元素,若其有右孩子,则将右孩子节点压入栈中,随后重复操作1 }else { // 操作2 root = stack.pop(); result.add(root.val); root = root.right; } } return result; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-26 19:19:05 @Description: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ @FilePath: \\leetcode-googtech\\#94. Binary Tree Inorder Traversal\\94.二叉树的中序遍历.py ''' # # @lc app=leetcode.cn id=94 lang=python # # [94] 二叉树的中序遍历 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归法 def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" if root is None: return [] # [] + [1] + [2,3] return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) # 迭代法 def inorderTraversal(self, root): # 初始化辅助栈及结果列表 result, stack = [], [] # 判断头节点是否为空 if root is None: return result currentNode = root # 遍历辅助栈 while stack or currentNode: # 遍历根节点的左孩子节点并将其依次压入栈中,直到为空然后进入操作2 if currentNode is not None: # 操作1 stack.append(currentNode) currentNode = currentNode.left # 弹出栈顶元素,若其有右孩子,则将右孩子节点压入栈中,随后重复操作1 else: # 操作2 currentNode = stack.pop() result.append(currentNode.val) currentNode = currentNode.right return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/94.144.145.二叉树的前中后序遍历模板/94.144.145.二叉树的前中后序遍历模板.html":{"url":"LeetCode刷题之旅及题目解析/94.144.145.二叉树的前中后序遍历模板/94.144.145.二叉树的前中后序遍历模板.html","title":"94.144.145.二叉树的前中后序遍历模板","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 94. 144. 145. 二叉树的前中后序遍历模板 Java Python 94. 144. 145. 二叉树的前中后序遍历模板 Java /* * @Author: Goog Tech * @Date: 2020-07-27 10:56:38 * @Description: #94 #144 #145: Binary Tree Traversal Template * @FilePath: \\leetcode-googtech\\#94 #144 #145 Binary Tree Traversal Template\\Template.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /** * 前序遍历:递归法 */ List result = new ArrayList<>(); public List preorderTraversal(TreeNode root) { if(root == null) return new ArrayList(); result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return result; } /** * 中序遍历:递归法 */ List result = new ArrayList<>(); public List inorderTraversal(TreeNode root) { if(root == null) return new ArrayList<>(); inorderTraversal(root.left); result.add(root.val); inorderTraversal(root.right); return result; } /** * 后续遍历:递归法 */ List result = new ArrayList<>(); public List postorderTraversal(TreeNode root) { if(root == null) return new ArrayList<>(); postorderTraversal(root.left); postorderTraversal(root.right); result.add(root.val); return result; } /** * 前序遍历:迭代法一 */ public List preorderTraversal(TreeNode root) { // 判断头节点是否为空 if(root == null) return new ArrayList(); // 声明辅助栈及结果链表 TreeNode currentNode = root; List result = new ArrayList<>(); Stack stack = new Stack<>(); // 循环遍历辅助栈 while(currentNode != null || !stack.isEmpty()) { // 将左孩子节点压入栈中并存储到结果链表中 while(currentNode != null) { stack.push(currentNode); result.add(currentNode.val); currentNode = currentNode.left; } // 更新当前节点为其右孩子节点,进入下一个循环 currentNode = stack.pop(); currentNode = node.right; } return result; } /** * 中序遍历:迭代法一 */ public List inorderTraversal(TreeNode root) { // 判断头节点是否为空 if(root == null) return new ArrayList<>(); // 声明辅助栈及结果链表 TreeNode currentNode = root; List result = new ArrayList<>(); Stack stack = new Stack<>(); // 循环遍历辅助栈 while(currentNode != null || !stack.isEmpty()) { // 将左孩子节点压入栈中 while(currentNode != null) { stack.push(currentNode); currentNode = currentNode.left; } // 出栈并将其存储到结果链表中 currentNode = stack.pop(); result.add(currentNode.val); // 更新当前节点为右孩子节点,进入下一个循环 currentNode = currentNode.right; } return result; } /** * 后序遍历:迭代法一 * 在后序遍历中每个节点需要访问两次,即当遍历完左子树后需要访问当前节点, * 之后遍历完右子树后还需要访问当前节点,但只有在第二次访问时才处理当前节点. */ public List postorderTraversal(TreeNode root) { // 判断头节点是否为空 if(root == null) return new ArrayList(); // previousNode为当前节点的前一个节点,用于区分之前的节点是否被访问过 TreeNode currentNode = root; TreeNode previousNode = null; // 声明辅助栈及结果链表 List result = new ArrayList<>(); Stack stack = new Stack<>(); // 循环遍历辅助栈 while(currentNode != null || !stack.isEmpty()) { while(currentNode != null) { stack.push(currentNode); currentNode = currentNode.left; } // 更新当前节点为用户栈出栈节点 currentNode = stack.pop(); // 当右孩子为空及右孩子被访问过时,访问当前节点,更新当前节点为空,为下一步的出栈作准备 if(currentNode.right == null || currentNode.right == previousNode) { result.add(currentNode.val); previousNode = currentNode; currentNode = null; }else { // 更新当前节点为右孩子节点 stack.push(currentNode); currentNode = currentNode.right; } } return result; } /** * 前序遍历:迭代法二 */ public List preorderTraversal(TreeNode root) { // 判断头节点是否为空 if(root == null) return new ArrayList(); TreeNode currentNode = null; // 初始化辅助栈及结果链表 List result = new ArrayList<>(); Stack stack = new Stack<>(); // 将根节点压入栈中 stack.push(root); // 重复操作:将栈中节点弹出并存储到list中,然后将右及左节点压入栈中 while(!stack.isEmpty()) { currentNode = stack.pop(); result.add(currentNode.val); // 根据Stack的特性,即FILO可知先弹出左节点 if(currentNode.right != null) stack.push(currentNode.right); if(currentNode.left != null) stack.push(currentNode.left); } return result; } /** * 后续遍历:迭代法二 * 利用先序的遍历顺序:root=>left->right,先将先序遍历更改为:root->right->left * 然后反转List,得到的结果的顺序即为:left->right->root */ public List postorderTraversal(TreeNode root) { // 判断头节点是否为空 if(root == null) return new ArrayList(); TreeNode currentNode = null; // 初始化辅助栈及结果链表 List result = new ArrayList<>(); Stack stack = new Stack<>(); // 将根节点压入栈中 stack.push(root); // 重复操作:将栈中节点弹出并存储到list中,然后将左及右节点压入栈中 while(!stack.isEmpty()) { currentNode = stack.pop(); // 逆序添加节点值 result.add(0,currentNode.val); // 根据Stack的特性,即FILO可知先弹出右节点 if(currentNode.left != null) stack.push(currentNode.left); if(currentNode.right != null) stack.push(currentNode.right); } return result; } } Python ''' @Author: Goog Tech @Date: 2020-07-27 10:56:50 @Description: #94 #144 #145: Binary Tree Traversal Template @FilePath: \\leetcode-googtech\\#94 #144 #145 Binary Tree Traversal Template\\Template.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): ''' 前序遍历: 递归法 ''' def preorderTraversal(self, root): return [] if root is None else [root.val] + self.preorderTraversal( root.left) + self.preorderTraversal(root.right) ''' 中序遍历: 递归法 ''' def inorderTraversal(self, root): return [] if root is None else self.inorderTraversal( root.left) + [root.val] + self.inorderTraversal(root.right) ''' 后序遍历: 递归法 ''' def postorderTraversal(self, root): return [] if root is None else self.postorderTraversal( root.left) + self.postorderTraversal(root.right) + [root.val] ''' 前序遍历: 迭代法 ''' def preorderTraversal(self, root): # 判断根节点是否为空 if root is None: return [] # 初始化辅助栈及结果列表 stack, result = [root], [] # 重复操作:将栈中根节点弹出并存储到list中,然后将右及左节点压入栈中 while stack: root = stack.pop() result.append(root.val) # 根据Stack的特性,即FILO可知先弹出左节点 if root.right is not None: stack.append(root.right) if root.left is not None: stack.append(root.left) return result ''' 中序遍历: 迭代法 ''' def inorderTraversal(self, root): # 初始化辅助栈及结果列表 result, stack, currentNode = [], [], root # 判断头节点是否为空 if root is None: return result currentNode = root # 遍历辅助栈 while stack or currentNode: # 遍历左孩子节点并将其依次压入栈中,直到为空然后进入操作2 if currentNode is not None: # 操作1 stack.append(currentNode) currentNode = currentNode.left # 弹出栈顶元素,若其有右孩子,则将右孩子节点压入栈中,随后重复操作1 else: # 操作2 currentNode = stack.pop() result.append(currentNode.val) currentNode = currentNode.right return result ''' 后续遍历: 迭代法 前序的遍历顺序是“根左右”,而后序是“左右根” 所以可以先模仿前序生成“根右左”,然后再反转就是“左右根”咯 ''' def postorderTraversal(self, root): # 判断根节点是否为空 if root is None: return [] # 初始化辅助栈及声明用于存储结果的列表 result, stack, current = [], [root], root # 重复操作:将栈中根节点弹出并存储到list中,然后将左及右节点依次压入栈中 while stack: current = stack.pop() result.append(current.val) # 根据Stack的特性,即FILO可知先弹出右节点 if current.left is not None: stack.append(current.left) if current.right is not None: stack.append(current.right) # 反转列表 return result[::-1] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/100.相同的树/100.相同的树.html":{"url":"LeetCode刷题之旅及题目解析/100.相同的树/100.相同的树.html","title":"100.相同的树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 100. 相同的树 Java Python 100. 相同的树 https://leetcode-cn.com/problems/same-tree/ Java /* * @Author: Goog Tech * @Date: 2020-07-24 19:08:50 * @Description: https://leetcode-cn.com/problems/same-tree/ * @FilePath: \\leetcode-googtech\\#100. Same Tree\\Solution.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { // 递归法 public boolean isSameTree(TreeNode p, TreeNode q) { if(p==null && q==null) { return true; } else if(p!=null && q!=null && p.val == q.val) { return isSameTree(p.left,q.left) && isSameTree(p.right,q.right); }else { return false; } } } Python ''' @Author: Goog Tech @Date: 2020-07-24 19:08:58 @Description: https://leetcode-cn.com/problems/same-tree/ @FilePath: \\leetcode-googtech\\#100. Same Tree\\Solution.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): # 递归法 def isSameTree(self, p, q): \"\"\" :type p: TreeNode :type q: TreeNode :rtype: bool \"\"\" if not p and not q: return True elif p is not None and q is not None and p.val==q.val: return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) else: return False Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/101.对称二叉树/101.对称二叉树.html":{"url":"LeetCode刷题之旅及题目解析/101.对称二叉树/101.对称二叉树.html","title":"101.对称二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 101. 对称二叉树 Java Python @lc app=leetcode.cn id=101 lang=python [101] 对称二叉树 @lc code=start 101. 对称二叉树 https://leetcode-cn.com/problems/symmetric-tree/ Java /* * @Author: Goog Tech * @Date: 2020-07-29 00:07:21 * @Description: https://leetcode-cn.com/problems/symmetric-tree/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\101.对称二叉树.java */ /* * @lc app=leetcode.cn id=101 lang=java * * [101] 对称二叉树 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /** * 递归法: 解题思路如下 * 有个超大的坑啊: 记得首先判断 left == null && right == null * 而不是 left == null || right == null,不然无论什么结果都会一直返回 False * 1. 若左右子树中的两节点都非空,则对称 * 2. 若左右子树中的两节点其有一个为空,则不对称 * 3. 若左右子树中的两节点不相同,则不对称 * 4. 继续递归比较左节点的左孩子和右节点的右孩子 */ public boolean isSymmetric(TreeNode root) { // if(root == null) return true; // return dfs(root.left, root.right); return root == null ? true : dfs(root.left, root.right); // 若根节点不为空则传入左右子树的根节点 } private boolean dfs(TreeNode left, TreeNode right) { // if(left == null && right == null) return true; // if(left == null || right == null || left.val != right.val) return false; // return dfs(left.left, right.right, left.right, right.left); return left == null && right == null ? true : left == null || right == null || left.val != right.val ? false : dfs(left.left, right.right) && dfs(left.right, right.left); } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-28 23:12:04 @Description: https://leetcode-cn.com/problems/symmetric-tree/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\101.对称二叉树.py ''' # # @lc app=leetcode.cn id=101 lang=python # # [101] 对称二叉树 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归法 # 有个超大的坑啊: 记得首先判断 if not left and not right # 而不是 if not left or not right,不然无论什么结果都会一直返回 False def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if not root: return True def dfs(left, right): # 若左右子树中的两节点都非空,则对称 if not left and not right: return True # 若左右子树中的两节点其有一个为空,则不对称 if not left or not right: return False # 若左右子树中的两节点不相同,则不对称 if left.val != right.val: return False # 继续递归比较左节点的左孩子和右节点的右孩子 return dfs(left.left, right.right) and dfs(left.right, right.left) # 传入左右子树的根节点 return dfs(root.left, root.right) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/102.二叉树的层序遍历/102.二叉树的层序遍历.html":{"url":"LeetCode刷题之旅及题目解析/102.二叉树的层序遍历/102.二叉树的层序遍历.html","title":"102.二叉树的层序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 102. 二叉树的层序遍历 Java Python 102. 二叉树的层序遍历 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-26 11:32:01 * @Description: In User Settings Edit * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.java * @Reference: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // Breadth First Search:使用队列实现二叉树的层次遍历 public List> levelOrder(TreeNode root) { // 存储结果 List> result = new ArrayList<>(); // 辅助队列 Queue queue = new LinkedList<>(); // 判断头节点是否为空 if(root != null) { queue.add(root); } // 遍历队列 while(!queue.isEmpty()) { // root非空时,第一层的节点数为1 int n = queue.size(); // 存储每层的节点 List list = new ArrayList<>(); // 进行n次循环,确保当前层的节点全部出队列 for(int i = 0;i Python ''' @Author: Goog Tech @Date: 2020-07-26 12:31:40 @Description: In User Settings Edit @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.py @Reference: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # Breadth First Search:使用队列实现二叉树的层次遍历 def levelOrder(self,root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" # 存储每层的节点列表 result = [] # 辅助队列 queue = [root] # 判断头节点是否为空 if not root: return result # 遍历队列 while queue: # root非空时,第一层的节点数为1 length = len(queue) # 存储每层的节点 alist = [] # 进行n次循环,确保当前层的的节点全部出队列 for i in range(length): node = queue.pop(0) # 存储当前节点 alist.append(node.val) # 把当前节点所有的左右节点全部加入队列,进而确保当前队列的len就是下一层的节点数 if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 将每层的节点列表加入结果列表中 result.append(alist) # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/104.二叉树的最大深度/104.二叉树的最大深度.html":{"url":"LeetCode刷题之旅及题目解析/104.二叉树的最大深度/104.二叉树的最大深度.html","title":"104.二叉树的最大深度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 104. 二叉树的最大深度 Java Python 104. 二叉树的最大深度 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-07-21 21:48:51 * @Description: https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ * @FilePath: \\leetcode-googtech\\#104. Maximum Depth of Binary Tree\\Solution.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 后序遍历(DFS): 递归法 public int maxDepth(TreeNode root) { return root == null ? 0 : Math.max(maxDepth(root.left),maxDepth(root.right)) + 1; } } Python ''' @Author: Goog Tech @Date: 2020-07-21 21:48:59 @Description: https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ @FilePath: \\leetcode-googtech\\#104. Maximum Depth of Binary Tree\\Solution.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 后序遍历(DFS): 递归法 def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" # lDepth = self.maxDepth(root.left)+1 # rDepth = self.maxDepth(root.right)+1 # return 0 if not root else lDepth if lDepth > rDepth else rDepth return 0 if not root else max(self.maxDepth(root.right),self.maxDepth(root.left)) + 1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/107.二叉树的层次遍历II/107.二叉树的层次遍历II.html":{"url":"LeetCode刷题之旅及题目解析/107.二叉树的层次遍历II/107.二叉树的层次遍历II.html","title":"107.二叉树的层次遍历II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 107. 二叉树的层次遍历 II Java Python 107. 二叉树的层次遍历 II https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ Java /* * @Author: Goog Tech * @Date: 2020-09-12 10:47:14 * @LastEditTime: 2020-09-12 10:49:35 * @Description: https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ * @FilePath: \\leetcode-googtech\\107. Binary Tree Level Order Traversal II\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 广度优先遍历( DFS ) public List> levelOrderBottom(TreeNode root) { // 初始化结果列表 LinkedList> result = new LinkedList<>(); // 判断根是否为空 if(root == null) return result; // 初始化辅助队列,并将根节点入队 Queue queue = new LinkedList<>(); queue.add(root); // 判断当前辅助队列是否为空 while(!queue.isEmpty()) { // 初始化用于存储当前层节点的临时列表 List oneLevel = new ArrayList<>(); // 获取队列中上一层节点的个数 int count = queue.size(); // 逐个遍历辅助队列中存储的上层节点 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-12 10:47:16 LastEditTime: 2020-09-12 10:50:20 Description: https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ FilePath: \\leetcode-googtech\\107. Binary Tree Level Order Traversal II\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 广度优先遍历( BFS ) def levelOrderBottom(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" # 判断根节点是否为空 if not root: return [] # 初始化结果列表及辅助队列 result, queue = [], [root] # 判断当前辅助队列是否为空 while queue: # 初始化用于存储当前层节点的列表 oneLevel = [] # 循环遍历辅助队列中存储的上层节点 for _ in range(len(queue)): # 将存储在队列中的上层节点逐个弹出,并将其存储到临时列表中 node = queue.pop(0) oneLevel.append(node.val) # 若当前弹出节点的左右孩子节点不为空,则将其孩子节点继续添加到队列中 if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 将存储上一层节点的临时列表添加到结果列表中 result.append(oneLevel) # 反转结果列表,即返回其节点值自底向上的层次遍历 return result[::-1] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/108.将有序数组转换为二叉搜索树/108.将有序数组转换为二叉搜索树.html":{"url":"LeetCode刷题之旅及题目解析/108.将有序数组转换为二叉搜索树/108.将有序数组转换为二叉搜索树.html","title":"108.将有序数组转换为二叉搜索树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 108. 将有序数组转换为二叉搜索树 Java Python @lc app=leetcode.cn id=108 lang=python [108] 将有序数组转换为二叉搜索树 @lc code=start 108. 将有序数组转换为二叉搜索树 https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 20:41:56 * @LastEditTime: 2020-08-14 20:52:29 * @Description: https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ * @FilePath: \\leetcode-googtech\\#108. Convert Sorted Array to Binary Search Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=108 lang=java * * [108] 将有序数组转换为二叉搜索树 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length - 1); } private TreeNode helper(int[] nums, int left, int right) { if(left > right) return null; // 获取数组中间元素的下标值,并将该元素作为二叉树的根节点 int midNodeIndex = (left + right) / 2; TreeNode root = new TreeNode(nums[midNodeIndex]); // 左侧数组作为左子树,同理右侧数组作为右子树 root.left = helper(nums, left, midNodeIndex - 1); root.right = helper(nums, midNodeIndex + 1, right); // 返回结果 return root; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-14 20:22:02 LastEditTime: 2020-08-14 20:52:13 Description: https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ FilePath: \\leetcode-googtech\\#108. Convert Sorted Array to Binary Search Tree\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=108 lang=python # # [108] 将有序数组转换为二叉搜索树 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def sortedArrayToBST(self, nums): \"\"\" :type nums: List[int] :rtype: TreeNode \"\"\" # 判断数组是否为空 if not nums: return None # 获取数组中间元素的下标值,并将该元素作为二叉树的根节点 midNodeIndex = len(nums) // 2 root = TreeNode(nums[midNodeIndex]) # 左侧数组作为左子树,同理右侧数组作为右子树 root.left = self.sortedArrayToBST(nums[:midNodeIndex]) root.right = self.sortedArrayToBST(nums[midNodeIndex + 1:]) # 返回结果 return root # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/109.有序链表转换二叉搜索树/109.有序链表转换二叉搜索树.html":{"url":"LeetCode刷题之旅及题目解析/109.有序链表转换二叉搜索树/109.有序链表转换二叉搜索树.html","title":"109.有序链表转换二叉搜索树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 109. 有序链表转换二叉搜索树 Java Python @lc app=leetcode.cn id=109 lang=python [109] 有序链表转换二叉搜索树 @lc code=start 109. 有序链表转换二叉搜索树 https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 18:46:04 * @LastEditTime: 2020-08-14 19:27:31 * @Description: https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/ * @FilePath: \\leetcode-googtech\\#109. Convert Sorted List to Binary Search Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=109 lang=java * * [109] 有序链表转换二叉搜索树 */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 双指针法: 首先使用快慢指针求出链表的中点,然后通过中序遍历构建二叉树 public TreeNode sortedListToBST(ListNode head) { return helper(head, null); } private TreeNode helper(ListNode head, ListNode tail) { if(head == tail) return null; // 初始化双指针 ListNode fast = head; ListNode slow = head; // 寻找中间节点: 当快指针fast走到尾部时,慢指针slow指向链表的中间节点 while(fast != tail && fast.next != tail) { slow = slow.next; fast = fast.next.next; } // 使用中序遍历将其转换为二叉树(此时slow指向中间节点) TreeNode root = new TreeNode(slow.val); root.left = helper(head, slow); // 构建左子树 root.right = helper(slow.next, tail); // 构建右子树 return root; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-14 19:01:27 LastEditTime: 2020-08-14 19:23:33 Description: https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/ FilePath: \\leetcode-googtech\\#109. Convert Sorted List to Binary Search Tree\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=109 lang=python # # [109] 有序链表转换二叉搜索树 # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 双指针法 def sortedListToBST(self, head): \"\"\" :type head: ListNode :rtype: TreeNode \"\"\" # 寻找中间节点: 当快指针fast走到末尾时,慢指针slow指向链表的中间节点 def findmid(head, tail): fast, slow = head, head while fast != tail and fast.next != tail: slow = slow.next fast = fast.next.next return slow # 构建二叉树: 利用中序遍历构建二叉树 def helper(head, tail): if head == tail: return node = findmid(head, tail) root = TreeNode(node.val) root.left = helper(head, node) root.right = helper(node.next, tail) return root # 返回结果 return helper(head, None) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/110.平衡二叉树/110.平衡二叉树.html":{"url":"LeetCode刷题之旅及题目解析/110.平衡二叉树/110.平衡二叉树.html","title":"110.平衡二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 110. 平衡二叉树 Java Python 110. 平衡二叉树 https://leetcode-cn.com/problems/balanced-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-09-14 17:25:33 * @LastEditTime: 2020-09-14 17:27:19 * @Description: https://leetcode-cn.com/problems/balanced-binary-tree/ * @FilePath: \\leetcode-googtech\\#110. Balanced Binary Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { boolean result = true; // BFS : 深度优先遍历 public boolean isBalanced(TreeNode root) { dfs(root); return result; } private int dfs(TreeNode root) { if(root == null) return 0; int lDepth = dfs(root.left); int rDepth = dfs(root.right); if(Math.abs(lDepth - rDepth) > 1) result = false; return Math.max(lDepth, rDepth) + 1; } } Python ''' Author: Goog Tech Date: 2020-09-14 17:25:59 LastEditTime: 2020-09-14 17:28:45 Description: https://leetcode-cn.com/problems/balanced-binary-tree/ FilePath: \\leetcode-googtech\\#110. Balanced Binary Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # 递归的三个条件 : 左平衡,右平衡,当前节点平衡. class Solution: def isBalanced(self, root: TreeNode) -> bool: if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.height(root.left) - self.height(root.right)) int: if not root: return 0 return max(self.height(root.left), self.height(root.right)) + 1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/111.二叉树的最小深度/111.二叉树的最小深度.html":{"url":"LeetCode刷题之旅及题目解析/111.二叉树的最小深度/111.二叉树的最小深度.html","title":"111.二叉树的最小深度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 111. 二叉树的最小深度 Java Python @lc app=leetcode.cn id=111 lang=python [111] 二叉树的最小深度 @lc code=start 111. 二叉树的最小深度 https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-07-28 22:30:45 * @Description: https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\111.二叉树的最小深度.java * @Reference: https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/ */ /* * @lc app=leetcode.cn id=111 lang=java * * [111] 二叉树的最小深度 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /** * 递归法，解题思路如下: * 叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点 * 1. 当 root 节点左右孩子都为空时，返回 1 * 2. 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度 * 3. 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值 */ public int minDepth(TreeNode root) { // 判断头节点是否为空 if(root == null) return 0; // 若左右孩子都为空,则说明到达了叶子节点,直接返回1即可 if(root.left == null && root.right == null) return 1; // 求出左右子树的深度值 // 若左右孩子其中有一个为空,那么需返回比较大的那个孩子的深度值 int lDepth = minDepth(root.left); int rDepth = minDepth(root.right); if(root.left == null || root.right == null) return lDepth + rDepth + 1; //有一个孩子必然为0，所以可以返回lDepth + rDepth + 1; // 若左右孩子都不为空,则返回最小深度加一即可 return Math.min(lDepth,rDepth) + 1; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-28 22:53:59 @Description: https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\111.二叉树的最小深度.py @Reference: https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/ ''' # # @lc app=leetcode.cn id=111 lang=python # # [111] 二叉树的最小深度 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): ''' 递归法，解题思路如下: 叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点 1. 当 root 节点左右孩子都为空时，返回 1 2. 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度 3. 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值 ''' def minDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 lDepth, rDepth = self.minDepth(root.left), self.minDepth(root.right) # 若左孩子或有孩子为空(lDepth or rDepth is zero.),则可直接返回: lDepth + rDepth + 1 # 若左右孩子都不为空则返回较小的那个孩子的深度值 return lDepth + rDepth + 1 if root.left is None or root.right is None else min(lDepth, rDepth) + 1 # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/114.二叉树展开为链表/114.二叉树展开为链表.html":{"url":"LeetCode刷题之旅及题目解析/114.二叉树展开为链表/114.二叉树展开为链表.html","title":"114.二叉树展开为链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 114. 二叉树展开为链表 Java Python 114. 二叉树展开为链表 https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ Java /* * @Author: Goog Tech * @Date: 2020-09-27 17:47:29 * @LastEditTime: 2020-09-27 17:48:43 * @Description: https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ * @FilePath: \\leetcode-googtech\\#114. Flatten Binary Tree to Linked List\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { // 递归解法: 解题思路如下所示: // 1. 将左子树插入到右子树的地方 // 2. 将原来的右子树接到左子树的最右边节点 // 3. 考虑新的右子树的根节点,一直重复上面的过程,直到新的右子树为 null public void flatten(TreeNode root) { while(root != null) { // 若左子树为空,则直接考虑下一个节点 if(root.left == null) { root = root.right; }else { // 找到左子树中最右边的节点 TreeNode pre = root.left; while(pre.right != null) { pre = pre.right; } // 将原来的右子树接到左子树中的最右边的节点上 pre.right = root.right; // 将左子树插入到右子树的地方 root.right = root.left; root.left = null; // 继续遍历下一个节点 root = root.right; } } } } Python ''' Author: Goog Tech Date: 2020-09-27 17:47:41 LastEditTime: 2020-09-27 17:49:59 Description: https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ FilePath: \\leetcode-googtech\\#114. Flatten Binary Tree to Linked List\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): # 递归解法 def flatten(self, root): \"\"\" :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. \"\"\" # 判断根节点及其左右子树是否为空 if not root or (not root.left and not root.right): return root # 将左右子树捋直 self.flatten(root.left) self.flatten(root.right) # 将捋直的右子树备份一下 tempTree = root.right # 将捋直的左子树放置到右边 root.right = root.left # 将左子树置空 root.left = None # 找到现右子树中的最后一个节点 while(root.right): root = root.right # 将捋直的原来的右子树接到现右子树的右子树上 root.right = tempTree Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/121.买卖股票的最佳时机/121.买卖股票的最佳时机.html":{"url":"LeetCode刷题之旅及题目解析/121.买卖股票的最佳时机/121.买卖股票的最佳时机.html","title":"121.买卖股票的最佳时机","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 121. 买卖股票的最佳时机 Java Python 121. 买卖股票的最佳时机 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ Java /* * @Author: Goog Tech * @Date: 2020-09-16 14:18:58 * @LastEditTime: 2020-09-16 14:19:12 * @Description: https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ * @FilePath: \\leetcode-googtech\\#121. Best Time to Buy and Sell Stock\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // DP : 动态规划思想 // 解题思路 : 前 i 天的最大收益 = MAX(前 i-1 天的最大收益, 第 i 天的价格 - 前 i-1 天中的最小价格) public int maxProfit(int[] prices) { if(prices.length Python ''' Author: Goog Tech Date: 2020-09-16 14:19:03 LastEditTime: 2020-09-16 14:19:31 Description: https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ FilePath: \\leetcode-googtech\\#121. Best Time to Buy and Sell Stock\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # DP : 动态规划思想 # 解题思路 : 前 i 天的最大收益 = MAX(前 i-1 天的最大收益, 第 i 天的价格 - 前 i-1 天中的最小价格) def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/124.二叉树中的最大路径和/124.二叉树中的最大路径和.html":{"url":"LeetCode刷题之旅及题目解析/124.二叉树中的最大路径和/124.二叉树中的最大路径和.html","title":"124.二叉树中的最大路径和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 124. 二叉树中的最大路径和 Java Python 124. 二叉树中的最大路径和 https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ Java /* * @Author: Goog Tech * @Date: 2020-09-28 11:46:32 * @LastEditTime: 2020-09-28 11:47:16 * @Description: https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ * @FilePath: \\leetcode-googtech\\#124. Binary Tree Maximum Path Sum\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { getMaxSum(root); return maxSum; } // 递归解法 private int getMaxSum(TreeNode node) { // 判断节点是否为空 if(node == null) return 0; // 递归计算当前节点的左右孩子节点,仅当最大贡献值 maxSum 大于 0 时,才会选取对应的节点 int left = Math.max(getMaxSum(node.left), 0); int right = Math.max(getMaxSum(node.right), 0); // 节点的最大路径和取决于当前节点的值与该节点的左右子节点的最大贡献值 maxSum = Math.max(node.val + left + right, maxSum); // 返回当前节点的最大贡献值 return node.val + Math.max(left, right); } } Python ''' Author: Goog Tech Date: 2020-09-28 11:46:38 LastEditTime: 2020-09-28 11:46:52 Description: https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ FilePath: \\leetcode-googtech\\#124. Binary Tree Maximum Path Sum\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归解法 def maxPathSum(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def getMaxSum(node): global maxSum # 判断节点是否为空 if not node: return 0 # 递归计算当前节点的左右孩子节点,仅当最大贡献值 maxSum 大于 0 时,才会选取对应的节点 left = max(getMaxSum(node.left), 0) right = max(getMaxSum(node.right), 0) # 节点的最大路径和取决于当前节点的值与该节点的左右子节点的最大贡献值 self.maxSum = max(node.val + left + right, self.maxSum) # 返回当前节点的最大贡献值 return node.val + max(left, right) self.maxSum = float('-inf') getMaxSum(root) return self.maxSum Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/125.验证回文串/125.验证回文串.html":{"url":"LeetCode刷题之旅及题目解析/125.验证回文串/125.验证回文串.html","title":"125.验证回文串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 125. 验证回文串 Java Python @lc app=leetcode.cn id=125 lang=python [125] 验证回文串 @lc code=start 125. 验证回文串 https://leetcode-cn.com/problems/valid-palindrome/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 09:15:36 * @LastEditTime: 2020-08-15 09:50:58 * @Description: https://leetcode-cn.com/problems/valid-palindrome/ * @FilePath: \\leetcode-googtech\\#125. Valid Palindrome\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=125 lang=java * * [125] 验证回文串 */ // @lc code=start class Solution { public boolean isPalindrome(String s) { // 判断字符串是否为空 if(s == null || s.length() == 0) return true; // 将字符串中的字符转换为小写 s = s.toLowerCase(); // 初始化头尾指针 int left = 0, right = s.length() - 1; // 利用双指针循环遍历字符串中的字符 while(left Python ''' Author: Goog Tech Date: 2020-08-15 09:38:40 LastEditTime: 2020-08-15 09:51:05 Description: https://leetcode-cn.com/problems/valid-palindrome/ FilePath: \\leetcode-googtech\\#125. Valid Palindrome\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=125 lang=python # # [125] 验证回文串 # # @lc code=start class Solution(object): ''' 截图思路如下: 初始时左右指针分别指向 string 的两侧,随后我们不断地将这两个指针相向移动, 每次移动一步,并判断这两个指针指向的字符是否相同. 当这两个指针相遇时,就说明 string 是回文串. ''' def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" # 将字符串中的字符转换为小写,其中 isalnum() 方法用于检测字符串是否由字母和数字组成 string = ''.join(ch.lower() for ch in s if ch.isalnum()) # 初始化头尾双指针 left, right = 0, len(string) - 1 # 通过移动双指针来逐个判断头尾指针所指字符是否相等 while left Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/129.求根到叶子节点数字之和/129.求根到叶子节点数字之和.html":{"url":"LeetCode刷题之旅及题目解析/129.求根到叶子节点数字之和/129.求根到叶子节点数字之和.html","title":"129.求根到叶子节点数字之和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 129. 求根到叶子节点数字之和 Java Python 129. 求根到叶子节点数字之和 https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/ Java /* * @Author: Goog Tech * @Date: 2020-09-28 11:44:06 * @LastEditTime: 2020-09-28 11:44:26 * @Description: https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/ * @FilePath: \\leetcode-googtech\\#129. Sum Root to Leaf Numbers\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归解法 public int sumNumbers(TreeNode root) { return helper(root, 0); } private int helper(TreeNode node, int sum) { if(node == null) return 0; // 若当前节点是叶子结点,则说明找到了一条路径 if(node.left == null && node.right == null) return 10 * sum + node.val; // 反之继续遍历子节点, 即将子节点和子节点的值分别加入到递归栈中,其中子节点的值 = 父节点的值 * 10 + 当前节点的值 return helper(node.left, 10 * sum + node.val) + helper(node.right, 10 * sum + node.val); } } Python ''' Author: Goog Tech Date: 2020-09-28 11:44:10 LastEditTime: 2020-09-28 11:44:39 Description: https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/ FilePath: \\leetcode-googtech\\#129. Sum Root to Leaf Numbers\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # DFS : 深度优先搜索 def sumNumbers(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" # 判断根节点是否为空 if not root: return 0 # 初始化两个辅助栈(分别存储节点及其对应的值)及结果数值 nodeStack, valueStack, result = [root], [root.val], 0 # 循环遍历存储节点的辅助栈 while nodeStack: # 将当前节点及其对应的节点值出栈 node = nodeStack.pop() value = valueStack.pop() # 若当前节点为叶子节点,则说明找到了一条路径,进而将这条路径的值逐个加入到 result 中 if not node.left and not node.right: result += value # 反之则说明当前出栈节点 node 不是叶子节点 else: # 将子节点及子节点的值分别入栈,这里的子节点的值 = 指父节点的值 * 10 + 当前节点的值 if node.right: nodeStack.append(node.right); valueStack.append(value * 10 + node.right.val) if node.left: nodeStack.append(node.left) valueStack.append(value * 10 + node.left.val) # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/136.只出现一次的数字/136.只出现一次的数字.html":{"url":"LeetCode刷题之旅及题目解析/136.只出现一次的数字/136.只出现一次的数字.html","title":"136.只出现一次的数字","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 136. 只出现一次的数字 Java Python @lc app=leetcode.cn id=136 lang=python [136] 只出现一次的数字 @lc code=start 136. 只出现一次的数字 https://leetcode-cn.com/problems/single-number/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 17:53:39 * @LastEditTime: 2020-08-15 17:56:52 * @Description: https://leetcode-cn.com/problems/single-number/ * @FilePath: \\leetcode-googtech\\#136. Single Number\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=136 lang=java * * [136] 只出现一次的数字 */ // @lc code=start class Solution { // 数组中的全部元素的异或运算结果即为数组中只出现一次的数字 public int singleNumber(int[] nums) { int single = 0; for(int num : nums) single ^= num; return single; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-15 17:52:11 LastEditTime: 2020-08-15 17:55:54 Description: https://leetcode-cn.com/problems/single-number/ FilePath: \\leetcode-googtech\\#136. Single Number\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=136 lang=python # # [136] 只出现一次的数字 # # @lc code=start class Solution(object): # 数组中的全部元素的异或运算结果即为数组中只出现一次的数字 def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" single = 0 for i in range(len(nums)): single ^= nums[i] return single # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/137.只出现一次的数字II/137.只出现一次的数字II.html":{"url":"LeetCode刷题之旅及题目解析/137.只出现一次的数字II/137.只出现一次的数字II.html","title":"137.只出现一次的数字II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 137. 只出现一次的数字 II Java Python @lc app=leetcode.cn id=137 lang=python [137] 只出现一次的数字 II @lc code=start 137. 只出现一次的数字 II https://leetcode-cn.com/problems/single-number-ii/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 14:34:53 * @LastEditTime: 2020-08-16 14:51:09 * @Description: https://leetcode-cn.com/problems/single-number-ii/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\137.只出现一次的数字-ii.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=137 lang=java * * [137] 只出现一次的数字 II */ // @lc code=start class Solution { public int singleNumber(int[] nums) { // 初始化 Map 集合 HashMap map = new HashMap<>(); // 将数组中的元素作为key,其出现的次数作为value存储到 hashMap 中 // getOrDefault:若该元素不存在则返回0,反之返回对应数值出现次数并加1 for(int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } // 遍历map的键值对,若键对应的值为1则返回该键,即结果数值 for(int key : map.keySet()) { if(map.get(key) == 1) { return key; } } // 无果 return -1; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-16 14:45:27 LastEditTime: 2020-08-16 14:52:02 Description: https://leetcode-cn.com/problems/single-number-ii/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\137.只出现一次的数字-ii.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=137 lang=python # # [137] 只出现一次的数字 II # # @lc code=start class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # 将数组中的元素作为key,其出现的次数作为value存储到 hashMap 中 hashMap = Counter(nums) # 遍历键值对,若键对应的值为1则返回改键,即结果数值 for k in hashMap.keys(): if hashMap[k] == 1: return k # 无果 return -1 # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/141.环形链表/141.环形链表.html":{"url":"LeetCode刷题之旅及题目解析/141.环形链表/141.环形链表.html","title":"141.环形链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 141. 环形链表 Video Java Python 141. 环形链表 https://leetcode-cn.com/problems/linked-list-cycle/ Video Java /* * @Author: Goog Tech * @Date: 2020-07-18 22:41:10 * @Description: https://leetcode-cn.com/problems/linked-list-cycle/ * @FilePath: \\leetcode-googtech\\#141. Linked List Cycle\\Solution.java */ /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { // 快慢指针 // 如果有环,经多次遍历后慢指针与快指针一定会在环中的某个结点相遇 public boolean hasCycle(ListNode head) { ListNode fastNode = head, slowNode = head; while(fastNode!=null&&fastNode.next!=null){ fastNode = fastNode.next.next; slowNode = slowNode.next; if(fastNode==slowNode){ return true; } } return false; } } Python ''' @Author: Goog Tech @Date: 2020-07-18 22:41:18 @Description: https://leetcode-cn.com/problems/linked-list-cycle/ @FilePath: \\leetcode-googtech\\#141. Linked List Cycle\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" # # 置空法 # # 判断头节点是否为空 # if not head: # return False # # 逐个将节点置为空 # while head.next and head.val != None: # head.val = None # head = head.next # # 若碰到空节点则无环 # if not head.next: # return False # return True # 快慢指针法 # 如果有环,经多次遍历后慢指针与快指针一定会在环中的某个结点相遇 fastNode = slowNode = head while fastNode and fastNode.next: fastNode = fastNode.next.next slowNode = slowNode.next if fastNode == slowNode: return True return False Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/144.二叉树的前序遍历/144.二叉树的前序遍历.html":{"url":"LeetCode刷题之旅及题目解析/144.二叉树的前序遍历/144.二叉树的前序遍历.html","title":"144.二叉树的前序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 144. 二叉树的前序遍历 Java Python @lc app=leetcode.cn id=144 lang=python [144] 二叉树的前序遍历 @lc code=start 144. 二叉树的前序遍历 https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-26 17:46:02 * @Description: https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ * @FilePath: \\leetcode-googtech\\#144. Binary Tree Preorder Traversal\\Solution.java */ /* * @lc app=leetcode.cn id=144 lang=java * * [144] 二叉树的前序遍历 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 迭代法: root->left->right public List preorderTraversal(TreeNode root) { // 初始化辅助栈及用于存储结果的列表 List list = new ArrayList<>(); Stack stack = new Stack<>(); // 判断头节点是否为空 if(root == null) { return list; } // 将根节点压入栈中 stack.push(root); // 重复操作:将栈中根节点弹出并存储到list中,然后将右及左节点压入栈中 while(!stack.isEmpty()) { root = stack.pop(); list.add(root.val); // 根据Stack的特性,即FILO可知先弹出左节点 if(root.right!=null) { stack.push(root.right); } if(root.left!=null) { stack.push(root.left); } } // 返回结果 return list; } // 递归法1 public List preorderTraversal(TreeNode root) { List res = new ArrayList<>(); helper(root, res); return res; } private void helper(TreeNode root, List res) { if (root == null) return; res.add(root.val); helper(root.left, res); helper(root.right, res); } // 递归法2 List list = new ArrayList<>(); public List preorderTraversal(TreeNode root) { if(root != null) { list.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); } return list; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-26 17:58:32 @Description: https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ @FilePath: \\leetcode-googtech\\#144. Binary Tree Preorder Traversal\\Solution.py ''' # # @lc app=leetcode.cn id=144 lang=python # # [144] 二叉树的前序遍历 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 迭代法: root->left->right def preorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" # 判断根节点是否为空 if root is None: return [] # 初始化辅助栈及声明用于存储结果的列表 stack, result = [root], [] # 重复操作:将栈中根节点弹出并存储到list中,然后将右及左节点压入栈中 while stack: root = stack.pop() result.append(root.val) # 根据Stack的特性,即FILO可知先弹出左节点 if root.right is not None: stack.append(root.right) if root.left is not None: stack.append(root.left) return result # 递归法: def preorderTraversal(self, root): if root is None: return [] # [1] + [] + [2,3] return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/145.二叉树的后序遍历/145.二叉树的后序遍历.html":{"url":"LeetCode刷题之旅及题目解析/145.二叉树的后序遍历/145.二叉树的后序遍历.html","title":"145.二叉树的后序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 145. 二叉树的后序遍历 Java Python @lc app=leetcode.cn id=145 lang=python [145] 二叉树的后序遍历 @lc code=start 145. 二叉树的后序遍历 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-26 21:18:04 * @Description: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ * @FilePath: \\leetcode-googtech\\#145. Binary Tree Postorder Traversal\\Solution.java * @Reference: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bian-li-tong-jie-by-long_wotu/ */ /* * @lc app=leetcode.cn id=145 lang=java * * [145] 二叉树的后序遍历 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right;145.二叉树的后序遍历 * TreeNode(int x) { val = x; } * } */ class Solution { /** * 递归法 */ List result = new ArrayList<>(); public List postorderTraversal(TreeNode root) { if(root != null) { postorderTraversal(root.left); postorderTraversal(root.right); result.add(root.val); } // [] + [3,2] + [1] return result; } /** * 迭代法:反转列表 * 利用先序的遍历顺序:root->left->right,先将先序遍历更改为:root->right->left * 然后反转List,得到结果的顺序即为:left->right->root */ public List postorderTraversal(TreeNode root) { List result = new ArrayList<>(); if(root == null) return result; Stack stack = new Stack<>(); stack.push(root); while(!stack.isEmpty()) { TreeNode node = stack.pop(); if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); // 逆序添加结点值 result.add(0,node.val); } return result; } /** * 迭代法: 前中序非递归统一的写法 */ public List postorderTraversal(TreeNode root) { // 初始化结果列表 List result = new ArrayList<>(); // 判断头节点是否为空 if(root == null) return result; // 初始化辅助栈 Stack stack = new Stack<>(); // 初始化当前节点及当前节点的前节点,其用于区分之前的节点是否被访问过 TreeNode currentNode = root, previousNode = null; // 遍历辅助栈 while(!stack.isEmpty() || currentNode != null) { // 将左子树的左节点压入栈中 while(currentNode != null) { stack.push(currentNode); currentNode = currentNode.left; } // 弹出栈顶元素 currentNode = stack.pop(); // 判断是否有右孩子节点或左孩子节点是否被访问过了 if(currentNode.right == null || currentNode.right == previousNode) { result.add(currentNode.val); previousNode = currentNode; currentNode = null; }else { stack.push(currentNode); currentNode = currentNode.right; } } return result; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-27 10:17:38 @Description: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\145.二叉树的后序遍历.py ''' # # @lc app=leetcode.cn id=145 lang=python # # [145] 二叉树的后序遍历 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): ''' 递归法 ''' def postorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" if root is None: return [] # [] + [3,2] + [1] return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val] ''' 迭代法 前序的遍历顺序是“根左右”,而后序是“左右根” 所以模仿前序生成先“根右左”,然后再反转就是“左右根”咯 ''' def postorderTraversal(self, root): # 判断根节点是否为空 if root is None: return [] # 初始化辅助栈及声明用于存储结果的列表 result, stack, current = [], [root], root # 重复操作:将栈中根节点弹出并存储到list中,然后将左及右节点依次压入栈中 while stack: current = stack.pop() result.append(current.val) # 根据Stack的特性,即FILO可知先弹出右节点 if current.left is not None: stack.append(current.left) if current.right is not None: stack.append(current.right) # 反转输出列表 return result[::-1] # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/151.翻转字符串里的单词/151.翻转字符串里的单词.html":{"url":"LeetCode刷题之旅及题目解析/151.翻转字符串里的单词/151.翻转字符串里的单词.html","title":"151.翻转字符串里的单词","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 151.翻转字符串里的单词 Java Python @lc app=leetcode.cn id=151 lang=python [151] 翻转字符串里的单词 @lc code=start 151.翻转字符串里的单词 https://leetcode-cn.com/problems/reverse-words-in-a-string/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 10:34:22 * @LastEditTime: 2020-08-04 11:09:04 * @Description: https://leetcode-cn.com/problems/reverse-words-in-a-string/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.java */ /* * @lc app=leetcode.cn id=151 lang=java * * [151] 翻转字符串里的单词 */ // @lc code=start class Solution { /** * 双指针法 * * 1.倒序遍历字符串s,记录单词左右索引边界left,right. * 2.每确定一个单词的边界,则将其添加到单词列表result中. * 3.最后将单词列表拼接为字符串并去除头尾空格,将其返回即可. */ public String reverseWords(String s) { // 删除字符串的首尾空格 s = s.trim(); // 初始化双指针,使得left与right指向字符串尾字符 int right = s.length() - 1, left = right; StringBuilder result = new StringBuilder(); // 通过移动左指针来检查字符串中是否含有单词 while(left >= 0) { // left指针向左移动: 寻找第一个空格 while( left >= 0 && s.charAt(left) != ' ') left--; // 将单词添加到result中,并在其后添加空格 result.append(s.substring(left + 1, right + 1) + \" \"); // 跳过单词之间的空格 while(left >= 0 && s.charAt(left) == ' ') left--; // 使得right指向下一个单词的尾字符 right = left; } // 将结果转化为字符串并删除头尾空格 return result.toString().trim(); } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-04 10:55:29 LastEditTime: 2020-08-04 11:10:18 Description: https://leetcode-cn.com/problems/reverse-words-in-a-string/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.py ''' # # @lc app=leetcode.cn id=151 lang=python # # [151] 翻转字符串里的单词 # # @lc code=start class Solution(object): # 双指针法 def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\" result = [] # 去除字符串的首位空格 s = s.strip() # 初始化双节点,使得left与right指向字符串的尾字符 left = right = len(s) - 1 # 通过移动左指针来检查字符串中是否含有单词 while left >= 0: # left指针向左移动: 寻找第一个空格 while left >= 0 and s[left] != ' ': left -= 1 # 将单词添加到结果列表 result.append(s[left + 1 : right + 1]) # 跳过单词之间的空格 while left >= 0 and s[left] == ' ': left -= 1 # 使得right指向下个单词的尾字符 right = left # 将结果列表用空格拼接为字符串并返回 return ' '.join(result) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/155.最小栈/155.最小栈.html":{"url":"LeetCode刷题之旅及题目解析/155.最小栈/155.最小栈.html","title":"155.最小栈","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 155. 最小栈 Java Python 155. 最小栈 https://leetcode-cn.com/problems/min-stack/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 21:57:05 * @LastEditTime: 2020-09-01 21:57:17 * @Description: https://leetcode-cn.com/problems/min-stack/ * @FilePath: \\leetcode-googtech\\#155. Min Stack\\Solution.java * @WebSite: https://algorithm.show/ */ class MinStack { // 声明两个辅助栈,其中 stack 用于存储元素,而 minStack 仅用于存储 stack 中的最小元素 private Stack stack; private Stack minStack; /** initialize your data structure here. */ public MinStack() { // 初始化辅助栈 stack = new Stack<>(); minStack = new Stack<>(); } public void push(int x) { // 将元素压入 stack 栈中 stack.push(x); // 若当前 minStack 为空或其顶部元素小于或等于当前压入的元素 x,则将 x 压入 minStack 栈中 if(minStack.isEmpty() || x Python ''' Author: Goog Tech Date: 2020-09-01 21:57:09 LastEditTime: 2020-09-01 21:58:29 Description: https://leetcode-cn.com/problems/min-stack/ FilePath: \\leetcode-googtech\\#155. Min Stack\\Solution.py WebSite: https://algorithm.show/ ''' class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" # 初始化两个辅助栈,其中 stack 用于存储元素,而 minStack 仅用于存储 stack 中的最小元素 self.stack = [] self.minStack = [] def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" # 将元素压入 stack 栈中 self.stack.append(x) # 若当前 minStack 为空或其顶部元素小于或等于当前压入的元素 x,则将 x 压入 minStack 栈中 if not self.minStack or x Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/160.相交链表/160.相交链表.html":{"url":"LeetCode刷题之旅及题目解析/160.相交链表/160.相交链表.html","title":"160.相交链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 160. 相交链表 Java Python @lc app=leetcode.cn id=160 lang=python [160] 相交链表 @lc code=start 160. 相交链表 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 11:48:46 * @LastEditTime: 2020-08-04 12:04:49 * @Description: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.java */ /* * @lc app=leetcode.cn id=160 lang=java * * [160] 相交链表 */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 判断头节点是否为空 if(headA == null || headB == null) return null; // 题目要求: 勿破坏原链表结构 ListNode nodeA = headA, nodeB = headB; // 循环遍历链表 while(nodeA != nodeB) { // 如果nodeA到了末尾,则令nodeA = headB,然后继续遍历 nodeA = nodeA == null ? headB : nodeA.next; // 如果nodeB到了末尾,则令nodeB = headA,然后继续遍历 nodeB = nodeB == null ? headA : nodeB.next; } return nodeA; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-04 11:14:21 LastEditTime: 2020-08-04 11:46:24 Description: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ FilePath: \\leetcode-googtech\\#160. Intersection of Two Linked Lists\\Solution.py ''' # # @lc app=leetcode.cn id=160 lang=python # # [160] 相交链表 # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" # 判断头节点是否为空 if not headA or not headB: return None # 题目要求: 勿破坏原链表结构 nodeA, nodeB = headA, headB # 循环遍历链表 while(nodeA != nodeB): # 如果nodeA到了末尾,则令nodeA = headB,然后继续遍历 nodeA = nodeA.next if nodeA else headB # 如果nodeB到了末尾,则令nodeB = headA,然后继续遍历 nodeB = nodeB.next if nodeB else headA return nodeA # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/165.比较版本号/165.比较版本号.html":{"url":"LeetCode刷题之旅及题目解析/165.比较版本号/165.比较版本号.html","title":"165.比较版本号","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 165. 比较版本号 Java Python 165. 比较版本号 https://leetcode-cn.com/problems/compare-version-numbers/ Java /* * @Author: Goog Tech * @Date: 2020-08-25 08:45:15 * @LastEditTime: 2020-08-25 08:45:40 * @Description: https://leetcode-cn.com/problems/compare-version-numbers/ * @FilePath: \\leetcode-googtech\\#165. Compare Version Numbers\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int compareVersion(String version1, String version2) { // 根据点分割两个字符串并将其存储到数组中 String[] a1 = version1.split(\"\\\\.\"); String[] a2 = version2.split(\"\\\\.\"); 历较长的数组 for(int n = 0; n j ? 1 : -1; } // 若版本号相同则返回零 return 0; } } Python ''' Author: Goog Tech Date: 2020-08-25 08:45:21 LastEditTime: 2020-08-25 08:45:52 Description: https://leetcode-cn.com/problems/compare-version-numbers/ FilePath: \\leetcode-googtech\\#165. Compare Version Numbers\\Solutoin.py WebSite: https://algorithm.show/ ''' class Solution(object): def compareVersion(self, version1, version2): \"\"\" :type version1: str :type version2: str :rtype: int \"\"\" # 根据点分割两个字符串并将其存储到数组中 nums1, nums2 = version1.split('.'), version2.split('.') # 获取两个字符串的长度 n1, n2 = len(nums1), len(nums2) # 遍历较长的数组 for i in range(max(n1, n2)): # 若其中一个数组先结束遍历了,则在其后添加零,进而可以继续与较长的数组进行比较 v1 = int(nums1[i]) if i v2 else -1 # 若版本号相同则返回零 return 0 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/167.两数之和II-输入有序数组/167.两数之和II-输入有序数组.html":{"url":"LeetCode刷题之旅及题目解析/167.两数之和II-输入有序数组/167.两数之和II-输入有序数组.html","title":"167.两数之和II-输入有序数组","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 167. 两数之和 II - 输入有序数组 Java Python @lc app=leetcode.cn id=167 lang=python [167] 两数之和 II - 输入有序数组 @lc code=start 167. 两数之和 II - 输入有序数组 https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 06:14:03 * @LastEditTime: 2020-08-04 06:44:43 * @Description: https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.java */ /* * @lc app=leetcode.cn id=167 lang=java * * [167] 两数之和 II - 输入有序数组 */ // @lc code=start class Solution { /** * 双指针法,解题思路如下 : * * 1. 初始状态下,令left指向数组第一个元素,right指向最后一个元素 * 2. 进入循环,控制循环退出的条件为: left >= right * 3. 在每一次循环中,如果left与right的数字之和等于所给的target,则返回当前的left,right * 4. 若left与right的数字之和小于所给的target,则left = left + 1,继续循环 * 5. 若left与right的数字之和大于所给的target,则right = right -1,继续循环 */ public int[] twoSum(int[] numbers, int target) { // 初始化头尾指针 int head = 0, tail = numbers.length - 1; // 通过移动头或尾部指针来遍历数组中的元素 while(head Python ''' Author: Goog Tech Date: 2020-08-04 06:45:56 LastEditTime: 2020-08-04 07:20:08 Description: https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.py ''' # # @lc app=leetcode.cn id=167 lang=python # # [167] 两数之和 II - 输入有序数组 # # @lc code=start class Solution(object): # 双指针法 def twoSum(self, numbers, target): \"\"\" :type numbers: List[int] :type target: int :rtype: List[int] \"\"\" # 初始化头尾指针 head, tail = 0, len(numbers) - 1 # 通过移动头或尾部指针来遍历数组中的元素 # left与right的数字之和小于所给的target,则left = left + 1,相反则right = right -1,然后继续循环 while head Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/169.多数元素/169.多数元素.html":{"url":"LeetCode刷题之旅及题目解析/169.多数元素/169.多数元素.html","title":"169.多数元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 169. 多数元素 Java Python 169. 多数元素 https://leetcode-cn.com/problems/majority-element/ Java /* * @Author: Goog Tech * @Date: 2020-10-27 14:30:14 * @LastEditTime: 2020-10-27 14:30:53 * @Description: https://leetcode-cn.com/problems/majority-element/ * @FilePath: \\leetcode-googtech\\#169. Majority Element\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 摩尔投票法 public int majorityElement(int[] nums) { int count = 0, result = 0; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-10-27 14:30:25 LastEditTime: 2020-10-27 14:31:13 Description: https://leetcode-cn.com/problems/majority-element/ FilePath: \\leetcode-googtech\\#169. Majority Element\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 摩尔投票法 def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" result, count = 0, 0 for num in nums: if count == 0: result = num if num != result: count -= 1 else: count += 1 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/173.二叉搜索树迭代器/173.二叉搜索树迭代器.html":{"url":"LeetCode刷题之旅及题目解析/173.二叉搜索树迭代器/173.二叉搜索树迭代器.html","title":"173.二叉搜索树迭代器","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 173. 二叉搜索树迭代器 Java Python 173. 二叉搜索树迭代器 https://leetcode-cn.com/problems/binary-search-tree-iterator/ Java /* * @Author: Goog Tech * @Date: 2020-09-02 21:45:01 * @LastEditTime: 2020-09-02 21:45:29 * @Description: https://leetcode-cn.com/problems/binary-search-tree-iterator/ * @FilePath: \\leetcode-googtech\\#173. Binary Search Tree Iterator\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class BSTIterator { private Stack stack; public BSTIterator(TreeNode root) { stack = new Stack<>(); while(root != null) { stack.push(root); root = root.left; } } /** @return the next smallest number */ public int next() { TreeNode node = stack.pop(); int result = node.val; if(node.right != null) { node = node.right; while(node != null) { stack.push(node); node = node.left; } } return result; } /** @return whether we have a next smallest number */ public boolean hasNext() { if(stack.isEmpty()) return false; return true; } } /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ Python ''' Author: Goog Tech Date: 2020-09-02 21:45:08 LastEditTime: 2020-09-02 21:46:17 Description: https://leetcode-cn.com/problems/binary-search-tree-iterator/ FilePath: \\leetcode-googtech\\#173. Binary Search Tree Iterator\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class BSTIterator(object): def __init__(self, root): \"\"\" :type root: TreeNode \"\"\" self.stack = [] while root: self.stack.append(root) root = root.left def next(self): \"\"\" @return the next smallest number :rtype: int \"\"\" temp =self.stack.pop() result = temp.val temp = temp.right while temp: self.stack.append(temp) temp = temp.left return result def hasNext(self): \"\"\" @return whether we have a next smallest number :rtype: bool \"\"\" return self.stack != [] # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.next() # param_2 = obj.hasNext() Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/182.查找重复的电子邮箱/182.查找重复的电子邮箱.html":{"url":"LeetCode刷题之旅及题目解析/182.查找重复的电子邮箱/182.查找重复的电子邮箱.html","title":"182.查找重复的电子邮箱","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 182. 查找重复的电子邮箱 MySQL SQLServer 182. 查找重复的电子邮箱 https://leetcode-cn.com/problems/duplicate-emails/ MySQL # Write your MySQL query statement below # HAVING 是在 GROUP BY 之后做一个补充筛选,而分组选用的字段是Email, # 所以 COUNT(*) 函数是针对 Email 里面的内容进行分别计数, 即 COUNT(*) > 1 表示指定 email 的出现次数不止一次 SELECT Email FROM Person GROUP BY Email HAVING COUNT(*) > 1 SQLServer /* Write your T-SQL query statement below */ /* 首先使用 group by 进行数据汇总,其次使用 having 进行过滤: 使用 count(字段) 进行统计汇总数据,大于1的则为重复 */ SELECT Email FROM Person GROUP BY Email HAVING COUNT(Email) > 1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/183.从不订购的客户/183.从不订购的客户.html":{"url":"LeetCode刷题之旅及题目解析/183.从不订购的客户/183.从不订购的客户.html","title":"183.从不订购的客户","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 183. 从不订购的客户 MySQL SQLServer 183. 从不订购的客户 https://leetcode-cn.com/problems/customers-who-never-order/ MySQL # Write your MySQL query statement below SELECT Name as Customers FROM Customers WHERE Id NOT IN ( SELECT CustomerId FROM Orders ) SQLServer /* Write your T-SQL query statement below */ SELECT Name as Customers FROM Customers c LEFT JOIN Orders o ON c.Id = o.CustomerId WHERE o.Id IS NULL Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/191.位1的个数/191.位1的个数.html":{"url":"LeetCode刷题之旅及题目解析/191.位1的个数/191.位1的个数.html","title":"191.位1的个数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 191. 位1的个数 Java Python 191. 位1的个数 https://leetcode-cn.com/problems/number-of-1-bits/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 10:07:51 * @LastEditTime: 2020-08-16 10:08:33 * @Description: https://leetcode-cn.com/problems/number-of-1-bits/ * @FilePath: \\leetcode-googtech\\#191. Number of 1 Bits\\Solution.java * @WebSite: https://algorithm.show/ */ public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { // 使用与(&)运算,即两位同时为1时结果才为1 return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1)); } } Python ''' Author: Goog Tech Date: 2020-08-16 10:07:58 LastEditTime: 2020-08-16 10:08:49 Description: https://leetcode-cn.com/problems/number-of-1-bits/ FilePath: \\leetcode-googtech\\#191. Number of 1 Bits\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def hammingWeight(self, n): \"\"\" :type n: int :rtype: int \"\"\" count = 0 # bin() 返回一个整数 int 或者长整数 long int 的二进制表示 for i in str(bin(n)): if i == '1': count += 1 return count Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/196.删除重复的电子邮箱/196.删除重复的电子邮箱.html":{"url":"LeetCode刷题之旅及题目解析/196.删除重复的电子邮箱/196.删除重复的电子邮箱.html","title":"196.删除重复的电子邮箱","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 196. 删除重复的电子邮箱 MySQL 196. 删除重复的电子邮箱 https://leetcode-cn.com/problems/delete-duplicate-emails/ MySQL # Write your MySQL query statement below DELETE p1 FROM person p1 join person p2 ON p1.email = p2.email AND p1.id > p2.id Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/198.打家劫舍/198.打家劫舍.html":{"url":"LeetCode刷题之旅及题目解析/198.打家劫舍/198.打家劫舍.html","title":"198.打家劫舍","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 198. 打家劫舍 Java Python 198. 打家劫舍 https://leetcode-cn.com/problems/house-robber/ Java /* * @Author: Goog Tech * @Date: 2020-09-23 21:28:55 * @LastEditTime: 2020-09-23 21:31:31 * @Description: https://leetcode-cn.com/problems/house-robber/ * @FilePath: \\leetcode-googtech\\#198. House Robber\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // DP : 动态规划 // 设第 n 个房屋的最大金额为 dp[n],解题思路如下: // 1. 若偷第 n 个房屋的话,由于相邻的房屋不能偷,所以 dp[n] = dp[n - 2] + nums[n] (即偷窃总金额等于 n - 2 间房屋的最大总金额 + 第 n 间房屋的金额) // 2. 反之若不偷第 n 个房屋的话,那么 dp[n] = dp[n - 1](即偷窃总金额为 n - 1 间房屋的最大金额) public int rob(int[] nums) { int n = nums.length; if(n == 0) return 0; if(n == 1) return nums[0]; int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i = 2; i Python ''' Author: Goog Tech Date: 2020-09-23 21:29:00 LastEditTime: 2020-09-23 21:31:51 Description: https://leetcode-cn.com/problems/house-robber/ FilePath: \\leetcode-googtech\\#198. House Robber\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # DP : 动态规划 # 设第 n 个房屋的最大金额为 dp[n],解题思路如下: # 1. 若偷第 n 个房屋的话,由于相邻的房屋不能偷,所以 dp[n] = dp[n - 2] + nums[n] (即偷窃总金额等于 n - 2 间房屋的最大总金额 + 第 n 间房屋的金额) # 2. 反之若不偷第 n 个房屋的话,那么 dp[n] = dp[n - 1](即偷窃总金额为 n - 1 间房屋的最大金额) def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if not nums: return 0 length = len(nums) if length == 1: return nums[0] dp = [0] * length dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, length): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[length - 1] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/199.二叉树的右视图/199.二叉树的右视图.html":{"url":"LeetCode刷题之旅及题目解析/199.二叉树的右视图/199.二叉树的右视图.html","title":"199.二叉树的右视图","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 199. 二叉树的右视图 Java Python 199. 二叉树的右视图 https://leetcode-cn.com/problems/binary-tree-right-side-view/ Java /* * @Author: Goog Tech * @Date: 2020-09-23 21:08:32 * @LastEditTime: 2020-09-23 21:09:52 * @Description: https://leetcode-cn.com/problems/binary-tree-right-side-view/ * @FilePath: \\leetcode-googtech\\#199. Binary Tree Right Side View\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // BFS : 广度优先搜索,即层次遍历 public List rightSideView(TreeNode root) { // 初始化结果数组集合 List result = new ArrayList<>(); // 判断根节点是否为空 if(root == null) return result; // 初始化双端辅助队列,并将根节点入队 Queue queue = new LinkedList<>(); queue.offer(root); // 循环遍历队列中的节点 while(!queue.isEmpty()) { // 获取队列中的节点数 int size = queue.size(); // 逐个遍历当前存储在队列中的上个深度层次的节点 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-23 21:08:37 LastEditTime: 2020-09-23 21:08:53 Description: https://leetcode-cn.com/problems/binary-tree-right-side-view/ FilePath: \\leetcode-googtech\\#199. Binary Tree Right Side View\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # BFS : 广度优先搜索,即层次遍历 def rightSideView(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" # 判断根节点是否为空 if not root: return [] # 初始化双端队列以及结果列表 queue, result = collections.deque([root]), [] # 循环遍历队列 while queue: # 逐个遍历队列中的每个元素 for _ in range(len(queue)): # 将队首节点出队,并将其左右孩子节点入队 node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 每次将当前深度的最后一个节点,即最右边的节点加入到结果列表中 result.append(node.val) # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/203.移除链表元素/203.移除链表元素.html":{"url":"LeetCode刷题之旅及题目解析/203.移除链表元素/203.移除链表元素.html","title":"203.移除链表元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 203. 移除链表元素 Java Python 203. 移除链表元素 https://leetcode-cn.com/problems/remove-linked-list-elements/ Java /* * @Author: Goog Tech * @Date: 2020-07-16 16:59:54 * @Description: https://leetcode-cn.com/problems/remove-linked-list-elements/ * @FilePath: \\leetcode-googtech\\#203. Remove Linked List Elements\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // 判断头节点是否为空 if(head==null){ return null; } // 初始化辅助节点 ListNode newNode = new ListNode(0); newNode.next = head; // 初始化当前节点与前继节点指针 ListNode previousNode = newNode; ListNode currentNode = head; // 遍历寻找待删除节点 while(currentNode!=null){ if(currentNode.val == val){ previousNode.next = currentNode.next; }else{ previousNode = currentNode; } currentNode = currentNode.next; } // 返回头节点 return newNode.next; } } /* Remove all elements from a linked list of integers that have value val. Example: Input: 1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5 */ Python ''' @Author: Goog Tech @Date: 2020-07-16 17:00:01 @Description: https://leetcode-cn.com/problems/remove-linked-list-elements/ @FilePath: \\leetcode-googtech\\#203. Remove Linked List Elements\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def removeElements(self, head, val): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" # 初始化辅助节点 newNode = ListNode(0) newNode.next = head # 初始化当前节点与前继节点指针 previousNode,currentNode = newNode,head # 遍历寻找待删除节点 while currentNode: if currentNode.val == val: previousNode.next = currentNode.next else: previousNode = currentNode currentNode = currentNode.next # 返回头节点: same as return head return newNode.next \"\"\" Remove all elements from a linked list of integers that have value val. Example: Input: 1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5 \"\"\" Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/206.反转链表/206.反转链表.html":{"url":"LeetCode刷题之旅及题目解析/206.反转链表/206.反转链表.html","title":"206.反转链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 206. 反转链表 Java Python @lc app=leetcode.cn id=206 lang=python [206] 反转链表 @lc code=start 206. 反转链表 https://leetcode-cn.com/problems/reverse-linked-list/ Java /* * @Author: Goog Tech * @Date: 2020-08-18 09:51:34 * @LastEditTime: 2020-08-18 09:59:44 * @Description: https://leetcode-cn.com/problems/reverse-linked-list/ * @FilePath: \\leetcode-googtech\\#206. Reverse Linked List\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=206 lang=java * * [206] 反转链表 */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 双指针迭代法 public ListNode reverseList(ListNode head) { // 初始化前后指针,其中临时指针用于辅助当前指针移动 ListNode previousNode = null, currentNode = head, tempNode = null; // 循环遍历链表 while(currentNode != null) { // 记录当前节点的下一个节点 tempNode = currentNode.next; // 将当前节点指向前节点previousNode currentNode.next = previousNode; // 继续向后移动前后节点 previousNode = currentNode; currentNode = tempNode; } // 当迭代完毕时currentNode指向null,而previousNode指向最后一个节点 return previousNode; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-18 09:44:05 LastEditTime: 2020-08-18 09:58:18 Description: https://leetcode-cn.com/problems/reverse-linked-list/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\206.反转链表.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=206 lang=python # # [206] 反转链表 # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # 双指针迭代法 def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 初始化前后指针,临时指针用于辅助currentNode指针移动 previousNode, currentNode, tempNode = None, head, None # 遍历链表 while currentNode: # 记录当前指针的下一个节点 tempNode = currentNode.next # 将当前节点指向前节点previousNode currentNode.next = previousNode # 继续向后移动前后指针 previousNode = currentNode currentNode = tempNode # 当迭代完毕时currentNode指向null,而previousNode指向最后一个节点 return previousNode # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/217.存在重复元素/217.存在重复元素.html":{"url":"LeetCode刷题之旅及题目解析/217.存在重复元素/217.存在重复元素.html","title":"217.存在重复元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 217. 存在重复元素 Java Python 217. 存在重复元素 https://leetcode-cn.com/problems/contains-duplicate/ Java /* * @Author: Goog Tech * @Date: 2020-08-21 20:36:30 * @LastEditTime: 2020-08-21 20:36:47 * @Description: https://leetcode-cn.com/problems/contains-duplicate/ * @FilePath: \\leetcode-googtech\\#217. Contains Duplicate\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 利用 HashSet 集合判断数组中是否还有重复元素 public boolean containsDuplicate(int[] nums) { Set result = new HashSet<>(); for(int num : nums) result.add(num); return result.size() == nums.length ? false : true; } } Python ''' Author: Goog Tech Date: 2020-08-21 20:36:36 LastEditTime: 2020-08-21 20:37:02 Description: https://leetcode-cn.com/problems/contains-duplicate/ FilePath: \\leetcode-googtech\\#217. Contains Duplicate\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 利用 HashSet 集合判断数组中是否还有重复元素 def containsDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" return len(set(nums)) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/222.完全二叉树的节点个数/222.完全二叉树的节点个数.html":{"url":"LeetCode刷题之旅及题目解析/222.完全二叉树的节点个数/222.完全二叉树的节点个数.html","title":"222.完全二叉树的节点个数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 222. 完全二叉树的节点个数 Video Java Python 222. 完全二叉树的节点个数 https://leetcode-cn.com/problems/count-complete-tree-nodes/ Video Java /* * @Author: Goog Tech * @Date: 2020-07-25 18:53:10 * @Description: https://leetcode-cn.com/problems/count-complete-tree-nodes/ * @FilePath: \\leetcode-googtech\\#222. Count Complete Tree Nodes\\Solution.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归法 // 1.通过遍历每个结点的左孩子先分别求出左子树和右子树的高度 // 2.如果leftHeight == rightHeight则说明左子树一定是满二叉树,此时求出左子树的节点总数加上当前子树的根节点, // 共计 2^leftHeight 个,而右子树中的节点个数可以通过递归获取 // 3.如果left != right则说明最后一层不满,但倒数第二层已经满了,此时求出右子树的节点总数加上当前子树的根节点, // 共计 2^rightHeight 个,而左子树中的节点个数可以通过递归获取 public int countNodes(TreeNode root) { // 判断头节点是否为空 if(root == null) { return 0; } // 获取左右子树的高度 int leftHeight = count(root.left),rightHeight = count(root.right); // 若左右子树的高度相同则说明左子树为满二叉树,其节点数为 2^leftHeight-1 个,而右子树中节点个数可以通过递归获得 // 总数 = 左子树节点个数 + 根节点 + 右子树节点个数(1 Python ''' @Author: Goog Tech @Date: 2020-07-25 18:53:16 @Description: https://leetcode-cn.com/problems/count-complete-tree-nodes/ @FilePath: \\leetcode-googtech\\#222. Count Complete Tree Nodes\\Solution.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归法 def countNodes(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" # 判断根节点是否为空 if not root: return 0 # 获取左右子树的高度 leftHeight,rightHeight = self.getHeight(root.left),self.getHeight(root.right) # 如果左右子树的高度相同则代表左子树为满二叉树,其节点数为2^leftHeight,即pow(2,leftHeight)-1个 # 而右子树中的节点数可以通过递归的方法获取,即总结数为:左子树节点数 + 根节点数 + 右子树节点数 if leftHeight == rightHeight: return (pow(2,leftHeight)-1) + 1 + self.countNodes(root.right) else: # 反之则代表最后一层不满(倒数第二层是满的),此时右子树的节点数为2^rightHeight,即pow(2,rightHeight)-1个 # 而左子树中的节点数可以通过递归的方法获取,即总结点数为:右子树节点数 + 根节点数 + 左子树节点数 return (pow(2,rightHeight)-1) + 1 + self.countNodes(root.left) # 获取左右子树的高度 def getHeight(self,root): level = 0 # 根据完全二叉树的性质可知,若左子树不为空则高度可加1 while root: level+=1 root = root.left return level Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/225.用队列实现栈/225.用队列实现栈.html":{"url":"LeetCode刷题之旅及题目解析/225.用队列实现栈/225.用队列实现栈.html","title":"225.用队列实现栈","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 225. 用队列实现栈 Java Python 225. 用队列实现栈 https://leetcode-cn.com/problems/implement-stack-using-queues/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 19:24:29 * @LastEditTime: 2020-09-01 19:24:40 * @Description: https://leetcode-cn.com/problems/implement-stack-using-queues/ * @FilePath: \\leetcode-googtech\\#225. Implement Stack using Queues\\Solution.java * @WebSite: https://algorithm.show/ */ class MyStack { // 声明辅助队列 private Queue queue; /** Initialize your data structure here. */ public MyStack() { // 初始化辅助队列 queue = new LinkedList<>(); } /** Push element x onto stack. */ public void push(int x) { // 将当前元素入栈 queue.offer(x); // 因入队顺序为先进先出,而栈则为先进后出,所以需要反转队列中的元素 for(int i = queue.size() - 1; i > 0; i--) { queue.offer(queue.poll()); } } /** Removes the element on top of the stack and returns that element. */ public int pop() { // 弹出队列头元素 return queue.poll(); } /** Get the top element. */ public int top() { // 获取队列头元素 return queue.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { // 判断队列是否为空 return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ Python ''' Author: Goog Tech Date: 2020-09-01 19:24:33 LastEditTime: 2020-09-01 19:27:10 Description: https://leetcode-cn.com/problems/implement-stack-using-queues/ FilePath: \\leetcode-googtech\\#225. Implement Stack using Queues\\Solution.py WebSite: https://algorithm.show/ ''' class MyStack(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" # 初始化辅助队列 self.queue = deque() def push(self, x): \"\"\" Push element x onto stack. :type x: int :rtype: None \"\"\" # 将当前元素入队 self.queue.append(x) # 因入队顺序为先进先出,而栈则为先进后出,所以需要反转队列中的元素 for _ in range(len(self.queue) - 1): self.queue.append(self.queue.popleft()) def pop(self): \"\"\" Removes the element on top of the stack and returns that element. :rtype: int \"\"\" # 弹出队首元素 return self.queue.popleft() def top(self): \"\"\" Get the top element. :rtype: int \"\"\" # 获取队首元素 return self.queue[0] def empty(self): \"\"\" Returns whether the stack is empty. :rtype: bool \"\"\" # 判断队列是否为空 return len(self.queue) == 0 # Your MyStack object will be instantiated and called as such: # obj = MyStack() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.top() # param_4 = obj.empty() Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/226.翻转二叉树/226.翻转二叉树.html":{"url":"LeetCode刷题之旅及题目解析/226.翻转二叉树/226.翻转二叉树.html","title":"226.翻转二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 226. 翻转二叉树 Java Python @lc app=leetcode.cn id=226 lang=python [226] 翻转二叉树 @lc code=start 226. 翻转二叉树 https://leetcode-cn.com/problems/invert-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 09:19:16 * @LastEditTime: 2020-08-16 09:40:05 * @Description: https://leetcode-cn.com/problems/invert-binary-tree/ * @FilePath: \\leetcode-googtech\\#226. Invert Binary Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=226 lang=java * * [226] 翻转二叉树 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if(root == null) return null; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } public TreeNode invertTree(TreeNode root) { // 判断当前节点是否为空 if(root == null) return null; // 交换当前节点的左右孩子节点 TreeNode tempNode = root.right; root.right = root.left; root.left = tempNode; // 递归交换当前节点的左右孩子节点 invertTree(root.left); invertTree(root.right); // 函数返回时即表示当前节点及它的左右孩子都已交换完毕 return root; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-16 09:17:39 LastEditTime: 2020-08-16 09:40:13 Description: https://leetcode-cn.com/problems/invert-binary-tree/ FilePath: \\leetcode-googtech\\#226. Invert Binary Tree\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=226 lang=python # # [226] 翻转二叉树 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def invertTree(self, root): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" if not root: return None root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root def invertTree(self, root): # 判断当前节点是否为空 if not root: return None # 交换当前节点的左右孩子节点 root.left, root.right = root.right, root.left # 递归交换当前节点的左右孩子节点 self.invertTree(root.left) self.invertTree(root.right) # 函数返回时即表示当前节点及它的左右孩子节点都已交换完毕 return root # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/230.二叉搜索树中第K小的元素/230.二叉搜索树中第K小的元素.html":{"url":"LeetCode刷题之旅及题目解析/230.二叉搜索树中第K小的元素/230.二叉搜索树中第K小的元素.html","title":"230.二叉搜索树中第K小的元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 230. 二叉搜索树中第K小的元素 Java Python 230. 二叉搜索树中第K小的元素 https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ Java /* * @Author: Goog Tech * @Date: 2020-08-18 12:35:53 * @LastEditTime: 2020-08-18 12:36:14 * @Description: https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ * @FilePath: \\leetcode-googtech\\#230. Kth Smallest Element in a BST\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { // 中序遍历: 左->根->右, 可得到一个从小到大的序列 // 搜索二叉树的特性为: 左孩子节点 Python ''' Author: Goog Tech Date: 2020-08-18 12:35:58 LastEditTime: 2020-08-18 12:36:44 Description: https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ FilePath: \\leetcode-googtech\\#230. Kth Smallest Element in a BST\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = class Solution(object): # 利用辅助栈及中序遍历: 左->根->右 # 以及搜索二叉树的特性为: 左孩子节点 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/232.用栈实现队列/232.用栈实现队列.html":{"url":"LeetCode刷题之旅及题目解析/232.用栈实现队列/232.用栈实现队列.html","title":"232.用栈实现队列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 232. 用栈实现队列 Java Python 232. 用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/ Java /* * @Author: Goog Tech * @Date: 2020-07-16 18:47:49 * @Description: https://leetcode-cn.com/problems/implement-queue-using-stacks/ * @FilePath: \\leetcode-googtech\\#232. Implement Queue using Stacks\\Solution.java */ class MyQueue { /** Define the stack. */ private Stack inputStack; private Stack outputStack; /** Initialize your data structure here. */ public MyQueue() { inputStack = new Stack<>(); outputStack = new Stack<>(); } /** Push element x to the back of queue. */ public void push(int x) { inputStack.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { copyElement(); return outputStack.pop(); } /** Get the front element. */ public int peek() { copyElement(); return outputStack.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return inputStack.isEmpty() && outputStack.isEmpty(); } /** Copy the elements from inputStack to outputStack. */ public void copyElement(){ if(outputStack.isEmpty()){ while(!inputStack.isEmpty()){ outputStack.push(inputStack.pop()); } } } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ Python # updating Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/234.回文链表/234.回文链表.html":{"url":"LeetCode刷题之旅及题目解析/234.回文链表/234.回文链表.html","title":"234.回文链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 234. 回文链表 Java Python 234. 回文链表 https://leetcode-cn.com/problems/palindrome-linked-list/ Java /* * @Author: Goog Tech * @Date: 2020-07-22 17:45:44 * @Description: https://leetcode-cn.com/problems/palindrome-linked-list/ * @FilePath: \\leetcode-googtech\\#234. Palindrome Linked List\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 双指针法 public boolean isPalindrome(ListNode head) { List list = new ArrayList<>(); // 遍历链表元素并将其存储到数组列表 ListNode currentNode = head; while(currentNode!=null) { list.add(currentNode.val); currentNode = currentNode.next; } // 同时移动头指针和尾指针并判断所指元素是否相等 int front = 0,rear = list.size() - 1; while(rear > front) { if(!list.get(front).equals(list.get(rear))) { return false; } front++; rear--; } return true; } } Python ''' @Author: Goog Tech @Date: 2020-07-22 17:45:49 @Description: https://leetcode-cn.com/problems/palindrome-linked-list/ @FilePath: \\leetcode-googtech\\#234. Palindrome Linked List\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" values = [] currentNode = head while currentNode is not None: values.append(currentNode.val) currentNode = currentNode.next return values == values[::-1] # values[::-1] : 将values数组中元素顺序取反 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/235.二叉搜索树的最近公共祖先/235.二叉搜索树的最近公共祖先.html":{"url":"LeetCode刷题之旅及题目解析/235.二叉搜索树的最近公共祖先/235.二叉搜索树的最近公共祖先.html","title":"235.二叉搜索树的最近公共祖先","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 235. 二叉搜索树的最近公共祖先 Java Python 235. 二叉搜索树的最近公共祖先 https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ Java /* * @Author: Goog Tech * @Date: 2020-09-27 19:30:56 * @LastEditTime: 2020-09-27 19:31:31 * @Description: https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ * @FilePath: \\leetcode-googtech\\#235. Lowest Common Ancestor of a Binary Search Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归解法 // 利用搜索二叉树中每个节点都具备特性: 大于左子树上任意一个节点的值，小于右子树上任意一个节点的值 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 判断当前节点是否为空 if(root == null) return null; // 若当前节点的值大于 q 与 p 的节点值,则说明 q 与 p 都在左子树 if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q); // 若当前节点的值小于 q 与 p 的节点值,则说明 q 与 p 都在右子树 if(root.val Python ''' Author: Goog Tech Date: 2020-09-27 19:31:07 LastEditTime: 2020-09-27 19:31:45 Description: https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ FilePath: \\leetcode-googtech\\#235. Lowest Common Ancestor of a Binary Search Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归解法 # 利用搜索二叉树中每个节点都具备特性: 大于左子树上任意一个节点的值，小于右子树上任意一个节点的值 def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" # 判断当前节点是否为空 if not root: return None # 若当前节点的值大于 q 与 p 的节点值,则说明 q 与 p 都在左子树 if root.val > p.val and root.val > q.val: return self.lowestCommonAncestor(root.left, p, q) # 若当前节点的值小于 q 与 p 的节点值,则说明 q 与 p 都在右子树 elif root.val Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/236.二叉树的最近公共祖先/236.二叉树的最近公共祖先.html":{"url":"LeetCode刷题之旅及题目解析/236.二叉树的最近公共祖先/236.二叉树的最近公共祖先.html","title":"236.二叉树的最近公共祖先","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 236. 二叉树的最近公共祖先 Java Python 236. 二叉树的最近公共祖先 https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-09-27 17:40:11 * @LastEditTime: 2020-09-27 17:41:51 * @Description: https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ * @FilePath: \\leetcode-googtech\\#236. Lowest Common Ancestor of a Binary Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归解法 &#x1F635; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 若当前节点为空或等于 q 或 p,则直接返回 root if(root == null || root.val == p.val || root.val == q.val) return root; // 递归左右子树节点 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 若 left 和 right 都为空,则说明 q 与 p 分别在 root 的异侧,因此 root 为最近公共节点 // 反之都为空则说明 root 的左右子树都不包含 q 与 p,进而返回 null 即可 if(left != null && right != null) return root; // 若 left 为空而 right 不为空,则说明 p 与 q 都不在 root 的左子树中,直接返回 right 即可 return left == null ? right : left; } } Python ''' Author: Goog Tech Date: 2020-09-27 17:40:32 LastEditTime: 2020-09-27 17:40:57 Description: https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ FilePath: \\leetcode-googtech\\#236. Lowest Common Ancestor of a Binary Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归解法 &#x1F635; def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" if not root or root.val == p.val or root.val == q.val: return root; left = self.lowestCommonAncestor(root.left, q, p) right = self.lowestCommonAncestor(root.right, q, p) if left and right: return root return right if left is None else left Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/237.删除链表中的节点/237.删除链表中的节点.html":{"url":"LeetCode刷题之旅及题目解析/237.删除链表中的节点/237.删除链表中的节点.html","title":"237.删除链表中的节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 237. 删除链表中的节点 Java Python 237. 删除链表中的节点 https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ Java /* * @Author: Goog Tech * @Date: 2020-07-15 23:29:09 * @Description: https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ * @FilePath: \\leetcode-googtech\\#237. Delete Node in a Linked List\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // node表示的是要删除的结点 public void deleteNode(ListNode node) { // 前移待删除节点后的一个节点的值 node.val = node.next.val; // 更新待删除节点的指针 node.next = node.next.next; } } /* Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. */ Python ''' @Author: Goog Tech @Date: 2020-07-15 23:29:15 @Description: https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ @FilePath: \\leetcode-googtech\\#237. Delete Node in a Linked List\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node.val = node.next.val # 前移待删除节点的后一个节点的值 node.next = node.next.next # 更新待删除节点的指针 \"\"\" Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function. \"\"\" Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/242.有效的字母异位词/242.有效的字母异位词.html":{"url":"LeetCode刷题之旅及题目解析/242.有效的字母异位词/242.有效的字母异位词.html","title":"242.有效的字母异位词","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 242. 有效的字母异位词 Java Python 242. 有效的字母异位词 https://leetcode-cn.com/problems/valid-anagram/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 17:00:00 * @LastEditTime: 2020-08-24 17:00:38 * @Description: https://leetcode-cn.com/problems/valid-anagram/ * @FilePath: \\leetcode-googtech\\#242. Valid Anagram\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 使用数组替代哈希表 public boolean isAnagram(String s, String t) { // 判断两字符串的长度是否相同 if(s.length() != t.length()) return false; // 初始化整型数组 int[] arr = new int[26]; // 遍历字符串,其中 s.charAt(i) - a 作为元素索引, // 其取值范围为 0 到 25,并将该字母出现的次数作为索引值 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-24 17:00:05 LastEditTime: 2020-08-24 17:00:27 Description: https://leetcode-cn.com/problems/valid-anagram/ FilePath: \\leetcode-googtech\\#242. Valid Anagram\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" # 判断两字符串的长度是否相同 if len(s) != len(t): return False # 将 s 字符串转换为 set 集合(无重复性质),然后进行字符遍历 for ch in set(s): # 判断当前字符在字符串 s 中出现的次数与 t 是否相等 if s.count(ch) != t.count(ch): return False return True Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/257.二叉树的所有路径/257.二叉树的所有路径.html":{"url":"LeetCode刷题之旅及题目解析/257.二叉树的所有路径/257.二叉树的所有路径.html","title":"257.二叉树的所有路径","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 257. 二叉树的所有路径 Java Python @lc app=leetcode.cn id=257 lang=python [257] 二叉树的所有路径 @lc code=start 257. 二叉树的所有路径 https://leetcode-cn.com/problems/binary-tree-paths/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 17:00:50 * @LastEditTime: 2020-08-16 17:11:57 * @Description: https://leetcode-cn.com/problems/binary-tree-paths/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\257.二叉树的所有路径.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=257 lang=java * * [257] 二叉树的所有路径 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List binaryTreePaths(TreeNode root) { LinkedList paths = new LinkedList<>(); getPaths(root, \"\", paths); return paths; } private void getPaths(TreeNode root, String path, LinkedList paths) { if(root !=null) { // 记录当前节点到叶子节点的路径 path += Integer.toString(root.val); // 判断当前节点是否为叶子节点,若是则将其整体添加到 List 集合中 if(root.left == null && root.right == null) { paths.add(path); // 反之则继续遍历当前节点的左右孩子节点 }else { path += \"->\"; getPaths(root.left, path, paths); getPaths(root.right, path, paths); } } } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-16 16:58:35 LastEditTime: 2020-08-16 17:10:50 Description: https://leetcode-cn.com/problems/binary-tree-paths/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\257.二叉树的所有路径.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=257 lang=python # # [257] 二叉树的所有路径 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def binaryTreePaths(self, root): \"\"\" :type root: TreeNode :rtype: List[str] \"\"\" # 判断当前节点是否为空 if not root: return [] # 判断当前节点是否为叶子节点 if not root.left and not root.right: return [str(root.val)] # 初始化用于存储根节点到左右叶子节点路径的列表 paths = [] # 递归添加当前节点到叶子节点的路径 if root.left: for i in self.binaryTreePaths(root.left): paths.append(str(root.val) + '->' + i) if root.right: for i in self.binaryTreePaths(root.right): paths.append(str(root.val) + '->' + i) # 返回结果 return paths # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/258.各位相加/258.各位相加.html":{"url":"LeetCode刷题之旅及题目解析/258.各位相加/258.各位相加.html","title":"258.各位相加","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 258. 各位相加 Java Python 258. 各位相加 https://leetcode-cn.com/problems/add-digits/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 14:24:10 * @LastEditTime: 2020-08-16 14:25:49 * @Description: https://leetcode-cn.com/problems/add-digits/ * @FilePath: \\leetcode-googtech\\#258. Add Digits\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int addDigits(int num) { if(num Python ''' Author: Goog Tech Date: 2020-08-16 14:25:08 LastEditTime: 2020-08-16 14:25:22 Description: https://leetcode-cn.com/problems/add-digits/ FilePath: \\leetcode-googtech\\#258. Add Digits\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def addDigits(self, num): \"\"\" :type num: int :rtype: int \"\"\" if num Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/260.只出现一次的数字III/260.只出现一次的数字III.html":{"url":"LeetCode刷题之旅及题目解析/260.只出现一次的数字III/260.只出现一次的数字III.html","title":"260.只出现一次的数字III","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 260. 只出现一次的数字 III Java Python 260. 只出现一次的数字 III https://leetcode-cn.com/problems/single-number-iii/ Java /* * @Author: Goog Tech * @Date: 2020-08-21 21:03:48 * @LastEditTime: 2020-08-21 21:06:07 * @Description: https://leetcode-cn.com/problems/single-number-iii/ * @FilePath: \\leetcode-googtech\\#260. Single Number III\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 哈希表法 public int[] singleNumber(int[] nums) { HashSet set = new HashSet<>(); // 遍历数组,若当前元素在set集合中已存在则将其移除 // 反之将其添加到set集合中 for(int num : nums) { if(set.contains(num)) { set.remove(num); }else { set.add(num); } } // 将set集合中存储的两个元素转存到结果数组中 int[] result = new int[2]; int index = 0; for(int element : set) { result[index++] = element; } // 返回结果数组 return result; } } Python ''' Author: Goog Tech Date: 2020-08-21 21:03:52 LastEditTime: 2020-08-21 21:04:10 Description: https://leetcode-cn.com/problems/single-number-iii/ FilePath: \\leetcode-googtech\\#260. Single Number III\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 哈希表法 def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" # Counter() 用于统计字符出现的个数或列表内出现的元素次数 hashMap = Counter(nums) return [x for x in hashMap if hashMap[x] == 1] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/283.移动零/283.移动零.html":{"url":"LeetCode刷题之旅及题目解析/283.移动零/283.移动零.html","title":"283.移动零","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 283. 移动零 Java Python @lc app=leetcode.cn id=283 lang=python [283] 移动零 @lc code=start 283. 移动零 https://leetcode-cn.com/problems/move-zeroes/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 17:42:47 * @LastEditTime: 2020-08-14 17:59:37 * @Description: https://leetcode-cn.com/problems/move-zeroes/ * @FilePath: \\leetcode-googtech\\#283. Move Zeroes\\Soultion.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=283 lang=java * * [283] 移动零 */ // @lc code=start class Solution { public void moveZeroes(int[] nums) { if(nums == null) return; //第一次遍历: 将数组中的非零元素赋值给nums[j] int j = 0; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-14 17:50:48 LastEditTime: 2020-08-14 17:59:45 Description: https://leetcode-cn.com/problems/move-zeroes/ FilePath: \\leetcode-googtech\\#283. Move Zeroes\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=283 lang=python # # [283] 移动零 # # @lc code=start class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\" if not nums: return 0 # 第一次遍历: 将数组中的非零元素赋值给nums[j] j = 0 for i in range(len(nums)): if nums[i] != 0: nums[j] = nums[i] j += 1 # 第二次遍历: 非零元素已移动完毕,最后将数组末尾元素赋值为0即可 for i in range(j, len(nums)): nums[i] = 0 # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/303.区域和检索-数组不可变/303.区域和检索-数组不可变.html":{"url":"LeetCode刷题之旅及题目解析/303.区域和检索-数组不可变/303.区域和检索-数组不可变.html","title":"303.区域和检索-数组不可变","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 303. 区域和检索 - 数组不可变 Java Python 303. 区域和检索 - 数组不可变 https://leetcode-cn.com/problems/range-sum-query-immutable/ Java /* * @Author: Goog Tech * @Date: 2020-09-15 15:07:30 * @LastEditTime: 2020-09-15 15:11:43 * @Description: https://leetcode-cn.com/problems/range-sum-query-immutable/ * @FilePath: \\leetcode-googtech\\#303. Range Sum Query - Immutable\\Solution.java * @Reference: https://leetcode-cn.com/problems/range-sum-query-immutable/solution/marveljian-dan-de-xue-xi-bi-ji-303-by-tyanyonecanc/ * @WebSite: https://algorithm.show/ */ class NumArray { private int[] sum; // DP : 动态规划 public NumArray(int[] nums) { sum = Arrays.copyOf(nums, nums.length); for(int i = 1; i Python ''' Author: Goog Tech Date: 2020-09-15 15:07:34 LastEditTime: 2020-09-15 15:08:56 Description: https://leetcode-cn.com/problems/range-sum-query-immutable/ FilePath: \\leetcode-googtech\\#303. Range Sum Query - Immutable\\Solution.py Reference: https://leetcode-cn.com/problems/range-sum-query-immutable/solution/marveljian-dan-de-xue-xi-bi-ji-303-by-tyanyonecanc/ WebSite: https://algorithm.show/ ''' class NumArray(object): # DP : 动态规划 def __init__(self, nums): \"\"\" :type nums: List[int] \"\"\" if not nums: return self.result = [0] * len(nums) self.result[0] = nums[0] for i in range(1, len(nums)): # result[i] 的值为 nums[0] 到 nums[i] 的所有值之和 self.result[i] = self.result[i - 1] + nums[i] def sumRange(self, i, j): \"\"\" :type i: int :type j: int :rtype: int \"\"\" if i == 0: return self.result[j] else: return self.result[j] - self.result[i - 1] # Your NumArray object will be instantiated and called as such: # obj = NumArray(nums) # param_1 = obj.sumRange(i,j) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/344.反转字符串/344.反转字符串.html":{"url":"LeetCode刷题之旅及题目解析/344.反转字符串/344.反转字符串.html","title":"344.反转字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 344. 反转字符串 Java Python 344. 反转字符串 https://leetcode-cn.com/problems/reverse-string/ Java /* * @Author: Goog Tech * @Date: 2020-07-22 18:03:18 * @Description: https://leetcode-cn.com/problems/reverse-string/ * @FilePath: \\leetcode-googtech\\#344. Reverse String\\Solution.java */ class Solution { // 双指针法 public void reverseString(final char[] s) { char temp; int left = 0,right = s.length - 1; while(left Python ''' @Author: Goog Tech @Date: 2020-07-22 18:03:26 @Description: https://leetcode-cn.com/problems/reverse-string/ @FilePath: \\leetcode-googtech\\#344. Reverse String\\Solution.py ''' class Solution(object): # 双指针法 def reverseString(self, s): \"\"\" :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. \"\"\" left, right = 0, len(s) - 1 while left Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/345.反转字符串中的元音字母/345.反转字符串中的元音字母.html":{"url":"LeetCode刷题之旅及题目解析/345.反转字符串中的元音字母/345.反转字符串中的元音字母.html","title":"345.反转字符串中的元音字母","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 345. 反转字符串中的元音字母 Java Python 345. 反转字符串中的元音字母 https://leetcode-cn.com/problems/reverse-vowels-of-a-string/ Java /* * @Author: Goog Tech * @Date: 2020-07-25 17:39:22 * @Description: https://leetcode-cn.com/problems/reverse-vowels-of-a-string/ * @FilePath: \\leetcode-googtech\\#345. Reverse Vowels of a String\\Solution.java */ class Solution { // 双指针法 public String reverseVowels(String s) { // 声明用于交换数组元素的中间变量 char temp; // 将字符串转换为数组 char[] str = s.toCharArray(); // 声明用于匹配的元音字符串 String letter = \"aeuioAEIUO\"; // 初始化头指针和尾指针 int first = 0,last = s.length() - 1; // 遍历数组中的元素 while(first Python ''' @Author: Goog Tech @Date: 2020-07-25 17:39:29 @Description: https://leetcode-cn.com/problems/reverse-vowels-of-a-string/ @FilePath: \\leetcode-googtech\\#345. Reverse Vowels of a String\\Solution.py ''' class Solution(object): # 双指针法 def reverseVowels(self, s): \"\"\" :type s: str :rtype: str \"\"\" # 声明用于匹配的元音列表 patterns = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] # 初始化头部和尾部指针 left = 0 right = len(s) - 1 # 将字符串转换为列表 s = list(s) # 遍历列表 while left left and s[right] not in patterns: right = right - 1 # 反转列表中的元音字符并且继续移动头和尾部指针 s[left], s[right] = s[right], s[left] left = left + 1 right = right - 1 # 返回结果 return ''.join(s) \"\"\" Python join() 方法用于将序列(sequence)中的元素以指定的字符连接生成一个新的字符串 join()方法语法: str.join(sequence) str = \"-\"; seq = (\"a\", \"b\", \"c\"); print str.join( seq ); \"\"\" Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/349.两个数组的交集/349.两个数组的交集.html":{"url":"LeetCode刷题之旅及题目解析/349.两个数组的交集/349.两个数组的交集.html","title":"349.两个数组的交集","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 349. 两个数组的交集 Java Python 349. 两个数组的交集 https://leetcode-cn.com/problems/intersection-of-two-arrays/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 09:31:26 * @LastEditTime: 2020-08-09 09:32:33 * @Description: https://leetcode-cn.com/problems/intersection-of-two-arrays/ * @FilePath: \\leetcode-googtech\\#349. Intersection of Two Arrays\\Solution.java */ class Solution { public int[] intersection(int[] nums1, int[] nums2) { // 初始化set集合 Set set = new HashSet<>(); // 对数组进行排序 Arrays.sort(nums1); Arrays.sort(nums2); // 循环遍历两数组中的元素,若相同则将其加入到set集合中,反之则继续移动p1或p2指针 int p1 = 0, p2 = 0; while(p1 nums2[p2]) { p2++; } } // 将set集合转换为数组并返回 int index = 0; int[] result = new int[set.size()]; for(int num : set) { result[index++] = num; } return result; } } Python ''' Author: Goog Tech Date: 2020-08-09 09:31:38 LastEditTime: 2020-08-09 09:33:23 Description: https://leetcode-cn.com/problems/intersection-of-two-arrays/ FilePath: \\leetcode-googtech\\#349. Intersection of Two Arrays\\Solution.py ''' class Solution(object): # 双指针法 def intersection(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" # 判断数组是否为空 if not nums1 or not nums2: return [] # 获取数组长度 nums1Len = len(nums1) nums2Len = len(nums2) # 初始化双指针 p1, p2 = 0, 0 # 初始化结果集合(题目要求: 输出结果中的每个元素一定是唯一的) res = set() # 对数组进行排序 nums1, nums2 = sorted(nums1), sorted(nums2) # 循环遍历两数组中的元素,如果两元素相同则将其加入到set结合中,反之则继续移动p1或这p2指针 while p1 nums2[p2]: p2 += 1 else: p1 += 1 # 将结果转换为列表并返回 return list(res) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/350.两个数组的交集II/350.两个数组的交集II.html":{"url":"LeetCode刷题之旅及题目解析/350.两个数组的交集II/350.两个数组的交集II.html","title":"350.两个数组的交集II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 350. 两个数组的交集 II Java Python 350. 两个数组的交集 II https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 16:36:47 * @LastEditTime: 2020-08-30 16:37:05 * @Description: https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ * @FilePath: \\leetcode-googtech\\#350. Intersection of Two Arrays II\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public int[] intersect(int[] nums1, int[] nums2) { // 分别对两个数组进行排序 Arrays.sort(nums1); Arrays.sort(nums2); // 初始化用于存储交集元素的 list 集合 List list = new ArrayList<>(); // 初始化双指针并遍历数组元素 for(int i = 0, j = 0; i nums2[j]) { j++; // 若相同则将当前指针所指元素添加到 list 集合中,并将双指针向后移动一位 }else { list.add(nums1[i]); i++; j++; } } // 根据集合长度初始化结果数组,并通过遍历集合中的元素将其添加到结果数组中 int[] result = new int[list.size()]; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-30 16:36:52 LastEditTime: 2020-08-30 16:37:12 Description: https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ FilePath: \\leetcode-googtech\\#350. Intersection of Two Arrays II\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 双指针法 def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" # 分别对两个数组进行排序 nums1, nums2 = sorted(nums1), sorted(nums2) # 初始化双指针 l1, l2 = 0, 0 # 初始化结果列表 result = [] # 通过分别移动双指针来循环遍历两数组中的元素 while l1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/383.赎金信/383.赎金信.html":{"url":"LeetCode刷题之旅及题目解析/383.赎金信/383.赎金信.html","title":"383.赎金信","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 383. 赎金信 Java Python 383. 赎金信 https://leetcode-cn.com/problems/ransom-note/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 16:26:33 * @LastEditTime: 2020-08-24 16:26:50 * @Description: https://leetcode-cn.com/problems/ransom-note/ * @FilePath: \\leetcode-googtech\\#383. Ransom Note\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 用数组代替哈希表 public boolean canConstruct(String ransomNote, String magazine) { // 初始化整型数组 int[] countR = new int[26]; int[] countM = new int[26]; // 存储每个字符对应的数值,其中 c - a 为数组索引,其取值范围为 0 到 25,而值为该字母出现的次数 for(char c : ransomNote.toCharArray()) countR[c - 'a'] ++; for(char c : magazine.toCharArray()) countM[c - 'a'] ++; // 遍历数组,逐个判断 countR 中元素出现的次数是否大于 countM for(int i = 0; i countM[i]) { return false; } } return true; } } Python ''' Author: Goog Tech Date: 2020-08-24 16:26:37 LastEditTime: 2020-08-24 16:28:45 Description: https://leetcode-cn.com/problems/ransom-note/ FilePath: \\leetcode-googtech\\#383. Ransom Note\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def canConstruct(self, ransomNote, magazine): \"\"\" :type ransomNote: str :type magazine: str :rtype: bool \"\"\" # 遍历 ransomNote 中的元素,判断当前元素在 ransomNote 中出现的次数大于 magazine for ch in set(ransomNote): if ransomNote.count(ch) > magazine.count(ch): return False return True Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/387.字符串中的第一个唯一字符/387.字符串中的第一个唯一字符.html":{"url":"LeetCode刷题之旅及题目解析/387.字符串中的第一个唯一字符/387.字符串中的第一个唯一字符.html","title":"387.字符串中的第一个唯一字符","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 387. 字符串中的第一个唯一字符 Java Python 387. 字符串中的第一个唯一字符 https://leetcode-cn.com/problems/first-unique-character-in-a-string/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 15:26:19 * @LastEditTime: 2020-08-24 15:27:02 * @Description: https://leetcode-cn.com/problems/first-unique-character-in-a-string/ * @FilePath: \\leetcode-googtech\\#387. First Unique Character in a String\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 利用哈希表 public int firstUniqChar(String s) { // 获取字符串的长度值 int length = s.length(); // 初始化HashMap,其中 key 存储字符,value 存储对应字符出现的次数 Map map = new HashMap<>(); // 遍历字符串,若当前字符在 map 中已存在,则获取对应字符出现的次数并加一,反之 value 为零 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-24 15:26:24 LastEditTime: 2020-08-24 15:26:45 Description: https://leetcode-cn.com/problems/first-unique-character-in-a-string/ FilePath: \\leetcode-googtech\\#387. First Unique Character in a String\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 利用哈希表 def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" # 计算每个字符出现的次数 count = Counter(s) # 找到并返回首个满足出现次数为一的字符的下标值 for index, char in enumerate(s): if count[char] == 1: return index # 无果 return -1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/389.找不同/389.找不同.html":{"url":"LeetCode刷题之旅及题目解析/389.找不同/389.找不同.html","title":"389.找不同","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 389. 找不同 Java Python 389. 找不同 https://leetcode-cn.com/problems/find-the-difference/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 15:42:39 * @LastEditTime: 2020-08-24 15:43:17 * @Description: https://leetcode-cn.com/problems/find-the-difference/ * @FilePath: \\leetcode-googtech\\#389. Find the Difference\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 解题思路: 首先将字符串转换为字符数组,然后求和做差,即可得到新插入的字符 public char findTheDifference(String s, String t) { int sum = 0; for(char c : t.toCharArray()) sum += c; for(char c : s.toCharArray()) sum -= c; return (char)sum; } } Python ''' Author: Goog Tech Date: 2020-08-24 15:42:44 LastEditTime: 2020-08-24 15:43:35 Description: https://leetcode-cn.com/problems/find-the-difference/ FilePath: \\leetcode-googtech\\#389. Find the Difference\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 解题思路: 遍历字符串,通过比较字符出现的次数即可得到新插入的字符 def findTheDifference(self, s, t): \"\"\" :type s: str :type t: str :rtype: str \"\"\" for i in range(len(t)): if t.count(t[i]) != s.count(t[i]): return t[i] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/392.判断子序列/392.判断子序列.html":{"url":"LeetCode刷题之旅及题目解析/392.判断子序列/392.判断子序列.html","title":"392.判断子序列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 392. 判断子序列 Java Python 392. 判断子序列 https://leetcode-cn.com/problems/is-subsequence/ Java /* * @Author: Goog Tech * @Date: 2020-08-25 09:15:19 * @LastEditTime: 2020-08-25 09:16:27 * @Description: https://leetcode-cn.com/problems/is-subsequence/ * @FilePath: \\leetcode-googtech\\#392. Is Subsequence\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public boolean isSubsequence(String s, String t) { // 分别获取两个字符的长度 int n = s.length(), m = t.length(); // 初始化双指针,分别指向 s 与 t 的初始位置 int i = 0, j = 0; // 循环遍历两字符串 while(i Python ''' Author: Goog Tech Date: 2020-08-25 09:15:24 LastEditTime: 2020-08-25 09:16:16 Description: https://leetcode-cn.com/problems/is-subsequence/ FilePath: \\leetcode-googtech\\#392. Is Subsequence\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 双指针法 def isSubsequence(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" # 初始化双指针,分别指向 s 与 t 的初始位置 i, j = 0, 0 # 循环遍历两字符串 while i Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/414.第三大的数/414.第三大的数.html":{"url":"LeetCode刷题之旅及题目解析/414.第三大的数/414.第三大的数.html","title":"414.第三大的数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 414. 第三大的数 Java Python 414. 第三大的数 https://leetcode-cn.com/problems/third-maximum-number/ Java /* * @Author: Goog Tech * @Date: 2020-07-25 10:45:27 * @Description: https://leetcode-cn.com/problems/third-maximum-number/ * @FilePath: \\leetcode-googtech\\#414. Third Maximum Number\\Solution.java */ class Solution { // Long.MIN_VALUE=-9223372036854775808(-2的63次方) private long MIN_VALUE = Long.MIN_VALUE; public int thirdMax(int[] nums) { // 初始化第一,第二以及第三大元素 long firstElement = MIN_VALUE,secondElement = MIN_VALUE,thirdElement = MIN_VALUE; // 遍历数组,获取第一,第二以及第三大元素 for(int num : nums) { if(num > firstElement) { thirdElement = secondElement; secondElement = firstElement; firstElement = num; }else if(secondElement Python ''' @Author: Goog Tech @Date: 2020-07-25 10:45:35 @Description: https://leetcode-cn.com/problems/third-maximum-number/ @FilePath: \\leetcode-googtech\\#414. Third Maximum Number\\Solution.py ''' class Solution(object): def thirdMax(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # 初始化第一,第二以及第三大元素 # -sys.maxsize = -9223372036854775807 first = second = thrid = -sys.maxsize # 遍历数组,获取第一,第二以及第三大元素的值 for num in nums: if num > first: thrid, second, first = second, first, num elif second Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/415.字符串相加/415.字符串相加.html":{"url":"LeetCode刷题之旅及题目解析/415.字符串相加/415.字符串相加.html","title":"415.字符串相加","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 415. 字符串相加 Java Python 415. 字符串相加 https://leetcode-cn.com/problems/add-strings/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 19:18:41 * @LastEditTime: 2020-08-24 19:20:49 * @Description: https://leetcode-cn.com/problems/add-strings/ * @FilePath: \\leetcode-googtech\\#415. Add Strings\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public String addStrings(String num1, String num2) { StringBuilder sb = new StringBuilder(); // 初始化进位值及两个字符串的尾指针 int carry = 0, i = num1.length() - 1, j = num2.length() - 1; // 循环遍历字符串 while(i >= 0 || j >= 0 || carry != 0) { // 移动字符串尾指针,并累加元素值,其中减 '0' 是为了将字符型转换为整型 if(i >= 0) carry += num1.charAt(i--) - '0'; if(j >= 0) carry += num2.charAt(j--) - '0'; // 取个位数值并将其存储到 sb 中 sb.append(carry % 10); // 舍去个位数值进而获取进位值 carry = carry / 10; } // 将结果反转后返回 return sb.reverse().toString(); } } Python ''' Author: Goog Tech Date: 2020-08-24 19:18:46 LastEditTime: 2020-08-24 19:20:16 Description: https://leetcode-cn.com/problems/add-strings/ FilePath: \\leetcode-googtech\\#415. Add Strings\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def addStrings(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\" # 初始化结果列表 result = [] # 初始化字符串尾指针及进位值 i, j, carry = len(num1) - 1, len(num2) - 1, 0 # 循环遍历字符串 while i >= 0 or j >= 0 or carry: # 移动字符串尾指针,并累加元素值,其中 ord() 方法的返回值是对应的十进制整数 if i >= 0: carry += ord(num1[i]) - ord('0') if j >= 0: carry += ord(num2[j]) - ord('0') # 取个位数值并将其存储到 result 列表中 result.append(str(carry % 10)) # 舍去个位数值进而获取进位值 carry = carry // 10 # 向前移动字符串尾指针 i, j = i - 1, j -1 # 将结果列表反转后转换为字符串,然后返回 return ''.join(result[::-1]) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/429.N叉树的层序遍历/429.N叉树的层序遍历.html":{"url":"LeetCode刷题之旅及题目解析/429.N叉树的层序遍历/429.N叉树的层序遍历.html","title":"429.N叉树的层序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 429. N叉树的层序遍历 Java Python @lc app=leetcode.cn id=429 lang=python [429] N叉树的层序遍历 @lc code=start 429. N叉树的层序遍历 https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-29 09:51:18 * @LastEditTime: 2020-07-29 10:29:48 * @Description: https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\429.n叉树的层序遍历.java */ /* * @lc app=leetcode.cn id=429 lang=java * * [429] N叉树的层序遍历 */ // @lc code=start /* // Definition for a Node. class Node { public int val; public List children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List _children) { val = _val; children = _children; } }; */ class Solution { // BFS: 利用队列实现广度优先搜索 public List> levelOrder(Node root) { // 初始化辅助队列和结果列表 Queue queue = new LinkedList<>(); List> result = new ArrayList<>(); // 若头节点不为空则将其压入辅助队列中 if(root != null) queue.add(root); // 循环遍历辅助队列 while(!queue.isEmpty()) { // 初始化辅助节点,用于将当前出队节点存储到结果列表中 List temp = new ArrayList<>(); // 将辅助队列中的节点依次出队,并将其孩子节点依次入队 for(int i = queue.size(); i > 0; i--) { Node node = queue.poll(); if(node != null) { temp.add(node.val); for(Node children : node.children) { queue.add(children); // queue.addAll(node.children); } } } // 存储辅助队列中当前出队的节点 result.add(temp); } // 返回结果列表 return result; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-29 10:31:43 @LastEditTime: 2020-07-29 10:56:49 @Description: https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\429.n叉树的层序遍历.py ''' # # @lc app=leetcode.cn id=429 lang=python # # [429] N叉树的层序遍历 # # @lc code=start \"\"\" # Definition for a Node. class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children \"\"\" class Solution(object): # BFS: 利用队列实现广度优先搜索 def levelOrder(self, root): \"\"\" :type root: Node :rtype: List[List[int]] \"\"\" # 若头节点不为空则将其压入辅助队列中 if not root: return [] # 初始化辅助队列和结果列表 result, queue = [], [root] # 循环遍历辅助队列 while queue: # 初始化辅助节点,用于将当前出队节点存储到结果列表中 temp = [] # 将辅助队列中的节点依次出队,并将其孩子节点依次入队 for i in range(len(queue)): node = queue.pop(0) if node is not None: temp.append(node.val) for children in node.children: queue.append(children) # 存储辅助队列中当前出队的节点 result.append(temp) # 返回结果列表 return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/434.字符串中的单词数/434.字符串中的单词数.html":{"url":"LeetCode刷题之旅及题目解析/434.字符串中的单词数/434.字符串中的单词数.html","title":"434.字符串中的单词数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 434. 字符串中的单词数 Java Python 434. 字符串中的单词数 https://leetcode-cn.com/problems/number-of-segments-in-a-string/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 07:04:17 * @LastEditTime: 2020-08-09 07:05:23 * @Description: https://leetcode-cn.com/problems/number-of-segments-in-a-string/ * @FilePath: \\leetcode-googtech\\#434. Number of Segments in a String\\Solution.java */ class Solution { public int countSegments(String s) { // 将字符串转换为char数组 char[] chars = s.toCharArray(); int len = 0; char lastChar = ' '; // 遍历char数组并统计字符串中的空格数 for(char c : chars) { if(c != ' ' && lastChar == ' ') { len++; } lastChar = c; } return len; } } Python ''' Author: Goog Tech Date: 2020-08-09 07:04:25 LastEditTime: 2020-08-09 07:06:02 Description: https://leetcode-cn.com/problems/number-of-segments-in-a-string/ FilePath: \\leetcode-googtech\\#434. Number of Segments in a String\\Solution.py ''' class Solution(object): def countSegments(self, s): \"\"\" :type s: str :rtype: int \"\"\" length = 0 lastChar = ' ' # 循环遍历数组元素 for c in s: # 统计字符串中的空格数 if c != ' ' and lastChar == ' ': length += 1 lastChar = c return length Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/442.数组中重复的数据/442.数组中重复的数据.html":{"url":"LeetCode刷题之旅及题目解析/442.数组中重复的数据/442.数组中重复的数据.html","title":"442.数组中重复的数据","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 442. 数组中重复的数据 Java Python 442. 数组中重复的数据 https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-27 16:45:05 * @LastEditTime: 2020-08-27 16:45:42 * @Description: https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/ * @FilePath: \\leetcode-googtech\\#442. Find All Duplicates in an Array\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 原地修改法 public List findDuplicates(int[] nums) { // 初始化结果列表 List result = new ArrayList<>(); // 遍历数组 for(int i = 0; i 0) { // 若得到的元素值为正则取其相反数 nums[num - 1] *= -1; }else { // 若为负则说明该元素已经出现过,进而将其存储到结果列表中 result.add(num); } } // 返回结果 return result; } } Python ''' Author: Goog Tech Date: 2020-08-27 16:45:10 LastEditTime: 2020-08-27 16:46:44 Description: https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/ FilePath: \\leetcode-googtech\\#442. Find All Duplicates in an Array\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 原地修改法 def findDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" # 初始化结果列表 result = [] # 遍历数组 for i in nums: # 获取当前元素的绝对值 num = abs(i) # 将当前元素 num 减一作为数组的下标值,获取 num 数组中对应的元素值,然后取其负 nums[num - 1] *= -1 # 若获取的元素值为正,则说明获取的元素出现了两次,进而将其存储到结果列表中 if nums[num - 1] > 0: result.append(num) # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/448.找到所有数组中消失的数字/448.找到所有数组中消失的数字.html":{"url":"LeetCode刷题之旅及题目解析/448.找到所有数组中消失的数字/448.找到所有数组中消失的数字.html","title":"448.找到所有数组中消失的数字","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 448. 找到所有数组中消失的数字 Java Python 448. 找到所有数组中消失的数字 https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-26 14:12:44 * @LastEditTime: 2020-08-26 14:13:07 * @Description: https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/ * @FilePath: \\leetcode-googtech\\#448. Find All Numbers Disappeared in an Array\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 原地修改法 public List findDisappearedNumbers(int[] nums) { // 初始化结果列表 List result = new ArrayList<>(); // 遍历数组,将 nums[i] - 1 索引位置的元素标记为负数 for(int i = 0; i 0) nums[index] = nums[index] * -1; } // 再次遍历数组,若当前数组元素 nums[i] 为负数,则说明在数组中存在数字: i + 1 // 反之则说明数组中缺失的数字为: i + 1 for(int i = 0; i 0) result.add(i + 1); } // 返回结果列表 return result; } } Python ''' Author: Goog Tech Date: 2020-08-26 14:12:49 LastEditTime: 2020-08-26 14:13:28 Description: https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/ FilePath: \\leetcode-googtech\\#448. Find All Numbers Disappeared in an Array\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 原地修改法 def findDisappearedNumbers(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" # 初始化结果列表 result = [] # 循环遍历数组元素 for i in range(len(nums)): # 将 nums[i] - 1 索引位置的元素标记为负数 # 先获取当前元素的绝对值,然后 -1 进而将当前元素转换为 nums 数组的索引值 newIndex = abs(nums[i]) - 1 # 若该索引值在数组 nums 中存在,则将其所指的元素变为负数 if nums[newIndex] > 0: nums[newIndex] *= -1 # 再次遍历数组,若当前数组元素 nums[i] 为负数,则说明在数组中存在数字: i + 1 # 反之则说明数组中缺失的数字为: i + 1 for i in range(0, len(nums)): # 将缺失的数字添加到结果列表中 if nums[i] > 0: result.append(i + 1) # 返回结果列表 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/453.最小移动次数使数组元素相等/453.最小移动次数使数组元素相等.html":{"url":"LeetCode刷题之旅及题目解析/453.最小移动次数使数组元素相等/453.最小移动次数使数组元素相等.html","title":"453.最小移动次数使数组元素相等","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 453. 最小移动次数使数组元素相等 Java Python 453. 最小移动次数使数组元素相等 https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/ Java /* * @Author: Goog Tech * @Date: 2020-08-27 18:08:49 * @LastEditTime: 2020-08-27 18:09:12 * @Description: https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/ * @FilePath: \\leetcode-googtech\\#453. Minimum Moves to Equal Array Elements\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 解题思路: 每次 n - 1 个数同时加一等同于每次有一个数自身减一, // 进而每个元素减去最小值的和就是答案,最后数组中的元素都为最小值 public int minMoves(int[] nums) { int sum = 0; int minNum = nums[0]; for(int i = 0; i nums[i]) { minNum = nums[i]; } } for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-27 18:08:53 LastEditTime: 2020-08-27 18:09:33 Description: https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/ FilePath: \\leetcode-googtech\\#453. Minimum Moves to Equal Array Elements\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 解题思路: 每次 n - 1 个数同时加一等同于每次有一个数自身减一, # 进而每个元素减去最小值的和就是答案,最后数组中的元素都为最小值 def minMoves(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" sum = 0 minNum = min(nums) for i in nums: sum += i - minNum return sum Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/459.重复的子字符串/459.重复的子字符串.html":{"url":"LeetCode刷题之旅及题目解析/459.重复的子字符串/459.重复的子字符串.html","title":"459.重复的子字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 459. 重复的子字符串 Java Python @lc app=leetcode.cn id=459 lang=python [459] 重复的子字符串 @lc code=start 459. 重复的子字符串 https://leetcode-cn.com/problems/repeated-substring-pattern/ Java /* * @Author: Goog Tech * @Date: 2020-08-24 09:24:57 * @LastEditTime: 2020-08-24 09:34:33 * @Description: https://leetcode-cn.com/problems/repeated-substring-pattern/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\459.重复的子字符串.java * @Reference: https://leetcode-cn.com/problems/repeated-substring-pattern/solution/jian-dan-ming-liao-guan-yu-javaliang-xing-dai-ma-s/ * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=459 lang=java * * [459] 重复的子字符串 */ // @lc code=start class Solution { // 解题思路: 判断str中去除首尾元素后是否包含自身元素,如果包含,则表明存在重复子串 public boolean repeatedSubstringPattern(String s) { String str = s + s; return str.substring(1, str.length() - 1).contains(s); } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-24 09:33:28 LastEditTime: 2020-08-24 09:34:25 Description: https://leetcode-cn.com/problems/repeated-substring-pattern/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\459.重复的子字符串.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=459 lang=python # # [459] 重复的子字符串 # # @lc code=start class Solution(object): # 解题思路: 判断str中去除首尾元素后是否包含自身元素,如果包含,则表明存在重复子串 def repeatedSubstringPattern(self, s): \"\"\" :type s: str :rtype: bool \"\"\" return (s + s)[1 : len(s) * 2 - 1].find(s) != -1 # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/461.汉明距离/461.汉明距离.html":{"url":"LeetCode刷题之旅及题目解析/461.汉明距离/461.汉明距离.html","title":"461.汉明距离","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 461. 汉明距离 Java Python 461. 汉明距离 https://leetcode-cn.com/problems/hamming-distance/ Java /* * @Author: Goog Tech * @Date: 2020-10-27 11:45:11 * @LastEditTime: 2020-10-27 11:46:35 * @Description: https://leetcode-cn.com/problems/hamming-distance/ * @FilePath: \\leetcode-googtech\\#461. Hamming Distance\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 使用内置函数 // public int hammingDistance(int x, int y) { // return Integer.bitCount(x ^ y); // } // 异或运算 + 与运算判断 + 位移 // 两个数的汉明距离就是这两个数进行异或运算,然后统计结果 x 的二进制中 1 的个数 public int hammingDistance(int x, int y) { int result = x ^ y; int count = 0; while(result != 0) { if((result & 1) == 1) count++; result = result >> 1; } return count; } } Python ''' Author: Goog Tech Date: 2020-10-27 11:45:17 LastEditTime: 2020-10-27 11:46:46 Description: https://leetcode-cn.com/problems/hamming-distance/ FilePath: \\leetcode-googtech\\#461. Hamming Distance\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # # 使用内置函数 # def hammingDistance(self, x, y): # \"\"\" # :type x: int # :type y: int # :rtype: int # \"\"\" # return bin(x ^ y).count('1'); # 异或运算 + 与运算判断 + 位移 # 两个数的汉明距离就是这两个数进行异或运算,然后统计结果 x 的二进制中 1 的个数 def hammingDistance(self, x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" result, count = x ^ y, 0 while result: result &= (result - 1) count += 1 return count Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/485.最大连续1的个数/485.最大连续1的个数.html":{"url":"LeetCode刷题之旅及题目解析/485.最大连续1的个数/485.最大连续1的个数.html","title":"485.最大连续1的个数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 485. 最大连续1的个数 Video Java Python 485. 最大连续1的个数 https://leetcode-cn.com/problems/max-consecutive-ones/ Video Java /* * @Author: Goog Tech * @Date: 2020-07-24 16:51:42 * @Description: https://leetcode-cn.com/problems/max-consecutive-ones/ * @FilePath: \\leetcode-googtech\\#485. Max Consecutive Ones\\Solution.java */ class Solution { public int findMaxConsecutiveOnes(int[] nums) { // 初始化变量 int result = 0,count = 0; // 遍历数组中的元素 for(int i = 0;i result ? count : result; } // 返回结果 return result; } } Python ''' @Author: Goog Tech @Date: 2020-07-24 16:51:47 @Description: https://leetcode-cn.com/problems/max-consecutive-ones/ @FilePath: \\leetcode-googtech\\#485. Max Consecutive Ones\\Solution.py ''' class Solution(object): def findMaxConsecutiveOnes(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # 初始化变量 result = count = 0; # 遍历数组中的元素 for num in nums: # 统计数组中连续相同元素的个数 count = count+1 if num == 1 else 0; # 若count为0则表示数组中无连续相同的元素 result = count if count > result else result # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/492.构造矩形/492.构造矩形.html":{"url":"LeetCode刷题之旅及题目解析/492.构造矩形/492.构造矩形.html","title":"492.构造矩形","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 492. 构造矩形 Java Python 492. 构造矩形 https://leetcode-cn.com/problems/construct-the-rectangle/ Java /* * @Author: Goog Tech * @Date: 2020-08-28 06:58:43 * @LastEditTime: 2020-08-28 06:59:05 * @Description: https://leetcode-cn.com/problems/construct-the-rectangle/ * @FilePath: \\leetcode-googtech\\#492. Construct the Rectangle\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public int[] constructRectangle(int area) { // 取面积 area 的平方根 int sqrt = (int)Math.sqrt(area); // 初始化双指针,即宽度与长度 int width = sqrt, length = sqrt; // 通过移动双指针实现循环遍历 while(width = W) }else { width--; } } // 无果 return new int[]{0, 0}; } } Python ''' Author: Goog Tech Date: 2020-08-28 06:58:52 LastEditTime: 2020-08-28 06:59:29 Description: https://leetcode-cn.com/problems/construct-the-rectangle/ FilePath: \\leetcode-googtech\\#492. Construct the Rectangle\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 双指针法 def constructRectangle(self, area): \"\"\" :type area: int :rtype: List[int] \"\"\" # 取面积 area 的平方根 sqrt = math.sqrt(area) # 将 sqrt 由浮点型转换为整型 intSqrt = int(sqrt) # 初始化双指针,即长度与宽度 length, width = intSqrt, intSqrt # 通过移动双指针实现循环遍历 while width = W) else: width -= 1 # 无果 return [0, 0] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/496.下一个更大元素I/496.下一个更大元素I.html":{"url":"LeetCode刷题之旅及题目解析/496.下一个更大元素I/496.下一个更大元素I.html","title":"496.下一个更大元素I","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 496. 下一个更大元素 I Java Python 496. 下一个更大元素 I https://leetcode-cn.com/problems/next-greater-element-i/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 11:57:12 * @LastEditTime: 2020-09-01 11:57:31 * @Description: https://leetcode-cn.com/problems/next-greater-element-i/ * @FilePath: \\leetcode-googtech\\#496. Next Greater Element I\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 解题思路: 先遍历 nums2 中的每一个元素,找出其下一个更大的元素, // 随后对于将这些答案放入哈希映射中,最后再遍历数组 nums1 直接找出答案 public int[] nextGreaterElement(int[] nums1, int[] nums2) { // 初始化辅助栈,其用于存储 nums2 数组中每个元素的右边第一个更大的元素值 Stack stack = new Stack<>(); // 初始化 HashMap,其中 nums2 数组中的元素作为 key,其对应的右边第一个更大的元素作为 value HashMap map = new HashMap<>(); // 根据 nums1 数组的长度初始化结果数组 int[] result = new int[nums1.length]; // 逐个遍历 nums2 数组中的元素 for(int i = 0; i stack.peek()) { // 若满足条件,则将栈顶元素弹出并将其作为 key,当前元素作为 value 存储到 HashMap 中 map.put(stack.pop(), nums2[i]); } // 反之则说明当前元素在 nums2 数组中并不是栈顶元素右边第一个更大的元素,进而将其压入栈中 stack.push(nums2[i]); } // 若遍历完毕后栈为空,则说明栈中的元素在 nums2 数组中并无右边第一个更大的元素, // 进而通过循环弹出栈顶元素,并将其作为 key, -1 作为 value 存储到 HashMap 中 while(!stack.isEmpty()) { map.put(stack.pop(), -1); } // 逐个遍历 nums1 数组中的元素,并通过将其作为 key 来获取 HashMap 中对应的 value,即对应的右边第一个更大的元素值 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-01 11:57:17 LastEditTime: 2020-09-01 11:58:02 Description: https://leetcode-cn.com/problems/next-greater-element-i/ FilePath: \\leetcode-googtech\\#496. Next Greater Element I\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 解题思路: 先遍历 nums2 中的每一个元素,找出其下一个更大的元素, # 随后对于将这些答案放入哈希映射中,最后再遍历数组 nums1 直接找出答案 def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" # 初始化辅助栈,其用于存储 nums2 数组中每个元素的右边第一个更大的元素值 # 初始化 HashMap,其中 nums2 数组中的元素作为 key,其对应的右边第一个更大的元素作为 value stack, hashSet = [], {} # 逐个遍历 nums2 数组中的元素 for num in nums2: # 判断栈是否为空,并且当前元素是否大于栈顶元素 while stack and stack[-1] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/503.下一个更大元素II/503.下一个更大元素II.html":{"url":"LeetCode刷题之旅及题目解析/503.下一个更大元素II/503.下一个更大元素II.html","title":"503.下一个更大元素II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 503. 下一个更大元素 II Java Python 503. 下一个更大元素 II https://leetcode-cn.com/problems/next-greater-element-ii/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 16:15:09 * @LastEditTime: 2020-09-01 16:17:01 * @Description: https://leetcode-cn.com/problems/next-greater-element-ii/ * @FilePath: \\leetcode-googtech\\#503. Next Greater Element II\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 解题思路: 首先需要解决的问题是如何实现循环数组,即 “最后一个元素的下一个元素是数组的第一个元素”. // 事实上,我们只要能遍历两遍数组,效果就等同于循环. // 虽然创建一个长度为原数组二倍的数组也可以,但为了额外空间尽可能少, // 这里采用取模的方式,将索引限制在小于数组长度的正整数范围内. public int[] nextGreaterElements(int[] nums) { // 获取数组的长度 int numsLength = nums.length; // 初始化辅助栈,栈顶至栈底由小到大 Stack stack = new Stack<>(); // 根据 nums 数组的长度初始化结果数组 int[] result = new int[nums.length]; // 逐个遍历并初始化数组元素 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-01 16:15:14 LastEditTime: 2020-09-01 16:18:00 Description: https://leetcode-cn.com/problems/next-greater-element-ii/ FilePath: \\leetcode-googtech\\#503. Next Greater Element II\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 解题思路: 首先需要解决的问题是如何实现循环数组,即 “最后一个元素的下一个元素是数组的第一个元素”. # 事实上,我们只要能遍历两遍数组,效果就等同于循环. # 虽然创建一个长度为原数组二倍的数组也可以,但为了额外空间尽可能少, # 这里采用取模的方式,将索引限制在小于数组长度的正整数范围内. def nextGreaterElements(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" # 判断数组是否为空 if not nums: return [] # 获取数组的长度 numsLength = len(nums) # 逐个遍历并初始化数组元素 result = [-1] * numsLength # 初始化辅助栈,栈顶至栈底由小到大 stack = [] # 逐个遍历数组元素,采用取模的方式将索引限制在小于数组长度的正整数范围内 for i in range(2 * len(nums)): # 例如 numsLength 为 5, 则 index 的取值为 0,1,2,3,4,0,1,2,3,4 即遍历两遍数组,效果就等同于循环 index = i % numsLength # 判断栈是否为空,并且当前元素是否大于栈顶元素 while stack and nums[stack[-1]] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/513.找树左下角的值/513.找树左下角的值.html":{"url":"LeetCode刷题之旅及题目解析/513.找树左下角的值/513.找树左下角的值.html","title":"513.找树左下角的值","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 513. 找树左下角的值 Java Python 513. 找树左下角的值 https://leetcode-cn.com/problems/find-bottom-left-tree-value/ Java /* * @Author: Goog Tech * @Date: 2020-09-14 17:56:04 * @LastEditTime: 2020-09-14 17:56:39 * @Description: https://leetcode-cn.com/problems/find-bottom-left-tree-value/ * @FilePath: \\leetcode-googtech\\#513. Find Bottom Left Tree Value\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // BFS : 广度优先遍历 // 解题思路 : 通常 BFS 遍历都是从上到下,从左到右, // 然而根据题目要求,故采用先上后下,先右后左的遍历策略, // 进而最后一个元素必然是最下方最左边的元素,最后将该节点的值 node.val 返回即可. public int findBottomLeftValue(TreeNode root) { Queue queue = new LinkedList<>(); queue.offer(root); while(!queue.isEmpty()) { root = queue.poll(); if(root.right != null) queue.offer(root.right); if(root.left != null) queue.offer(root.left); } return root.val; } } Python ''' Author: Goog Tech Date: 2020-09-14 17:56:15 LastEditTime: 2020-09-14 17:57:04 Description: https://leetcode-cn.com/problems/find-bottom-left-tree-value/ FilePath: \\leetcode-googtech\\#513. Find Bottom Left Tree Value\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # BFS : 广度优先遍历 # 解题思路 : 通常 BFS 遍历都是从上到下,从左到右, # 然而根据题目要求,故采用先上后下,先右后左的遍历策略, # 进而最后一个元素必然是最下方最左边的元素,最后将该节点的值 node.val 返回即可. def findBottomLeftValue(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" queue = [root] while queue: node = queue.pop(0) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return node.val Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/515.在每个树行中找最大值/515.在每个树行中找最大值.html":{"url":"LeetCode刷题之旅及题目解析/515.在每个树行中找最大值/515.在每个树行中找最大值.html","title":"515.在每个树行中找最大值","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 515. 在每个树行中找最大值 Java Python 515. 在每个树行中找最大值 https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/ Java /* * @Author: Goog Tech * @Date: 2020-09-15 11:16:43 * @LastEditTime: 2020-09-15 11:17:26 * @Description: https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/ * @FilePath: \\leetcode-googtech\\#515. Find Largest Value in Each Tree Row\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { // BFS : 深度优先遍历 public List largestValues(TreeNode root) { // 初始化辅助队列及结果列表 Queue queue = new LinkedList<>(); List values = new ArrayList<>(); // 若二叉树不为空则将根节点入队 if(root != null) queue.add(root); // 循环遍历队列 while(!queue.isEmpty()) { // 初始化最小节点值 int max = Integer.MIN_VALUE; // 获取二叉树中当前层的节点数 int levelSize = queue.size(); // 遍历队列中的元素 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-15 11:16:47 LastEditTime: 2020-09-15 11:17:16 Description: https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/ FilePath: \\leetcode-googtech\\#515. Find Largest Value in Each Tree Row\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): # BFS : 深度优先遍历 def largestValues(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" # 判断根节点是否为空 if not root: return [] # 初始化结果列表 result = [] # 初始化模拟队列 queue = [root] # 循环遍历队列 while queue: # 初始化最小节点值 maxValue = float('-inf') # 遍历队列元素 for _ in range(len(queue)): # 将队列中第一元素出队 node = queue.pop(0) # 通过逐一比较,获取二叉树当前层中最大节点值 maxValue = max(maxValue, node.val) # 将当前出队节点的左右孩子节点入队 if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 将当前层中最大节点值添加到结果列表中 result.append(maxValue) # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/520.检测大写字母/520.检测大写字母.html":{"url":"LeetCode刷题之旅及题目解析/520.检测大写字母/520.检测大写字母.html","title":"520.检测大写字母","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 520. 检测大写字母 Java Python 520. 检测大写字母 https://leetcode-cn.com/problems/detect-capital/ Java /* * @Author: Goog Tech * @Date: 2020-07-24 18:35:09 * @Description: https://leetcode-cn.com/problems/detect-capital/ * @FilePath: \\leetcode-googtech\\#520. Detect Capital\\Solution.java */ class Solution { public boolean detectCapitalUse(String word) { char[] ch = word.toCharArray(); int upper = 0,lower = 0; // 通过比较ASCII的大小来统计字符串中大小写字符的所占的个数 for(int i = 0;i ='a') lower++; else upper++; } // GOOGLE || google || Google return upper==ch.alength || lower==ch.length || (upper==1 && ch[0] Python ''' @Author: Goog Tech @Date: 2020-07-24 18:18:31 @Description: https://leetcode-cn.com/problems/detect-capital/ @FilePath: \\leetcode-googtech\\#520. Detect Capital\\Solution.py ''' class Solution(object): def detectCapitalUse(self, word): \"\"\" :type word: str :rtype: bool \"\"\" # istitle():检测字符串中所有的单词拼写首字母是否为大写 # return word.islower() or word.isupper() or word.istitle() lower = upper = 0 strLength = len(word) # 通过比较ASCII的大小来统计字符串中大小写字符的个数 for i in range(0,strLength): if word[i] >= 'a': lower = lower+1 else: upper = upper+1 # google or GOOGLE or Google return lower == strLength or upper == strLength or (upper==1 and word[0] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/521.最长特殊序列Ⅰ/521.最长特殊序列Ⅰ.html":{"url":"LeetCode刷题之旅及题目解析/521.最长特殊序列Ⅰ/521.最长特殊序列Ⅰ.html","title":"521.最长特殊序列Ⅰ","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 521. 最长特殊序列Ⅰ Java Python 521. 最长特殊序列Ⅰ https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/ Java /* * @Author: Goog Tech * @Date: 2020-08-25 10:08:18 * @LastEditTime: 2020-08-25 10:08:38 * @Description: https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/ * @FilePath: \\leetcode-googtech\\#521. Longest Uncommon Subsequence I\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { /* * 解题思路如下: * 1. 若字符串 a 与 b 相等则说明没有特殊子序列,返回 -1 即可 * 2. 若字符串 a 与 b 的长度不同等则说明长的字符串一定不会是短字符串的子序列,因此可以将长字符串看作是特殊子序列 * 3. 若字符串 a 与 b 的长度相等则说明其中一个字符串不会是另一个字符串的子序列,因此可以将任意一个字符串看作特殊子序列 */ public int findLUSlength(String a, String b) { return a.equals(b) ? -1 : a.length() > b.length() ? a.length() : b.length(); } } Python ''' Author: Goog Tech Date: 2020-08-25 10:08:25 LastEditTime: 2020-08-25 10:09:40 Description: https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/ FilePath: \\leetcode-googtech\\#521. Longest Uncommon Subsequence I\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def findLUSlength(self, a, b): \"\"\" :type a: str :type b: str :rtype: int \"\"\" ''' 解题思路如下: 1. 若字符串 a 与 b 相等则说明没有特殊子序列,返回 -1 即可 2. 若字符串 a 与 b 的长度不同等则说明长的字符串一定不会是短字符串的子序列,因此可以将长字符串看作是特殊子序列 3. 若字符串 a 与 b 的长度相等则说明其中一个字符串不会是另一个字符串的子序列,因此可以将任意一个字符串看作特殊子序列 ''' return -1 if a == b else len(a) if len(a) > len(b) else len(b); Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/530.二叉搜索树的最小绝对差/530.二叉搜索树的最小绝对差.html":{"url":"LeetCode刷题之旅及题目解析/530.二叉搜索树的最小绝对差/530.二叉搜索树的最小绝对差.html","title":"530.二叉搜索树的最小绝对差","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 530. 二叉搜索树的最小绝对差 Java Python 530. 二叉搜索树的最小绝对差 https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ Java /* * @Author: Goog Tech * @Date: 2020-09-10 20:05:49 * @LastEditTime: 2020-09-10 20:07:17 * @Description: https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ * @FilePath: \\leetcode-googtech\\#530. Minimum Absolute Difference in BST\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ // 中序遍历: 根据搜索二叉树的特性,中序遍历会将树中节点数值从小到大顺序输出,所以 root.val > pre.val // 进而只需要遍历计算相邻数值的差值,取其中最小值即可. class Solution { private TreeNode pre = null; private int minDiff = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { if(root == null) return -1; inOrder(root); return minDiff; } private void inOrder(TreeNode root) { if(root == null) return; inOrder(root.left); if(pre != null) minDiff = Math.min(minDiff, root.val - pre.val); // if(pre != null) minDiff = Math.min(minDiff, Math.abs(pre.val - root.val)); pre = root; inOrder(root.right); } } Python ''' Author: Goog Tech Date: 2020-09-10 20:05:58 LastEditTime: 2020-09-10 20:06:38 Description: https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ FilePath: \\leetcode-googtech\\#530. Minimum Absolute Difference in BST\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def getMinimumDifference(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(node): if node: dfs(node.left) # 利用搜索二叉树的特性,即中序遍历会将树中节点数值从小到大顺序输出,所以 node.val > prev.val # 进而只需要遍历计算相邻数的差值,取其中最小值即可. # self.result = min(self.result, node.val - self.prev) self.result = min(self.result, abs(self.prev - node.val)) self.prev = node.val dfs(node.right) # Python 用如下的方式表示正负无穷,即规定所有的数都比 -inf 大,所有的小都比 inf 小 self.prev = float('-inf') self.result = float('inf') dfs(root) return self.result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/532.数组中的K-diff数对/532.数组中的K-diff数对.html":{"url":"LeetCode刷题之旅及题目解析/532.数组中的K-diff数对/532.数组中的K-diff数对.html","title":"532.数组中的K-diff数对","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 532. 数组中的K-diff数对 Java Python 532. 数组中的K-diff数对 https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 20:26:55 * @LastEditTime: 2020-08-30 20:27:05 * @Description: https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/ * @FilePath: \\leetcode-googtech\\#532. K-diff Pairs in an Array\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public int findPairs(int[] nums, int k) { // 初始化用于存储 k-diff数对 之和的 HashSet 集合 HashSet set = new HashSet<>(); // 通过移动双指针 i 与 其后指针 j 来遍历数组元素 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-30 20:27:00 LastEditTime: 2020-08-30 20:28:18 Description: https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/ FilePath: \\leetcode-googtech\\#532. K-diff Pairs in an Array\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def findPairs(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" ''' 待解. . . ''' Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/538.把二叉搜索树转换为累加树/538.把二叉搜索树转换为累加树.html":{"url":"LeetCode刷题之旅及题目解析/538.把二叉搜索树转换为累加树/538.把二叉搜索树转换为累加树.html","title":"538.把二叉搜索树转换为累加树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 538. 把二叉搜索树转换为累加树 Java Python @lc app=leetcode.cn id=538 lang=python [538] 把二叉搜索树转换为累加树 @lc code=start 538. 把二叉搜索树转换为累加树 https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 12:23:26 * @LastEditTime: 2020-08-16 12:30:19 * @Description: https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ * @FilePath: \\leetcode-googtech\\#538. Convert BST to Greater Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=538 lang=java * * [538] 把二叉搜索树转换为累加树 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int sum = 0; // 利用反序中序遍历解题,注: 二叉搜索树的左子树 Python ''' Author: Goog Tech Date: 2020-08-16 12:10:39 LastEditTime: 2020-08-16 12:30:38 Description: https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ FilePath: \\leetcode-googtech\\#538. Convert BST to Greater Tree\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=538 lang=python # # [538] 把二叉搜索树转换为累加树 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def __init__(self): self.total = 0 # 利用反序中序遍历解题,注: 二叉搜索树的左子树 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/543.二叉树的直径/543.二叉树的直径.html":{"url":"LeetCode刷题之旅及题目解析/543.二叉树的直径/543.二叉树的直径.html","title":"543.二叉树的直径","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 543. 二叉树的直径 Java Python 543. 二叉树的直径 https://leetcode-cn.com/problems/diameter-of-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-10-27 13:34:28 * @LastEditTime: 2020-10-27 13:35:13 * @Description: https://leetcode-cn.com/problems/diameter-of-binary-tree/ * @FilePath: \\leetcode-googtech\\#543. Diameter of Binary Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 一条路径的长度为该路径经过的节点数减一, // 所以求直径(即求路径长度的最大值)等效于求路径经过节点数的最大值减一 private int max = 0; // root的直径 = root左子树高度 + root右子树高度 // root的高度 = max {root左子树高度, root右子树高度} + 1 // 二叉树的直径不一定过根节点,因此需要去搜一遍所有子树 // ( 例如以root, root.left, root.right..为根节点的树)对应的直径,取最大值 public int diameterOfBinaryTree(TreeNode root) { dfs(root); return max; } // DFS : 深度优先搜索 private int dfs(TreeNode root) { // 判断当前节点是否为空 if(root == null) return 0; // 递归获取左右子树孩子节点的高度 int leftHeight = dfs(root.left), rightHeight = dfs(root.right); // 获取每个节点的最大直径(左子树深度 + 右子树深度),与当前最大值比较并取较大者 max = Math.max(leftHeight + rightHeight, max); // 返回当前节点的深度 return Math.max(leftHeight, rightHeight) + 1; } } Python ''' Author: Goog Tech Date: 2020-10-27 13:34:34 LastEditTime: 2020-10-27 13:37:31 Description: https://leetcode-cn.com/problems/diameter-of-binary-tree/ FilePath: \\leetcode-googtech\\#543. Diameter of Binary Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 注意: 最大的直径不一定是经过根节点的,其可能出现在子树中,那么将此题转换成求每个节点 # 的左右子树最大深度和即可 def diameterOfBinaryTree(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" self.result = 0 # Depth First Search def dfs(node): if not node: return 0 leftHeight, rightHeight = dfs(node.left), dfs(node.right) self.result = max(self.result, leftHeight + rightHeight) return max(leftHeight, rightHeight) + 1 dfs(root) return self.result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/557.反转字符串中的单词III/557.反转字符串中的单词III.html":{"url":"LeetCode刷题之旅及题目解析/557.反转字符串中的单词III/557.反转字符串中的单词III.html","title":"557.反转字符串中的单词III","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 557. 反转字符串中的单词 III Java Python 557. 反转字符串中的单词 III https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 07:28:06 * @LastEditTime: 2020-08-09 07:33:49 * @Description: https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/ * @FilePath: \\leetcode-googtech\\#557. Reverse Words in a String III\\Solution.java */ class Solution { public String reverseWords(String s) { // 去除字符串中的空格并将其转化为字符数组 String[] str = s.split(\" \"); StringBuffer buffer = new StringBuffer(); // 遍历数组中的字符串元素 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-09 07:28:12 LastEditTime: 2020-08-09 07:34:54 Description: https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/ FilePath: \\leetcode-googtech\\#557. Reverse Words in a String III\\Solution.py ''' class Solution(object): def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\" # 将字符串分割成单词列表,然后把每个单词反转切片 return \" \".join(word[::-1] for word in s.split(\" \")) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/559.N叉树的最大深度/559.N叉树的最大深度.html":{"url":"LeetCode刷题之旅及题目解析/559.N叉树的最大深度/559.N叉树的最大深度.html","title":"559.N叉树的最大深度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 559. N叉树的最大深度 Java Python @lc app=leetcode.cn id=559 lang=python [559] N叉树的最大深度 @lc code=start 559. N叉树的最大深度 https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-07-28 21:27:08 * @Description: https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\559.n叉树的最大深度.java */ /* * @lc app=leetcode.cn id=559 lang=java * * [559] N叉树的最大深度 */ // @lc code=start /* // Definition for a Node. class Node { public int val; public List children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List _children) { val = _val; children = _children; } }; */ class Solution { // 递归法 public int maxDepth(Node root) { // 判断根节点是否为空或无孩子节点 if(root == null) return 0; if(root.children == null) return 1; // 初始化最大深度值及当前子树的深度值 int maxDepth = 0, currentDepth = 0; // 遍历当前节点的子节点,即求出当前子树的深度值 for(Node node : root.children) { currentDepth = maxDepth(node); // 判断当前子树的深度是否为最大深度值 maxDepth =currentDepth > maxDepth ? currentDepth : maxDepth; } // 一棵树的最大深度就是子树最大深度加一 return maxDepth + 1; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-28 21:54:41 @Description: https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\559.n叉树的最大深度.py ''' # # @lc app=leetcode.cn id=559 lang=python # # [559] N叉树的最大深度 # # @lc code=start \"\"\" # Definition for a Node. class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children \"\"\" class Solution(object): # 递归法 def maxDepth(self, root): \"\"\" :type root: Node :rtype: int \"\"\" # 判断根节点是否为空或无孩子节点 if not root: return 0 if not root.children: return 1 # 初始化最大深度值及当前子树的深度值 maxDepth = currentDepth = 0 # 遍历当前节点的子节点,即求出当前子树的深度值 for child in root.children: currentDepth = self.maxDepth(child) # 判断当前子树的深度是否为最大深度值 maxDepth = currentDepth if currentDepth > maxDepth else maxDepth # 一棵树的最大深度值就是子树最大深度值加一 return maxDepth + 1 # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/561.数组拆分I/561.数组拆分I.html":{"url":"LeetCode刷题之旅及题目解析/561.数组拆分I/561.数组拆分I.html","title":"561.数组拆分I","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 561. 数组拆分I Java Python 561. 数组拆分I https://leetcode-cn.com/problems/array-partition-i/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 09:49:53 * @LastEditTime: 2020-08-16 09:50:12 * @Description: https://leetcode-cn.com/problems/array-partition-i/ * @FilePath: \\leetcode-googtech\\#561. Array Partition I\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { //其实就是把从a1到an数组下标为奇数的数都加起来 public int arrayPairSum(int[] nums) { Arrays.sort(nums); int sum = 0; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-16 09:49:58 LastEditTime: 2020-08-16 09:51:47 Description: https://leetcode-cn.com/problems/array-partition-i/ FilePath: \\leetcode-googtech\\#561. Array Partition I\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 其实就是把从a1到an数组下标为奇数的数都加起来 def arrayPairSum(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" return sum(sorted(nums)[::2]) # seq[start:end:step] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/589.N叉树的前序遍历/589.N叉树的前序遍历.html":{"url":"LeetCode刷题之旅及题目解析/589.N叉树的前序遍历/589.N叉树的前序遍历.html","title":"589.N叉树的前序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 589. N叉树的前序遍历 Java Python @lc app=leetcode.cn id=589 lang=python [589] N叉树的前序遍历 @lc code=start 589. N叉树的前序遍历 https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-29 11:07:57 * @LastEditTime: 2020-07-29 11:51:42 * @Description: https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/ * @FilePath: \\leetcode-googtech\\#589. N-ary Tree Preorder Traversal\\589.n叉树的前序遍历.java */ /* * @lc app=leetcode.cn id=589 lang=java * * [589] N叉树的前序遍历 */ // @lc code=start /* // Definition for a Node. class Node { public int val; public List children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List _children) { val = _val; children = _children; } }; */ class Solution { /** * 递归法 */ private List result = new ArrayList<>(); public List preorder(Node root) { if(root == null) return new ArrayList(); result.add(root.val); for(Node children : root.children) preorder(children); return result; } /** * 迭代法 */ public List preorder(Node root) { // 判断头节点是否为空 if(root == null) return new ArrayList(); // 初始化辅助栈及结果列表 Stack stack = new Stack<>(); List result = new LinkedList<>(); // 将根节点压入栈中 stack.push(root); // 循环遍历辅助栈 while(!stack.isEmpty()) { // 每次循环将栈顶元素出栈 root = stack.pop(); // 将栈顶元素存储到结果列表中 result.add(root.val); // 然后将栈顶元素的孩子节点从右至左压入栈中(出栈顺序:从左至右) if(!root.children.isEmpty()) { for(int i = root.children.size() - 1; i >= 0; i--) { stack.push(root.children.get(i)); } } } // 返回结果列表 return result; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-29 11:07:27 @LastEditTime: 2020-07-29 11:50:55 @Description: https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/ @FilePath: \\leetcode-googtech\\#589. N-ary Tree Preorder Traversal\\589.n叉树的前序遍历.py ''' # # @lc app=leetcode.cn id=589 lang=python # # [589] N叉树的前序遍历 # # @lc code=start \"\"\" # Definition for a Node. class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children \"\"\" class Solution(object): ''' 递归法 ''' def preorder(self, root): \"\"\" :type root: Node :rtype: List[int] \"\"\" result = [] def dfs(root): if not root: return [] result.append(root.val) for children in root.children: dfs(children) dfs(root) return result ''' 迭代法 ''' def preorder(self, root): # 判断头节点是否为空 if not root: return [] # 初始化辅助栈和结果列表 result, stack = [], [root] # 循环遍历辅助栈 while stack: # 每次循环将栈顶元素出栈 currentNode = stack.pop() # 将栈顶元素存储到结果列表中 result.append(currentNode.val) # 然后将栈顶元素的孩子节点从右至左压入栈中(出栈顺序:从左至右) for children in currentNode.children[::-1]: stack.append(children) # 返回结果列表 return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/590.N叉树的后序遍历/590.N叉树的后序遍历.html":{"url":"LeetCode刷题之旅及题目解析/590.N叉树的后序遍历/590.N叉树的后序遍历.html","title":"590.N叉树的后序遍历","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 590. N叉树的后序遍历 Java Python @lc app=leetcode.cn id=590 lang=python [590] N叉树的后序遍历 @lc code=start 590. N叉树的后序遍历 https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/ Java /* * @Author: Goog Tech * @Date: 2020-07-29 12:49:06 * @LastEditTime: 2020-07-29 15:05:17 * @Description: https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/ * @FilePath: \\leetcode-googtech\\#590. N-ary Tree Postorder Traversal\\590.n叉树的后序遍历.java */ /* * @lc app=leetcode.cn id=590 lang=java * * [590] N叉树的后序遍历 */ // @lc code=start /* // Definition for a Node. class Node { public int val; public List children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List _children) { val = _val; children = _children; } }; */ class Solution { /** * 递归法 */ List result = new ArrayList<>(); public List postorder(Node root) { if(root == null) return new ArrayList<>(); // 递归根节点的左右孩子节点,将其添加到结果队列中 for(Node children : root.children) { postorder(children); } // 将根节点添加到结果队列中 result.add(root.val); // 返回结果队列 return result; } /** * 迭代法: 双端队列 + 辅助栈 */ public List postorder(Node root) { // 判断头节点是否为空 if(root == null) return new ArrayList<>(); // 初始化结果队列(双端队列)及辅助栈 LinkedList result = new LinkedList<>(); Stack stack = new Stack<>(); // 将根节点压入栈中 stack.push(root); // 循环遍历辅助栈 while(!stack.isEmpty()) { // 每次循环将栈顶元素弹出 Node currentNode = stack.pop(); // 将栈顶元素存储到双端队列的头部(存储顺序: 根节点->右节点->左节点) result.addFirst(currentNode.val); // 然后将栈顶元素的孩子节点从左至右顺序入栈(出栈顺序: 从右至左) if(currentNode.children != null) { for(Node children : currentNode.children) { stack.push(children); } } } // 返回结果队列 return result; } /** * 迭代法: 数组队列 + 辅助栈 */ public List postorder(Node root) { // 判断头节点是否为空 if(root == null) return new ArrayList<>(); // 初始化结果队列(数组队列)及辅助栈 List result = new ArrayList<>(); Stack stack = new Stack<>(); // 将根节点压入栈中 stack.push(root); // 循环遍历辅助栈 while(!stack.isEmpty()) { // 每次循环获取并删除栈尾元素 Node currentNode = stack.remove(stack.size() - 1); // 将栈尾元素存储到数组队列中(根节点->右节点->左节点) result.add(currentNode.val); // 然后将栈尾元素的孩子节点从左至右顺序入栈,所以栈尾元素为右节点 if(currentNode.children != null) { for(Node children : currentNode.children) { stack.push(children); } } } // 将结果队列反转并返回 Collections.reverse(result); return result; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-29 12:58:33 @LastEditTime: 2020-07-29 15:09:54 @Description: https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/ @FilePath: \\leetcode-googtech\\#590. N-ary Tree Postorder Traversal\\590.n叉树的后序遍历.py ''' # # @lc app=leetcode.cn id=590 lang=python # # [590] N叉树的后序遍历 # # @lc code=start \"\"\" # Definition for a Node. class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children \"\"\" class Solution(object): ''' 递归法 ''' def postorder(self, root): \"\"\" :type root: Node :rtype: List[int] \"\"\" # 初始化结果列表 result = [] # 递归调用当前节点的孩子节点 def dfs(root): # 判断头节点是否空 if not root: return [] # 递归根节点的左右孩子节点,并将其添加到结果队列中 for children in root.children: dfs(children) # 将根节点添加到结果队列中 result.append(root.val) dfs(root) return result ''' 迭代法: 数组队列 + 辅助栈 ''' def postorder(self, root): # 判断头节点是否为空 if not root: return [] # 初始化结果列表及辅助栈 result, stack = [], [root] # 循环遍历辅助栈 while stack: # 每次循环获取并删除栈尾元素, # pop(): 默认移除列表中的最后一个元素 currentNode = stack.pop() # 将栈尾元素存储到结果列表中(根节点->右节点->左节点) result.append(currentNode.val) # 然后将栈尾元素的孩子节点从左至右顺序入栈,所以出栈尾节点为右节点 if currentNode.children is not None: for children in currentNode.children: stack.append(children) # 将结果列表反转并返回 return result[::-1] # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/595.大的国家/595.大的国家.html":{"url":"LeetCode刷题之旅及题目解析/595.大的国家/595.大的国家.html","title":"595.大的国家","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 595. 大的国家 MySQL SQLServer 595. 大的国家 https://leetcode-cn.com/problems/big-countries/ MySQL # Write your MySQL query statement below SELECT name, population, area FROM world WHERE area > 3000000 or population > 25000000 SQLServer /* Write your T-SQL query statement below */ SELECT name, population, area FROM world WHERE area > 3000000 or population > 25000000 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/596.超过5名学生的课/596.超过5名学生的课.html":{"url":"LeetCode刷题之旅及题目解析/596.超过5名学生的课/596.超过5名学生的课.html","title":"596.超过5名学生的课","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 596. 超过5名学生的课 MySQL 596. 超过5名学生的课 https://leetcode-cn.com/problems/classes-more-than-5-students/ MySQL # Write your MySQL query statement below SELECT class FROM courses GROUP BY class HAVING COUNT(DISTINCT student) >= 5; Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/617.合并二叉树/617.合并二叉树.html":{"url":"LeetCode刷题之旅及题目解析/617.合并二叉树/617.合并二叉树.html","title":"617.合并二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 617. 合并二叉树 Java Python @lc app=leetcode.cn id=617 lang=python [617] 合并二叉树 @lc code=start 617. 合并二叉树 https://leetcode-cn.com/problems/merge-two-binary-trees/ Java /* * @Author: Goog Tech * @Date: 2020-07-29 08:34:34 * @Description: https://leetcode-cn.com/problems/merge-two-binary-trees/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\617.合并二叉树.java */ /* * @lc app=leetcode.cn id=617 lang=java * * [617] 合并二叉树 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 迭代法 public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { // 若其中一棵树为空,则返回另一颗树作为结果 if(t1 == null || t2 == null) return t1 == null ? t2 : t1; // 若两颗树当前节点都不为空,则将它们的值相加,并且对它们的左右孩子节点进行递归合并 t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; } } // @lc code=end Python ''' @Author: Goog Tech @Date: 2020-07-29 09:01:01 @LastEditTime: 2020-07-29 09:12:01 @Description: https://leetcode-cn.com/problems/merge-two-binary-trees/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\617.合并二叉树.py ''' # # @lc app=leetcode.cn id=617 lang=python # # [617] 合并二叉树 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 迭代法 def mergeTrees(self, t1, t2): \"\"\" :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode \"\"\" # 若其中一棵树为空,则返回另一颗树作为结果 if not t1: return t2 if not t2: return t1 # 若两棵树当前节点都不为空,则将它们的值相加,并且对它们的左右孩子节点进行递归合并 t1.val += t2.val t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) return t1 # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/620.有趣的电影/620.有趣的电影.html":{"url":"LeetCode刷题之旅及题目解析/620.有趣的电影/620.有趣的电影.html","title":"620.有趣的电影","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 620. 有趣的电影 MySQL SQLServer 620. 有趣的电影 https://leetcode-cn.com/problems/not-boring-movies/ MySQL # Write your MySQL query statement below SELECT id, movie, description, rating FROM cinema WHERE id & 1 AND description <> 'boring' ORDER BY rating DESC SQLServer /* Write your T-SQL query statement below */ SELECT id, movie, description, rating FROM cinema WHERE id % 2 = 1 AND description NOT LIKE '%boring%' ORDER by 4 DESC Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/622.设计循环队列/622.设计循环队列.html":{"url":"LeetCode刷题之旅及题目解析/622.设计循环队列/622.设计循环队列.html","title":"622.设计循环队列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 622. 设计循环队列 Java Python 622. 设计循环队列 https://leetcode-cn.com/problems/design-circular-queue/ Java /* * @Author: Goog Tech * @Date: 2020-09-07 08:16:03 * @LastEditTime: 2020-09-07 08:16:33 * @Description: https://leetcode-cn.com/problems/design-circular-queue/ * @FilePath: \\leetcode-googtech\\#622. Design Circular Queue\\Solution.java * @WebSite: https://algorithm.show/ */ class MyCircularQueue { private int front; // 指向队头元素 private int rear; // 指向队尾元素的下一个元素 private int capacity; //声明数组容量 private int[] array; // 使用数组实现循环队列 /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { front = 0; rear = 0; capacity = k + 1; array = new int[capacity]; } /** Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) { if(isFull()) return false; array[rear] = value; rear = (rear + 1) % capacity; return true; } /** Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() { if(isEmpty()) return false; front = (front + 1) % capacity; return true; } /** Get the front item from the queue. */ public int Front() { if(isEmpty()) return -1; return array[front]; } /** Get the last item from the queue. */ public int Rear() { if(isEmpty()) return -1; return array[(rear - 1 + capacity) % capacity]; } /** Checks whether the circular queue is empty or not. */ public boolean isEmpty() { return front == rear; } /** Checks whether the circular queue is full or not. */ public boolean isFull() { // 为了避免 “队列为空” 和 “队列为满” 的判别条件冲突,有意浪费一个元素空间 // 即当 rear 循环到数组的前面,要从后面追上 front,还差一格的时判定为队列为满 return (rear + 1) % capacity == front; } } /** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue obj = new MyCircularQueue(k); * boolean param_1 = obj.enQueue(value); * boolean param_2 = obj.deQueue(); * int param_3 = obj.Front(); * int param_4 = obj.Rear(); * boolean param_5 = obj.isEmpty(); * boolean param_6 = obj.isFull(); */ Python ''' Author: Goog Tech Date: 2020-09-07 08:16:08 LastEditTime: 2020-09-07 08:17:10 Description: https://leetcode-cn.com/problems/design-circular-queue/ FilePath: \\leetcode-googtech\\#622. Design Circular Queue\\Solution.py WebSite: https://algorithm.show/ ''' class MyCircularQueue(object): def __init__(self, k): \"\"\" Initialize your data structure here. Set the size of the queue to be k. :type k: int \"\"\" self.front = 0 # 指向队头元素 self.rear = 0 # 指向队尾元素的下一个元素 self.capacity = k + 1 # 声明数组容量 self.array = [0 for _ in range(self.capacity)] # 使用数组实现循环队列 def enQueue(self, value): \"\"\" Insert an element into the circular queue. Return true if the operation is successful. :type value: int :rtype: bool \"\"\" if self.isFull(): return False self.array[self.rear] = value self.rear = (self.rear + 1) % self.capacity; return True; def deQueue(self): \"\"\" Delete an element from the circular queue. Return true if the operation is successful. :rtype: bool \"\"\" if self.isEmpty(): return False self.front = (self.front + 1) % self.capacity return True def Front(self): \"\"\" Get the front item from the queue. :rtype: int \"\"\" if self.isEmpty(): return -1 return self.array[self.front] def Rear(self): \"\"\" Get the last item from the queue. :rtype: int \"\"\" if self.isEmpty(): return -1 return self.array[(self.rear - 1 + self.capacity) % self.capacity] def isEmpty(self): \"\"\" Checks whether the circular queue is empty or not. :rtype: bool \"\"\" return self.front == self.rear def isFull(self): \"\"\" Checks whether the circular queue is full or not. :rtype: bool \"\"\" # 为了避免 “队列为空” 和 “队列未满” 的判别条件冲突,有意浪费一个元素空间 # 即当 rear 循环到数组的前面,要从后面追上 front,还差一格的时候判定为队列为满 return (self.rear + 1) % self.capacity == self.front # Your MyCircularQueue object will be instantiated and called as such: # obj = MyCircularQueue(k) # param_1 = obj.enQueue(value) # param_2 = obj.deQueue() # param_3 = obj.Front() # param_4 = obj.Rear() # param_5 = obj.isEmpty() # param_6 = obj.isFull() Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/627.交换工资/627.交换工资.html":{"url":"LeetCode刷题之旅及题目解析/627.交换工资/627.交换工资.html","title":"627.交换工资","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 627. 交换工资 MySQL SQLServer 627. 交换工资 https://leetcode-cn.com/problems/swap-salary/ MySQL # Write your MySQL query statement below # 使用 UPDATE 和 CASE...WHEN 语句 UPDATE salary SET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END; SQLServer /* Write your T-SQL query statement below */ /* 使用 UPDATE 和 CASE...WHEN 语句 */ update salary set sex = case sex when 'm' then 'f' else 'm' end; Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/628.三个数的最大乘积/628.三个数的最大乘积.html":{"url":"LeetCode刷题之旅及题目解析/628.三个数的最大乘积/628.三个数的最大乘积.html","title":"628.三个数的最大乘积","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 628. 三个数的最大乘积 Java Python 628. 三个数的最大乘积 https://leetcode-cn.com/problems/maximum-product-of-three-numbers/ Java /* * @Author: Goog Tech * @Date: 2020-07-25 12:26:56 * @Description: https://leetcode-cn.com/problems/maximum-product-of-three-numbers/ * @FilePath: \\leetcode-googtech\\#628. Maximum Product of Three Numbers\\Solution.java */ class Solution { public int maximumProduct(int[] nums) { // 初始化第一,第二以及第三大元素 int firstMax = Integer.MIN_VALUE, secondMax = Integer.MIN_VALUE,thirdMax = Integer.MIN_VALUE; // 初始化第一,第二以及第三小元素 int firstMin = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE; // 遍历数组 for(int num : nums) { // 获取第一,第二以及第三大元素 if(num > firstMax) { thirdMax = secondMax; secondMax = firstMax; firstMax = num; }else if(num > secondMax) { thirdMax = secondMax; secondMax = num; }else if(num > thirdMax) { thirdMax = num; } // 获取第一,第二小元素 if(num Python ''' @Author: Goog Tech @Date: 2020-07-25 12:27:03 @Description: https://leetcode-cn.com/problems/maximum-product-of-three-numbers/ @FilePath: \\leetcode-googtech\\#628. Maximum Product of Three Numbers\\Solution.py ''' class Solution(object): def maximumProduct(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # 初始化第一、第二、第三大元素以及第一、第二小元素 # -sys.maxsize = -9223372036854775807 firstMax = secondMax = thirdMax = -sys.maxsize firstMin = secondMin = sys.maxsize # 遍历数组 for num in nums: # 获取第一,第二以及第三大元素 if num > firstMax: thirdMax, secondMax, firstMax = secondMax, firstMax, num elif num > secondMax: thirdMax, secondMax = secondMax, num elif num > thirdMax: thirdMax = num # 获取第一,第二小元素 if num Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/641.设计循环双端队列/641.设计循环双端队列.html":{"url":"LeetCode刷题之旅及题目解析/641.设计循环双端队列/641.设计循环双端队列.html","title":"641.设计循环双端队列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 641. 设计循环双端队列 Java Python 641. 设计循环双端队列 https://leetcode-cn.com/problems/design-circular-deque/ Java /* * @Author: Goog Tech * @Date: 2020-09-06 22:26:24 * @LastEditTime: 2020-09-06 22:27:19 * @Description: https://leetcode-cn.com/problems/design-circular-deque/ * @FilePath: \\leetcode-googtech\\#641. Design Circular Deque\\Solution.java * @WebSite: https://algorithm.show/ */ class MyCircularDeque { private int[] elements; // int是基础数据类型,初始值是 0,它对应的有一种引用类型叫做 Integer 类,没初始化时是 null private int size; /** Initialize your data structure here. Set the size of the deque to be k. */ public MyCircularDeque(int k) { elements = new int[k]; } /** Adds an item at the front of Deque. Return true if the operation is successful. */ public boolean insertFront(int value) { if(isFull()) return false; for(int i = size - 1; i >= 0; i--) elements[i + 1] = elements[i]; elements[0] = value; size++; return true; } /** Adds an item at the rear of Deque. Return true if the operation is successful. */ public boolean insertLast(int value) { if(isFull()) return false; elements[size] = value; size++; return true; } /** Deletes an item from the front of Deque. Return true if the operation is successful. */ public boolean deleteFront() { if(isEmpty()) return false; elements[0] = 0; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-06 22:26:27 LastEditTime: 2020-09-06 22:29:32 Description: https://leetcode-cn.com/problems/design-circular-deque/ FilePath: \\leetcode-googtech\\#641. Design Circular Deque\\Solution.py WebSite: https://algorithm.show/ ''' class MyCircularDeque(object): def __init__(self, k): \"\"\" Initialize your data structure here. Set the size of the deque to be k. :type k: int \"\"\" self.queue = [] self.size = k def insertFront(self, value): \"\"\" Adds an item at the front of Deque. Return true if the operation is successful. :type value: int :rtype: bool \"\"\" if not self.isFull(): self.queue.insert(0, value) return True else: return False def insertLast(self, value): \"\"\" Adds an item at the rear of Deque. Return true if the operation is successful. :type value: int 44`:rtype: bool \"\"\" if not self.isFull(): self.queue.append(value) return True else: return False def deleteFront(self): \"\"\" Deletes an item from the front of Deque. Return true if the operation is successful. :rtype: bool \"\"\" if not self.isEmpty(): self.queue.pop(0) return True else: return False def deleteLast(self): \"\"\" Deletes an item from the rear of Deque. Return true if the operation is successful. :rtype: bool \"\"\" if not self.isEmpty(): self.queue.pop() return True else: return False def getFront(self): \"\"\" Get the front item from the deque. :rtype: int \"\"\" if self.isEmpty(): return -1 else: return self.queue[0] def getRear(self): \"\"\" Get the last item from the deque. :rtype: int \"\"\" if self.isEmpty(): return -1 else: return self.queue[-1] def isEmpty(self): \"\"\" :rtype: bool Checks whether the circular deque is empty or not. \"\"\" return len(self.queue) == 0 def isFull(self): \"\"\" Checks whether the circular deque is full or not. :rtype: bool \"\"\" return len(self.queue) == self.size # Your MyCircularDeque object will be instantiated and called as such: # obj = MyCircularDeque(k) # param_1 = obj.insertFront(value) # param_2 = obj.insertLast(value) # param_3 = obj.deleteFront() # param_4 = obj.deleteLast() # param_5 = obj.getFront() # param_6 = obj.getRear() # param_7 = obj.isEmpty() # param_8 = obj.isFull() Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/645.错误的集合/645.错误的集合.html":{"url":"LeetCode刷题之旅及题目解析/645.错误的集合/645.错误的集合.html","title":"645.错误的集合","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 645. 错误的集合 Java Python 645. 错误的集合 https://leetcode-cn.com/problems/set-mismatch/ Java /* * @Author: Goog Tech * @Date: 2020-08-26 13:00:38 * @LastEditTime: 2020-08-26 13:04:46 * @Description: https://leetcode-cn.com/problems/set-mismatch/ * @FilePath: \\leetcode-googtech\\#645. Set Mismatch\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 使用额外数组法 public int[] findErrorNums(int[] nums) { // 初始化计数数组 int[] counter = new int[nums.length + 1]; // 遍历 nums 数组,将其元素值作为 counter 数组的索引值,而将每个元素出现的次数作为其元素值 for(int num : nums) counter[num]++; // 初始化结果数组 int[] result = new int[2]; // 遍历计数数组 for(int i = 1; i Python ''' Author: Goog Tech Date: 2020-08-26 13:00:43 LastEditTime: 2020-08-26 13:05:01 Description: https://leetcode-cn.com/problems/set-mismatch/ FilePath: \\leetcode-googtech\\#645. Set Mismatch\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def findErrorNums(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" # 初始化结果列表并对 nums 进行排序处理 result, nums = [], sorted(nums) # 从头到尾遍历数组 for i in range(len(nums) - 1): # 若相邻元素相同则将其添加到结果列表中,然后结束遍历 if nums[i] == nums[i + 1]: result.append(nums[i]) break # 从索引值一开始从头到尾遍历数组 for i in range(1, len(nums) + 1): # 若当前索引值不在数组 nums 中则将其添加到结果列表中,然后结束遍历 if i not in nums: result.append(i) break # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/657.机器人能否返回原点/657.机器人能否返回原点.html":{"url":"LeetCode刷题之旅及题目解析/657.机器人能否返回原点/657.机器人能否返回原点.html","title":"657.机器人能否返回原点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 657. 机器人能否返回原点 Java Python 657. 机器人能否返回原点 https://leetcode-cn.com/problems/robot-return-to-origin/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 13:57:43 * @LastEditTime: 2020-08-29 13:58:01 * @Description: https://leetcode-cn.com/problems/robot-return-to-origin/ * @FilePath: \\leetcode-googtech\\#657. Robot Return to Origin\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public boolean judgeCircle(String moves) { int col = 0, row = 0; for(char ch : moves.toCharArray()) { if(ch == 'U') row++; else if(ch == 'D') row--; else if(ch == 'L') col++; else col--; } return row == 0 && col == 0; } } Python ''' Author: Goog Tech Date: 2020-08-29 13:57:51 LastEditTime: 2020-08-29 13:58:16 Description: https://leetcode-cn.com/problems/robot-return-to-origin/ FilePath: \\leetcode-googtech\\#657. Robot Return to Origin\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def judgeCircle(self, moves): \"\"\" :type moves: str :rtype: bool \"\"\" return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D') Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/680.验证回文字符串Ⅱ/680.验证回文字符串Ⅱ.html":{"url":"LeetCode刷题之旅及题目解析/680.验证回文字符串Ⅱ/680.验证回文字符串Ⅱ.html","title":"680.验证回文字符串Ⅱ","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 680. 验证回文字符串 Ⅱ Java Python @lc app=leetcode.cn id=680 lang=python [680] 验证回文字符串 Ⅱ @lc code=start 680. 验证回文字符串 Ⅱ https://leetcode-cn.com/problems/valid-palindrome-ii/ Java /* * @Author: Goog Tech * @Date: 2020-08-03 17:04:28 * @LastEditTime: 2020-08-03 17:43:08 * @Description: https://leetcode-cn.com/problems/valid-palindrome-ii/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.java */ /* * @lc app=leetcode.cn id=680 lang=java * * [680] 验证回文字符串 Ⅱ */ // @lc code=start class Solution { // 双指针法 public boolean validPalindrome(String s) { // 遍历字符串,判断头尾指针所指的字符是否相等 for(int i = 0, j = s.length()-1; i Python ''' Author: Goog Tech Date: 2020-08-03 16:48:16 LastEditTime: 2020-08-03 18:04:48 Description: https://leetcode-cn.com/problems/valid-palindrome-ii/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\Solution.py ''' # # @lc app=leetcode.cn id=680 lang=python # # [680] 验证回文字符串 Ⅱ # # @lc code=start class Solution(object): # 双指针法 def validPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" # 判断字符串是否为回文 def isPalindrome(s): return s == s[::-1] s = list(s) left = 0 right = len(s) - 1 # 遍历字符串,判断头尾指针所指的字符是否相等 while left Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/682.棒球比赛/682.棒球比赛.html":{"url":"LeetCode刷题之旅及题目解析/682.棒球比赛/682.棒球比赛.html","title":"682.棒球比赛","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 682. 棒球比赛 Java Python 682. 棒球比赛 https://leetcode-cn.com/problems/baseball-game/ Java /* * @Author: Goog Tech * @Date: 2020-08-31 17:36:46 * @LastEditTime: 2020-08-31 17:37:00 * @Description: https://leetcode-cn.com/problems/baseball-game/ * @FilePath: \\leetcode-googtech\\#682. Baseball Game\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int calPoints(String[] ops) { // 初始化辅助栈 Stack stack = new Stack<>(); // 初始化栈顶,临时变量以及总分数值 int top = 0, temp = 0, sum = 0; // 逐个遍历字符串数组中的符号 for(String str : ops) { // 获得的最后一个有效回合的分数是无效的,即删除栈顶元素 if(str.equals(\"C\")) { sum -= stack.pop(); // 本轮获得的得分是前一轮有效回合得分的两倍,即获取栈顶元素并将其乘以二后压入栈中 }else if(str.equals(\"D\")) { sum += stack.push(2 * stack.peek()); // 本轮获得的得分是前两轮有效回合得分的总和,即获取栈顶及栈顶第二个元素,并将其相加后压入栈中 }else if(str.equals(\"+\")) { top = stack.pop(); temp = top + stack.peek(); stack.push(top); sum += stack.push(temp); // 表示本轮中获得的积分数,即直接将其压入栈中 }else { stack.push(Integer.parseInt(str)); sum += Integer.parseInt(str); } } // 返回总分数值 return sum; } } Python ''' Author: Goog Tech Date: 2020-08-31 17:36:50 LastEditTime: 2020-08-31 17:37:13 Description: https://leetcode-cn.com/problems/baseball-game/ FilePath: \\leetcode-googtech\\#682. Baseball Game\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def calPoints(self, ops): \"\"\" :type ops: List[str] :rtype: int \"\"\" # 初始化辅助栈 stack = [] # 逐个遍历字符串数组中的符号 for op in ops: # 轮获得的得分是前两轮有效回合得分的总和,即获取栈顶及栈顶第二个元素,并将其相加后压入栈中 if op == '+': stack.append(stack[-1] + stack[-2]) # 获得的最后一个有效回合的分数是无效的,即删除栈顶元素 elif op == 'C': stack.pop() # 本轮获得的得分是前一轮有效回合得分的两倍,即获取栈顶元素并将其乘以二后压入栈中 elif op == 'D': stack.append(2 * stack[-1]) # 表示本轮中获得的积分数,即直接将其压入栈中 else: stack.append(int(op)) # 返回总分数值 return sum(stack) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/690.员工的重要性/690.员工的重要性.html":{"url":"LeetCode刷题之旅及题目解析/690.员工的重要性/690.员工的重要性.html","title":"690.员工的重要性","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 690. 员工的重要性 Java Python 690. 员工的重要性 https://leetcode-cn.com/problems/employee-importance/ Java /* * @Author: Goog Tech * @Date: 2020-09-13 13:32:22 * @LastEditTime: 2020-09-13 13:32:56 * @Description: https://leetcode-cn.com/problems/employee-importance/ * @FilePath: \\leetcode-googtech\\#690. Employee Importance\\Solution.java * @WebSite: https://algorithm.show/ */ /* // Definition for Employee. class Employee { public int id; public int importance; public List subordinates; }; */ class Solution { // 使用辅助队列进行广度优先遍历( BFS ) public int getImportance(List employees, int id) { // 初始化用于存储员工信息的 hashMap 集合 Map map = new HashMap<>(); // 逐个遍历员工信息,并将其添加到 hashMap 集合中 for(Employee employee : employees) map.put(employee.id, employee); // 初始化辅助队列,其用于存储每层每个员工信息的数据结构( 可将所有员工信息看作一个树结构 ) Queue queue = new LinkedList<>(); // 将待查找的员工 id 入队 queue.add(id); // 初始化当前层的员工个数及待查找员工所有下属的重要度之和的值 int oneLevel = 1, sum = 0; // 判断当前辅助队列是否为空 while(!queue.isEmpty()) { // 通过循环将队列中的元素,即员工信息结构逐个出队 while(oneLevel-- > 0) { // 获取当前出队员工的 id,并根据 id 获取该员工信息中的 \"重要度\" 的值 int tempId = queue.remove(); sum += map.get(tempId).importance; // 然后再通过 id 获取其直系下属的 id,并通过遍历将其下属 id 逐个存储在队列中 for(int subordinate : map.get(tempId).subordinates) queue.add(subordinate); } // 获取下一层员工的个数 oneLevel = queue.size(); } // 返回结果 return sum; } } Python ''' Author: Goog Tech Date: 2020-09-13 13:32:26 LastEditTime: 2020-09-13 13:33:19 Description: https://leetcode-cn.com/problems/employee-importance/ FilePath: \\leetcode-googtech\\#690. Employee Importance\\Solution.py WebSite: https://algorithm.show/ ''' \"\"\" # Definition for Employee. class Employee(object): def __init__(self, id, importance, subordinates): ################# :type id: int :type importance: int :type subordinates: List[int] ################# self.id = id self.importance = importance self.subordinates = subordinates \"\"\" class Solution(object): # 使用辅助队列进行广度优先搜索( BFS ) def getImportance(self, employees, id): \"\"\" :type employees: List[Employee] :type id: int :rtype: int \"\"\" # 初始化用于存储员工信息的 hashMap 集合 # 初始化辅助队列,其用于存储每层每个员工信息的数据结构( 可将所有员工信息看作一个树结构 ) # 初始化待查找员工所有下属的重要度之和的值 hashMap, queue, s = {}, [id], 0 # 逐个遍历员工信息,并将其添加到 hashMap 集合中 for employee in employees: hashMap[employee.id] = employee # 判断当前辅助队列是否为空 while queue: # 获取当前出队员工的 id,并根据 id 获取该员工信息中的 \"重要度\" 的值 currentEmplpyeeId = queue.pop(0) s += hashMap[currentEmplpyeeId].importance # 然后再通过 id 获取其直系下属的 id,并通过遍历将其下属 id 逐个存储在队列中 for subordinate in hashMap[currentEmplpyeeId].subordinates: queue.append(subordinate) # 返回结果 return s Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/700.二叉搜索树中的搜索/700.二叉搜索树中的搜索.html":{"url":"LeetCode刷题之旅及题目解析/700.二叉搜索树中的搜索/700.二叉搜索树中的搜索.html","title":"700.二叉搜索树中的搜索","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 700. 二叉搜索树中的搜索 Java Python @lc app=leetcode.cn id=700 lang=python [700] 二叉搜索树中的搜索 @lc code=start 700. 二叉搜索树中的搜索 https://leetcode-cn.com/problems/search-in-a-binary-search-tree/ Java /* * @Author: Goog Tech * @Date: 2020-07-29 09:40:02 * @LastEditTime: 2020-07-29 09:45:44 * @Description: https://leetcode-cn.com/problems/search-in-a-binary-search-tree/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\700.二叉搜索树中的搜索.java */ /* * @lc app=leetcode.cn id=700 lang=java * * [700] 二叉搜索树中的搜索 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /** * 二叉搜索树是一棵二叉树，每个节点都具备特性: 大于左子树上任意一个节点的值，小于右子树上任意一个节点的值。 * 解题思路如下: * 1.如果根节点为空 root == null 或者根节点的值等于搜索值 val == root.val，返回根节点 * 2.如果 val root.val，进入根节点的右子树查找 searchBST(root.right, val) */ public TreeNode searchBST(TreeNode root, int val) { // if(root == null || root.val == val) return root; // return val Python ''' @Author: Goog Tech @Date: 2020-07-29 09:22:52 @LastEditTime: 2020-07-29 09:45:28 @Description: https://leetcode-cn.com/problems/search-in-a-binary-search-tree/ @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\700.二叉搜索树中的搜索.py ''' # # @lc app=leetcode.cn id=700 lang=python # # [700] 二叉搜索树中的搜索 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): ''' 二叉搜索树是一棵二叉树，每个节点都具备特性: 大于左子树上任意一个节点的值，小于右子树上任意一个节点的值。 解题思路如下: 1.如果根节点为空 root == null 或者根节点的值等于搜索值 val == root.val，返回根节点 2.如果 val root.val，进入根节点的右子树查找 searchBST(root.right, val) ''' def searchBST(self, root, val): \"\"\" :type root: TreeNode :type val: int :rtype: TreeNode \"\"\" # if root is None or val == root.val: return root # return self.searchBST(root.left, val) if val Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/709.转换成小写字母/709.转换成小写字母.html":{"url":"LeetCode刷题之旅及题目解析/709.转换成小写字母/709.转换成小写字母.html","title":"709.转换成小写字母","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 709. 转换成小写字母 Java Python 709. 转换成小写字母 https://leetcode-cn.com/problems/to-lower-case/ Java /* * @Author: Goog Tech * @Date: 2020-07-20 23:50:00 * @Description: https://leetcode-cn.com/problems/to-lower-case/ * @FilePath: \\leetcode-googtech\\#709. To Lower Case\\Solution.java */ class Solution { public String toLowerCase(String str) { String result = \"\"; for (int i = 0; i = 65 && temp Python # updating Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/746.使用最小花费爬楼梯/746.使用最小花费爬楼梯.html":{"url":"LeetCode刷题之旅及题目解析/746.使用最小花费爬楼梯/746.使用最小花费爬楼梯.html","title":"746.使用最小花费爬楼梯","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 746. 使用最小花费爬楼梯 Java Python 746. 使用最小花费爬楼梯 https://leetcode-cn.com/problems/min-cost-climbing-stairs/ Java /* * @Author: Goog Tech * @Date: 2020-09-23 21:16:35 * @LastEditTime: 2020-09-23 21:17:52 * @Description: https://leetcode-cn.com/problems/min-cost-climbing-stairs/ * @FilePath: \\leetcode-googtech\\#746. Min Cost Climbing Stairs\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // DP : 动态规划 public int minCostClimbingStairs(int[] cost) { // 初始化 dp 数组及头两个元素 int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; // 循环遍历 cost 数组,用每一步选择台所消耗的最小体力值来初始化 dp for(int i = 2; i Python ''' Author: Goog Tech Date: 2020-09-23 21:16:40 LastEditTime: 2020-09-23 21:17:16 Description: https://leetcode-cn.com/problems/min-cost-climbing-stairs/ FilePath: \\leetcode-googtech\\#746. Min Cost Climbing Stairs\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # DP : 动态规划 # 设达到第 i 阶楼梯的最小代价为f(i),则 f(i) = min(f(i - 1), f(i - 2)) + cost[i] # 从而达到楼顶的最小代价为最后到达两个台阶的最小代价中的较小者 def minCostClimbingStairs(self, cost): \"\"\" :type cost: List[int] :rtype: int \"\"\" N = len(cost) dp = [0] * N dp[0] = cost[0] dp[1] = cost[1] for i in range(2, N): dp[i] = min(dp[i-2], dp[i-1]) + cost[i] return min(dp[-2], dp[-1]) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/783.二叉搜索树节点最小距离/783.二叉搜索树节点最小距离.html":{"url":"LeetCode刷题之旅及题目解析/783.二叉搜索树节点最小距离/783.二叉搜索树节点最小距离.html","title":"783.二叉搜索树节点最小距离","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 783. 二叉搜索树节点最小距离 Java Python 783. 二叉搜索树节点最小距离 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ Java /* * @Author: Goog Tech * @Date: 2020-09-10 17:58:45 * @LastEditTime: 2020-09-10 17:59:01 * @Description: https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ * @FilePath: \\leetcode-googtech\\#783. Minimum Distance Between BST Nodes\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ // 中序遍历: 根据搜索二叉树的特性,中序遍历会将树中节点数值从小到大顺序输出, // 进而只需要遍历计算相邻数的差值,取其中最小值即可. class Solution { private TreeNode pre = null; private int minDiff = Integer.MAX_VALUE; public int minDiffInBST(TreeNode root) { if(root == null) return -1; inOrder(root); return minDiff; } private void inOrder(TreeNode root) { if(root == null) return; inOrder(root.left); if(pre != null) minDiff = Math.min(minDiff, root.val - pre.val); pre = root; inOrder(root.right); } } Python ''' Author: Goog Tech Date: 2020-09-10 17:58:51 LastEditTime: 2020-09-10 17:59:28 Description: https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ FilePath: \\leetcode-googtech\\#783. Minimum Distance Between BST Nodes\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 中序遍历: 根据搜索二叉树的特性,中序遍历会将树中节点数值从小到大顺序输出 # 进而只需要遍历计算相邻数的差值,取其中最小值即可. def minDiffInBST(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(node): if node: dfs(node.left) self.result = min(self.result, abs(node.val - self.prev)) self.prev = node.val dfs(node.right) # Python用如下方式表示正负无穷,即规定所有的数都比 -inf 大,所有数都比 inf 小 self.prev = float('-inf') self.result = float('inf') dfs(root) return self.result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/804.唯一摩尔斯密码词/804.唯一摩尔斯密码词.html":{"url":"LeetCode刷题之旅及题目解析/804.唯一摩尔斯密码词/804.唯一摩尔斯密码词.html","title":"804.唯一摩尔斯密码词","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 804. 唯一摩尔斯密码词 Java Python 804. 唯一摩尔斯密码词 https://leetcode-cn.com/problems/unique-morse-code-words/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 14:34:19 * @LastEditTime: 2020-08-29 14:34:31 * @Description: https://leetcode-cn.com/problems/unique-morse-code-words/ * @FilePath: \\leetcode-googtech\\#804. Unique Morse Code Words\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int uniqueMorseRepresentations(String[] words) { // 初始化 26 个英文字母对应摩尔斯密码表 String[] str=new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; // 初始化用于存储单词翻译结果的 HashSet 集合 HashSet set = new HashSet<>(); // 遍历字符串数组 for(String word : words) { // 遍历当前单词中的所有字符,对照摩斯密码进行逐个翻译 StringBuilder sb = new StringBuilder(); for(char c : word.toCharArray()) { // 其中 c - a 的取值范围为 1 到 26 sb.append(str[c - 'a']); } // 将单词翻译的结果添加到结果集合中 set.add(sb.toString()); } // 返回结果集合中的已翻译的单词数(已去重) return set.size(); } } Python ''' Author: Goog Tech Date: 2020-08-29 14:34:23 LastEditTime: 2020-08-29 14:35:28 Description: https://leetcode-cn.com/problems/unique-morse-code-words/ FilePath: \\leetcode-googtech\\#804. Unique Morse Code Words\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def uniqueMorseRepresentations(self, words): \"\"\" :type words: List[str] :rtype: int \"\"\" # 初始化 26 个英文字母对应摩尔斯密码表 pwdStr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] # 初始化用于存储单词翻译结果的 HashSet 集合 result = set() # 遍历字符串数组 for word in words: # 遍历当前单词中的所有字符,对照摩斯密码进行逐个翻译 s = \"\" for c in word: # ord() 方法返回对应的 ASCII 数值,其中 ord(c) - ord(a) 的取值范围为 1 到 26 s += pwdStr[ord(c) - 97] # 将单词翻译的结果添加到结果集合中 result.add(s) # 返回结果集合中的已翻译的单词数(已去重) return len(result) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/844.比较含退格的字符串/844.比较含退格的字符串.html":{"url":"LeetCode刷题之旅及题目解析/844.比较含退格的字符串/844.比较含退格的字符串.html","title":"844.比较含退格的字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 844. 比较含退格的字符串 Java Python 844. 比较含退格的字符串 https://leetcode-cn.com/problems/backspace-string-compare/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 17:19:51 * @LastEditTime: 2020-08-30 17:20:08 * @Description: https://leetcode-cn.com/problems/backspace-string-compare/ * @FilePath: \\leetcode-googtech\\#844. Backspace String Compare\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 本题主要考察双指针,这里利用栈结构来解答下吧嘿嘿&#x1F605; public boolean backspaceCompare(String S, String T) { // 初始化栈结构,其用于存储 S 与 T 字符串中的字符 Stack sstack = new Stack<>(); Stack tstack = new Stack<>(); // 遍历字符串 S 中的字符 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-30 17:19:55 LastEditTime: 2020-08-30 17:21:07 Description: https://leetcode-cn.com/problems/backspace-string-compare/ FilePath: \\leetcode-googtech\\#844. Backspace String Compare\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 本题主要考察双指针,这里利用栈结构来解答下吧嘿嘿&#x1F605; def backspaceCompare(self, S, T): \"\"\" :type S: str :type T: str :rtype: bool \"\"\" # 初始化两辅助栈,其用于存储 S 与 T 字符串中的字符 slist, tlist = [], [] # 遍历 S 字符串中的字符 for i in range(len(S)): # 判断当前字符是否为符号 # if S[i] != '#': # 若是则将其压入栈中 slist.append(S[i]) # 判断当前字符是否为符号 # 且辅助栈是否为空 elif S[i] == '#' and slist != []: # 若是则弹出栈顶元素,即删除符号 # 前的一个字符 slist.pop() # 同上 for j in range(len(T)): if T[j] != '#': tlist.append(T[j]) elif T[j] == '#' and tlist != []: tlist.pop() # 判断两个辅助栈中的元素是否相同,并返回其结果 return slist == tlist Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/872.叶子相似的树/872.叶子相似的树.html":{"url":"LeetCode刷题之旅及题目解析/872.叶子相似的树/872.叶子相似的树.html","title":"872.叶子相似的树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 872. 叶子相似的树 Java Python @lc app=leetcode.cn id=872 lang=python [872] 叶子相似的树 @lc code=start 872. 叶子相似的树 https://leetcode-cn.com/problems/leaf-similar-trees/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 17:27:08 * @LastEditTime: 2020-08-16 17:47:02 * @Description: https://leetcode-cn.com/problems/leaf-similar-trees/ * @FilePath: \\leetcode-googtech\\#872. Leaf-Similar Trees\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=872 lang=java * * [872] 叶子相似的树 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // DFS: 深度优先搜索 public boolean leafSimilar(TreeNode root1, TreeNode root2) { // 判断两个二叉树的叶值序列是否相同 String leftLeaf = dfs(root1, \"\"); String rightLeaf = dfs(root2, \"\"); return leftLeaf.equals(rightLeaf); } private String dfs(TreeNode root, String result) { // 判断当前节点是否为空 if(root == null) return result; // 判断当前节点是否为叶子节点,若是则对其进行拼接 if(root.left == null && root.right == null) { // 添加分隔符的目的: https://leetcode-cn.com/problems/leaf-similar-trees/comments/548544 result += '-'; result += result + root.val; return result; } // 递归遍历当前节点的左右孩子节点 return dfs(root.left, result) + dfs(root.right, result); } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-16 17:28:02 LastEditTime: 2020-08-16 17:39:45 Description: https://leetcode-cn.com/problems/leaf-similar-trees/ FilePath: \\leetcode-googtech\\#872. Leaf-Similar Trees\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=872 lang=python # # [872] 叶子相似的树 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 先序遍历 def leafSimilar(self, root1, root2): \"\"\" :type root1: TreeNode :type root2: TreeNode :rtype: bool \"\"\" # 用于存储两个二叉树的叶子节点 nums1, nums2 = [], [] def leaf(root, nums): # 判断当前节点是否为空并且是否为叶子节点,若是则将其添加到nums中 if root and not root.left and not root.right: nums.append(root.val) # 递归遍历当前节点的左右孩子节点 if root.left: leaf(root.left, nums) if root.right: leaf(root.right, nums) # 返回叶子节点列表 return nums # 判断两个二叉树的叶值序列是否相同 return leaf(root1, nums1) == leaf(root2, nums2) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/876.链表的中间结点/876.链表的中间结点.html":{"url":"LeetCode刷题之旅及题目解析/876.链表的中间结点/876.链表的中间结点.html","title":"876.链表的中间结点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 876. 链表的中间结点 Java Python 876. 链表的中间结点 https://leetcode-cn.com/problems/middle-of-the-linked-list/ Java /* * @Author: Goog Tech * @Date: 2020-07-18 22:10:42 * @Description: https://leetcode-cn.com/problems/middle-of-the-linked-list/ * @FilePath: \\leetcode-googtech\\#876. Middle of the Linked List\\Solutoin.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 快指针fastNode每次走2步,慢指针slowNode每次走1步, // 当fastNode走到末尾时slowNode正好走到中间 public ListNode middleNode(ListNode head) { ListNode fastNode = head,slowNode = head; while(fastNode!=null && fastNode.next!=null){ fastNode = fastNode.next.next; slowNode = slowNode.next; } return slowNode; } } Python ''' @Author: Goog Tech @Date: 2020-07-18 22:10:48 @Description: https://leetcode-cn.com/problems/middle-of-the-linked-list/ @FilePath: \\leetcode-googtech\\#876. Middle of the Linked List\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def middleNode(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 快指针fastNode每次走2步,慢指针slowNode每次走1步, # 当fastNode走到末尾时slowNode正好走到中间 fastNode = slowNode = head while fastNode and fastNode.next: fastNode = fastNode.next.next slowNode = slowNode.next return slowNode Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/897.递增顺序查找树/897.递增顺序查找树.html":{"url":"LeetCode刷题之旅及题目解析/897.递增顺序查找树/897.递增顺序查找树.html","title":"897.递增顺序查找树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 897. 递增顺序查找树 Java Python 897. 递增顺序查找树 https://leetcode-cn.com/problems/increasing-order-search-tree/ Java /* * @Author: Goog Tech * @Date: 2020-09-13 14:40:43 * @LastEditTime: 2020-09-13 14:40:56 * @Description: https://leetcode-cn.com/problems/increasing-order-search-tree/ * @FilePath: \\leetcode-googtech\\#897. Increasing Order Search Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 查找树也称搜索树或排序树,其特性为: 左孩子比根节点小,右孩子比根节点大, // 进而中序遍历会得到一个递增序列. public TreeNode increasingBST(TreeNode root) { // 初始化用于存储查找树中节点的 list 集合数组 List list = new ArrayList<>(); // 中序遍历得到一个递增序列的集合数组 inorder(root, list); // 初始化结果树的头节点及其指针 TreeNode result = new TreeNode(0), currentNode = result; // 用已经有序的的集合数组元素构建结果树 for(int value : list) { currentNode.right = new TreeNode(value); currentNode = currentNode.right; } // 返回根节点 return result.right; } private void inorder(TreeNode node, List list) { if(node == null) return; inorder(node.left, list); list.add(node.val); inorder(node.right, list); } } Python ''' Author: Goog Tech Date: 2020-09-13 14:40:49 LastEditTime: 2020-09-13 14:41:21 Description: https://leetcode-cn.com/problems/increasing-order-search-tree/ FilePath: \\leetcode-googtech\\#897. Increasing Order Search Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 查找树也称搜索树或排序树,其特性为: 左孩子比根节点小,右孩子比根节点大, # 进而中序遍历会得到一个递增序列. def increasingBST(self, root): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" def inorder(root): if not root: return [] else: return inorder(root.left) + [root.val] + inorder(root.right); # 通过中序遍历得到一个递增序列的列表数组 alist = inorder(root) # 初始化根节点及其指针 newRoot = TreeNode(alist[0]) currentNode = newRoot # 用已经有序的的列表元素构建结果树 for i in range(1, len(alist)): currentNode.right = TreeNode(alist[i]) currentNode = currentNode.right # 返回结果树的根节点 return newRoot Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/905.按奇偶排序数组/905.按奇偶排序数组.html":{"url":"LeetCode刷题之旅及题目解析/905.按奇偶排序数组/905.按奇偶排序数组.html","title":"905.按奇偶排序数组","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 905. 按奇偶排序数组 Java Python 905. 按奇偶排序数组 https://leetcode-cn.com/problems/sort-array-by-parity/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 11:39:16 * @LastEditTime: 2020-08-16 11:39:27 * @Description: https://leetcode-cn.com/problems/sort-array-by-parity/ * @FilePath: \\leetcode-googtech\\#905. Sort Array By Parity\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public int[] sortArrayByParity(int[] A) { int left = 0, right = A.length - 1; while(left Python ''' Author: Goog Tech Date: 2020-08-16 11:39:20 LastEditTime: 2020-08-16 11:39:46 Description: https://leetcode-cn.com/problems/sort-array-by-parity/ FilePath: \\leetcode-googtech\\#905. Sort Array By Parity\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def sortArrayByParity(self, A): \"\"\" :type A: List[int] :rtype: List[int] \"\"\" i = 0 for j in range(len(A)): if A[j] % 2 == 0: A[i], A[j] = A[j], A[i] i += 1 return A Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/917.仅仅反转字母/917.仅仅反转字母.html":{"url":"LeetCode刷题之旅及题目解析/917.仅仅反转字母/917.仅仅反转字母.html","title":"917.仅仅反转字母","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 917. 仅仅反转字母 Java Python 917. 仅仅反转字母 https://leetcode-cn.com/problems/reverse-only-letters/ Java /* * @Author: Goog Tech * @Date: 2020-08-21 18:35:39 * @LastEditTime: 2020-08-21 18:36:02 * @Description: https://leetcode-cn.com/problems/reverse-only-letters/ * @FilePath: \\leetcode-googtech\\#917. Reverse Only Letters\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public String reverseOnlyLetters(String S) { // 初始化头尾指针 int left = 0, right = S.length() - 1; // 将字符串转换为字符数组 char[] chars = S.toCharArray(); while(left Python ''' Author: Goog Tech Date: 2020-08-21 18:35:45 LastEditTime: 2020-08-21 18:36:21 Description: https://leetcode-cn.com/problems/reverse-only-letters/ FilePath: \\leetcode-googtech\\#917. Reverse Only Letters\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def reverseOnlyLetters(self, S): \"\"\" :type S: str :rtype: str \"\"\" # 将字符串转换为列表数组 S = list(S) # 初始化双指针 front, end = 0, len(S) - 1 # 通过移动双指针循环遍历数组元素 while front Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/921.使括号有效的最少添加/921.使括号有效的最少添加.html":{"url":"LeetCode刷题之旅及题目解析/921.使括号有效的最少添加/921.使括号有效的最少添加.html","title":"921.使括号有效的最少添加","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 921. 使括号有效的最少添加 Java Python 921. 使括号有效的最少添加 https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/ Java /* * @Author: Goog Tech * @Date: 2020-09-02 22:04:54 * @LastEditTime: 2020-09-02 22:05:22 * @Description: https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/ * @FilePath: \\leetcode-googtech\\#921. Minimum Add to Make Parentheses Valid\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int minAddToMakeValid(String S) { int left = 0, result = 0; for(char c : S.toCharArray()) { if(c == '(') { left++; // 左括号多余 }else { if(left == 0) { result++; // 右括号多余 }else { left--; } } } return result + left; } } Python ''' Author: Goog Tech Date: 2020-09-02 22:04:59 LastEditTime: 2020-09-02 22:05:14 Description: https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/ FilePath: \\leetcode-googtech\\#921. Minimum Add to Make Parentheses Valid\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def minAddToMakeValid(self, S): \"\"\" :type S: str :rtype: int \"\"\" stack = [] for ch in S: if not stack: stack.append(ch) else: if ch == ')' and stack[-1] == '(': stack.pop() else: stack.append(ch) return len(stack) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/922.按奇偶排序数组II/922.按奇偶排序数组II.html":{"url":"LeetCode刷题之旅及题目解析/922.按奇偶排序数组II/922.按奇偶排序数组II.html","title":"922.按奇偶排序数组II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 922. 按奇偶排序数组 II Java Python 922. 按奇偶排序数组 II https://leetcode-cn.com/problems/sort-array-by-parity-ii/ Java /* * @Author: Goog Tech * @Date: 2020-09-09 19:03:17 * @LastEditTime: 2020-09-09 19:05:42 * @Description: https://leetcode-cn.com/problems/sort-array-by-parity-ii/ * @FilePath: \\leetcode-googtech\\#922. Sort Array By Parity II\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // i 用于寻找偶数,j 用于寻找奇数 // 把奇数部分作为暂存区,不断增加指向奇数部分的指针,直到找到一个偶数,然后交换指针i, j所指的值 public int[] sortArrayByParityII(int[] A) { int j = 1; // 遍历数组中下标为偶数的元素 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-09 19:03:22 LastEditTime: 2020-09-09 19:05:54 Description: https://leetcode-cn.com/problems/sort-array-by-parity-ii/ FilePath: \\leetcode-googtech\\#922. Sort Array By Parity II\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # i 用于寻找偶数,j 用于寻找奇数 # 解题思路: 把奇数部分作为暂存区,不断增加指向奇数部分的指针,直到找到一个偶数,然后交换指针i, j所指的值 def sortArrayByParityII(self, A): \"\"\" :type A: List[int] :rtype: List[int] \"\"\" j = 1 # 遍历数组中下标为偶数的元素 for i in range(0, len(A), 2): # 判断当前偶数下标的元素是否为奇数 if A[i] % 2: # 判断当前奇数下标的元素是否为奇数,即寻找偶数下标 j while A[j] % 2: j += 2 # 交换当前奇偶元素 A[i], A[j] = A[j], A[i] # 返回结果数组 return A Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/925.长按键入/925.长按键入.html":{"url":"LeetCode刷题之旅及题目解析/925.长按键入/925.长按键入.html","title":"925.长按键入","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 925. 长按键入 Java Python 925. 长按键入 https://leetcode-cn.com/problems/long-pressed-name/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 20:00:16 * @LastEditTime: 2020-08-30 20:02:56 * @Description: https://leetcode-cn.com/problems/long-pressed-name/ * @FilePath: \\leetcode-googtech\\#925. Long Pressed Name\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 此题考察的是双指针算法,那我们用其它的简便方法吧嘻嘻&#x1F605; public boolean isLongPressedName(String name, String typed) { // 将 name 字符串转化为字符数组 char[] nameChars = name.toCharArray(); // 初始化姓名数组指针,即下标值 int index = 0; // 逐个遍历输入字符串 typed 中的字符 for(char t : typed.toCharArray()) { // 若 index 的长度小于姓名数组的长度, // 并且当前输入的字符与 nameChars 数组中指针 index 所指的元素相同,则向后移动指针 index if(index Python ''' Author: Goog Tech Date: 2020-08-30 20:00:20 LastEditTime: 2020-08-30 20:01:52 Description: https://leetcode-cn.com/problems/long-pressed-name/ FilePath: \\leetcode-googtech\\#925. Long Pressed Name\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def isLongPressedName(self, name, typed): \"\"\" :type name: str :type typed: str :rtype: bool \"\"\" ''' 待解. . . ''' Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/929.独特的电子邮件地址/929.独特的电子邮件地址.html":{"url":"LeetCode刷题之旅及题目解析/929.独特的电子邮件地址/929.独特的电子邮件地址.html","title":"929.独特的电子邮件地址","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 929. 独特的电子邮件地址 Java Python 929. 独特的电子邮件地址 https://leetcode-cn.com/problems/unique-email-addresses/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 23:17:50 * @LastEditTime: 2020-08-29 23:18:19 * @Description: https://leetcode-cn.com/problems/unique-email-addresses/ * @FilePath: \\leetcode-googtech\\#929. Unique Email Addresses\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int numUniqueEmails(String[] emails) { Set set = new HashSet<>(); for(String email : emails) { StringBuilder sb = new StringBuilder(); // substring(int beginIndex, int endIndex) sb.append(email.substring(0, email.indexOf('+') == -1 ? email.indexOf('@') : email.indexOf('+')).replace(\".\", \"\")); // substring(int beginIndex) sb.append(email.substring(email.indexOf('@'))); set.add(sb.toString()); } return set.size(); } } Python ''' Author: Goog Tech Date: 2020-08-29 23:17:56 LastEditTime: 2020-08-29 23:18:12 Description: https://leetcode-cn.com/problems/unique-email-addresses/ FilePath: \\leetcode-googtech\\#929. Unique Email Addresses\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def numUniqueEmails(self, emails): \"\"\" :type emails: List[str] :rtype: int \"\"\" # 初始化用于存储邮件地址的 Set 集合 emailSet = set() # 逐个遍历数组中的邮件地址 for email in emails: # 分割邮件中的本地名称与域名 name, domain = email.split('@') # 判断本地名称中是否存在符号 '+' if name.find('+') == -1: # 本地名称中不存在符号 '+',所以仅删除名称中的符号 '.' 即可 name = name.replace('.','') else: # 忽略本地名称中符号 '+' 后面的字符,并删除名称中的符号 '.' name = name[:name.find('+')].replace('.', '') # 重新组合本地名称与域名,并将其存储到 Set 集合中 emailSet.add(name + '@' + domain) # 返回 Set 集合中不同邮件的数量 return len(emailSet) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/933.最近的请求次数/933.最近的请求次数.html":{"url":"LeetCode刷题之旅及题目解析/933.最近的请求次数/933.最近的请求次数.html","title":"933.最近的请求次数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 933. 最近的请求次数 Java Python 933. 最近的请求次数 https://leetcode-cn.com/problems/number-of-recent-calls/ Java /* * @Author: Goog Tech * @Date: 2020-09-06 21:04:04 * @LastEditTime: 2020-09-06 21:04:36 * @Description: https://leetcode-cn.com/problems/number-of-recent-calls/ * @FilePath: \\leetcode-googtech\\#933. Number of Recent Calls\\Solution.java * @WebSite: https://algorithm.show/ */ // 解题关键点 : 因只需考虑最近 3000 毫秒到现在时间 t 的 ping 数, // 所以我们可以使用队列来存储这些 ping 的记录,当收到一个时间 t 的 ping 时, // 我们将它加入队列,并且将所有在时间 t - 3000 之前的 ping 移出队列. class RecentCounter { Queue queue; public RecentCounter() { queue = new LinkedList(); } public int ping(int t) { queue.add(t); while(queue.peek() Python ''' Author: Goog Tech Date: 2020-09-06 21:04:10 LastEditTime: 2020-09-06 21:05:17 Description: https://leetcode-cn.com/problems/number-of-recent-calls/ FilePath: \\leetcode-googtech\\#933. Number of Recent Calls\\Solution.py WebSite: https://algorithm.show/ ''' # 解题关键点 : 因只需考虑最近 3000 毫秒到现在时间 t 的 ping 数, # 所以我们可以使用队列来存储这些 ping 的记录,当收到一个时间 t 的 ping 时, # 我们将它加入队列,并且将所有在时间 t - 3000 之前的 ping 移出队列. class RecentCounter(object): def __init__(self): self.queue = deque() def ping(self, t): \"\"\" :type t: int :rtype: int \"\"\" self.queue.append(t) while self.queue[0] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/938.二叉搜索树的范围和/938.二叉搜索树的范围和.html":{"url":"LeetCode刷题之旅及题目解析/938.二叉搜索树的范围和/938.二叉搜索树的范围和.html","title":"938.二叉搜索树的范围和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 938. 二叉搜索树的范围和 Java Python @lc app=leetcode.cn id=938 lang=python [938] 二叉搜索树的范围和 @lc code=start 938. 二叉搜索树的范围和 https://leetcode-cn.com/problems/range-sum-of-bst/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 21:07:13 * @LastEditTime: 2020-08-14 21:24:18 * @Description: https://leetcode-cn.com/problems/range-sum-of-bst/ * @FilePath: \\leetcode-googtech\\#938. Range Sum of BST\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=938 lang=java * * [938] 二叉搜索树的范围和 */ // @lc code=start /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /* * 二叉查找树,又被称为二叉搜索树. 其特点为: 左孩子均比父节点小,右孩子均比比父节点大. * * 算法实现的逻辑如下所示: * 当前节点为 null 时返回 0 * 当前节点 X R 时则返回左子树之和 * 当前节点 X >= L 且 X R) return rangeSumBST(root.left, L, R); return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R); } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-14 21:20:02 LastEditTime: 2020-08-14 21:24:29 Description: https://leetcode-cn.com/problems/range-sum-of-bst/ FilePath: \\leetcode-googtech\\#938. Range Sum of BST\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=938 lang=python # # [938] 二叉搜索树的范围和 # # @lc code=start # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): ''' 二叉查找树,又被称为二叉搜索树. 其特点为: 左孩子均比父节点小,右孩子均比比父节点大. 算法实现的逻辑如下所示: 当前节点为 null 时返回 0 当前节点 X R 时则返回左子树之和 当前节点 X >= L 且 X R: return self.rangeSumBST(root.left, L, R) return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/977.有序数组的平方/977.有序数组的平方.html":{"url":"LeetCode刷题之旅及题目解析/977.有序数组的平方/977.有序数组的平方.html","title":"977.有序数组的平方","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 977. 有序数组的平方 Java Python 977. 有序数组的平方 https://leetcode-cn.com/problems/squares-of-a-sorted-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 10:29:21 * @LastEditTime: 2020-08-09 10:29:54 * @Description: https://leetcode-cn.com/problems/squares-of-a-sorted-array/ * @FilePath: \\leetcode-googtech\\#977. Squares of a Sorted Array\\Solution.java */ class Solution { // 双指针法 public int[] sortedSquares(int[] A) { // 初始化双指针 int start = 0, end = A.length; int index = end - 1; // 初始化结果数组 int [] nums = new int[end--]; // 循环遍历数组中元素,并计算其平方值,然后按照递增的顺序存储到结果数组中 while(index >= 0) nums[index--] = A[start]*A[start] >= A[end]*A[end] ? A[start]*A[start++] : A[end]*A[end--]; // 返回结果数组 return nums; } } Python ''' Author: Goog Tech Date: 2020-08-09 10:29:28 LastEditTime: 2020-08-09 10:30:23 Description: https://leetcode-cn.com/problems/squares-of-a-sorted-array/ FilePath: \\leetcode-googtech\\#977. Squares of a Sorted Array\\Solution.py ''' class Solution(object): def sortedSquares(self, A): \"\"\" :type A: List[int] :rtype: List[int] \"\"\" for i in range(len(A)): A[i] = A[i]*A[i] return sorted(A) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/993.二叉树的堂兄弟节点/993.二叉树的堂兄弟节点.html":{"url":"LeetCode刷题之旅及题目解析/993.二叉树的堂兄弟节点/993.二叉树的堂兄弟节点.html","title":"993.二叉树的堂兄弟节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 993. 二叉树的堂兄弟节点 Java Python 993. 二叉树的堂兄弟节点 https://leetcode-cn.com/problems/cousins-in-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-09-12 11:36:11 * @LastEditTime: 2020-09-12 11:36:33 * @Description: https://leetcode-cn.com/problems/cousins-in-binary-tree/ * @FilePath: \\leetcode-googtech\\#993. Cousins in Binary Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { Map depth; Map parent; // 解题思路: 利用深度优先搜索及递归求出每一个节点的深度与父节点 public boolean isCousins(TreeNode root, int x, int y) { depth = new HashMap(); parent = new HashMap(); // 传入根节点及其父节点(null) dfs(root, null); // 当且仅当一对节点深度相同而父节点不同时,它们是堂兄弟节点. return (depth.get(x) == depth.get(y) && parent.get(x) != parent.get(y)); } public void dfs(TreeNode node, TreeNode par) { // 判断当前节点,即上一个节点的孩子节点是否为空 if(node != null) { // 对于每一个节点 node,它的父亲为 par,深度为 d,我们将其记录到 HashMap 中 // 即令 parent[node.val] = par, depth[node.val] = d depth.put(node.val, par != null ? 1 + depth.get(par.val) : 0); parent.put(node.val, par); // 传入当前节点的孩子节点及其父节点,即继续深度遍历 dfs(node.left, node); dfs(node.right, node); } } } Python ''' Author: Goog Tech Date: 2020-09-12 11:36:15 LastEditTime: 2020-09-12 11:36:59 Description: https://leetcode-cn.com/problems/cousins-in-binary-tree/ FilePath: \\leetcode-googtech\\#993. Cousins in Binary Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): # 解题思路: 利用深度优先搜索及递归求出每一个节点的深度与父节点 def isCousins(self, root, x, y): \"\"\" :type root: TreeNode :type x: int :type y: int :rtype: bool \"\"\" parent, depth = {}, {} def dfs(node, par = None): # 判断当前节点,即上一个节点的孩子节点是否为空 if node: # 对于每一个节点 node,它的父亲为 par,深度为 d,我们将其记录到 HashMap 中 # 即令 parent[node.val] = par, depth[node.val] = d depth[node.val] = 1 + depth[par.val] if par else 0 parent[node.val] = par # 传入当前节点的孩子节点及其父节点,即继续深度遍历 dfs(node.left, node) dfs(node.right, node) dfs(root) # 当且仅当一对节点深度相同而父节点不同时,它们是堂兄弟节点. return depth[x] == depth[y] and parent[x] != parent[y] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1021.删除最外层的括号/1021.删除最外层的括号.html":{"url":"LeetCode刷题之旅及题目解析/1021.删除最外层的括号/1021.删除最外层的括号.html","title":"1021.删除最外层的括号","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1021. 删除最外层的括号 Java Python 1021. 删除最外层的括号 https://leetcode-cn.com/problems/remove-outermost-parentheses/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 08:17:15 * @LastEditTime: 2020-08-09 08:18:31 * @Description: https://leetcode-cn.com/problems/remove-outermost-parentheses/ * @FilePath: \\leetcode-googtech\\#1021. Remove Outermost Parentheses\\Solution.java */ class Solution { public String removeOuterParentheses(String S) { StringBuffer sb = new StringBuffer(); // 将字符串转换为字符数组 char[] chars = S.toCharArray(); int level = 0; // 遍历字符数组,将最内层括号添加到sb中 for(char c : chars) { if( c == ')') --level; if(level >= 1) sb.append(c); if(c == '(') ++level; } // 将结果转化为字符串并返回 return sb.toString(); } } Python ''' Author: Goog Tech Date: 2020-08-09 08:17:22 LastEditTime: 2020-08-09 08:18:59 Description: https://leetcode-cn.com/problems/remove-outermost-parentheses/ FilePath: \\leetcode-googtech\\#1021. Remove Outermost Parentheses\\Solution.py ''' class Solution(object): def removeOuterParentheses(self, S): \"\"\" :type S: str :rtype: str \"\"\" level = 0 result = [] # 遍历字符串元素,并将最内层括号添加到result列表中 for c in S: if c == ')': level -= 1 if level >= 1: result.append(c) if c == '(': level += 1 # 将结果列表转换为字符串并返回 return ''.join(result) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1047.删除字符串中的所有相邻重复项/1047.删除字符串中的所有相邻重复项.html":{"url":"LeetCode刷题之旅及题目解析/1047.删除字符串中的所有相邻重复项/1047.删除字符串中的所有相邻重复项.html","title":"1047.删除字符串中的所有相邻重复项","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1047. 删除字符串中的所有相邻重复项 Java Python @lc app=leetcode.cn id=1047 lang=python [1047] 删除字符串中的所有相邻重复项 @lc code=start 1047. 删除字符串中的所有相邻重复项 https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 14:15:21 * @LastEditTime: 2020-08-14 14:40:21 * @Description: https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/ * @FilePath: \\leetcode-googtech\\#1047. Remove All Adjacent Duplicates In String\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1047 lang=java * * [1047] 删除字符串中的所有相邻重复项 */ // @lc code=start class Solution { public String removeDuplicates(String S) { // 将字符串转为字符数组 char[] c = S.toCharArray(); // 初始化辅助栈 Stack stack = new Stack<>(); // 遍历字符串,判断当前元素是否与栈顶元素相同 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-14 14:17:54 LastEditTime: 2020-08-14 14:40:50 Description: https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/ FilePath: \\leetcode-googtech\\#1047. Remove All Adjacent Duplicates In String\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1047 lang=python # # [1047] 删除字符串中的所有相邻重复项 # # @lc code=start class Solution(object): def removeDuplicates(self, S): \"\"\" :type S: str :rtype: str \"\"\" stack = [] # 循环遍历栈中元素 for c in S: # 若当前字母与栈顶元素相同,则弹出栈顶元素 if stack and c == stack[-1]: stack.pop() # 反之将其继续存储到栈中 else: stack.append(c) # 最后将其转换为字符串并返回 return ''.join(stack) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1108.IP地址无效化/1108.IP地址无效化.html":{"url":"LeetCode刷题之旅及题目解析/1108.IP地址无效化/1108.IP地址无效化.html","title":"1108.IP地址无效化","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1108. IP 地址无效化 Java Python 1108. IP 地址无效化 https://leetcode-cn.com/problems/defanging-an-ip-address/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 07:42:42 * @LastEditTime: 2020-08-09 07:43:54 * @Description: https://leetcode-cn.com/problems/defanging-an-ip-address/ * @FilePath: \\leetcode-googtech\\#1108. Defanging an IP Address\\Solution.java */ class Solution { public String defangIPaddr(String address) { StringBuffer sb = new StringBuffer(); char[] chars = address.toCharArray(); for(char c : chars) { sb = c == '.' ? sb.append(\"[.]\") : sb.append(c); } return sb.toString(); } } Python ''' Author: Goog Tech Date: 2020-08-09 07:42:47 LastEditTime: 2020-08-09 07:43:15 Description: https://leetcode-cn.com/problems/defanging-an-ip-address/ FilePath: \\leetcode-googtech\\#1108. Defanging an IP Address\\Solution.py ''' class Solution(object): def defangIPaddr(self, address): \"\"\" :type address: str :rtype: str \"\"\" return address.replace('.', '[.]') Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1123.最深叶节点的最近公共祖先/1123.最深叶节点的最近公共祖先.html":{"url":"LeetCode刷题之旅及题目解析/1123.最深叶节点的最近公共祖先/1123.最深叶节点的最近公共祖先.html","title":"1123.最深叶节点的最近公共祖先","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1123. 最深叶节点的最近公共祖先 Java Python 1123. 最深叶节点的最近公共祖先 https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/ Java /* * @Author: Goog Tech * @Date: 2020-09-27 17:55:31 * @LastEditTime: 2020-09-27 17:55:57 * @Description: https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/ * @FilePath: \\leetcode-googtech\\#1123. Lowest Common Ancestor of Deepest Leaves\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // DFS : 深度优先遍历 // 如果左右子树高度相等,则当前结点为要找的结点 // 否则要找的结点在高度较大的子树中,进而自底向上的计算高度并返回寻找到的结点 public TreeNode lcaDeepestLeaves(TreeNode root) { if(root == null) return null; int leftDepth = depth(root.left); int rightDepth = depth(root.right); return leftDepth == rightDepth ? root : leftDepth > rightDepth ? lcaDeepestLeaves(root.left) : lcaDeepestLeaves(root.right); } private int depth(TreeNode root) { if(root == null) return 0; int leftDepth = depth(root.left); int rightDepth = depth(root.right); return Math.max(leftDepth, rightDepth) + 1; } } Python ''' Author: Goog Tech Date: 2020-09-27 17:55:36 LastEditTime: 2020-09-27 17:57:17 Description: https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/ FilePath: \\leetcode-googtech\\#1123. Lowest Common Ancestor of Deepest Leaves\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # DFS : 深度优先遍历 # 如果左右子树高度相等,则当前结点为要找的结点 # 否则要找的结点在高度较大的子树中,进而自底向上的计算高度并返回寻找到的结点 def lcaDeepestLeaves(self, root): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" def depth(node): if not node: return 0 leftDepth = depth(node.left) rightDepth = depth(node.right) return max(leftDepth, rightDepth) + 1 if not root: return None leftDepth = depth(root.left) rightDepth = depth(root.right) return root if leftDepth == rightDepth else self.lcaDeepestLeaves(root.left) if leftDepth > rightDepth else self.lcaDeepestLeaves(root.right) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1207.独一无二的出现次数/1207.独一无二的出现次数.html":{"url":"LeetCode刷题之旅及题目解析/1207.独一无二的出现次数/1207.独一无二的出现次数.html","title":"1207.独一无二的出现次数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1207. 独一无二的出现次数 Java Python @lc app=leetcode.cn id=1207 lang=python [1207] 独一无二的出现次数 @lc code=start 1207. 独一无二的出现次数 https://leetcode-cn.com/problems/unique-number-of-occurrences/ Java /* * @Author: Goog Tech * @Date: 2020-08-16 10:23:22 * @LastEditTime: 2020-08-16 10:38:07 * @Description: https://leetcode-cn.com/problems/unique-number-of-occurrences/ * @FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\1207.独一无二的出现次数.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1207 lang=java * * [1207] 独一无二的出现次数 */ // @lc code=start class Solution { public boolean uniqueOccurrences(int[] arr) { // 使用 Map 集合记录每个数值及其出现的次数 Map countMap = new HashMap<>(); // 记录每个数字出现的次数,数值作为键,其出现的次数作为值 for(int num : arr) { // getDefault: 不存在则返回0,否则返回键num对应的值并加一 countMap.put(num, countMap.getOrDefault(num, 0) + 1); } // 使用 Set 集合判断 Map 中键所对应的值是否右重复 Set set = new HashSet<>(); // 判断value是否有重复值 for(Integer value : countMap.values()) { // 若value值已存在,add方法则会返回false if(!set.add(value)) { return false; } } return true; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-16 10:33:02 LastEditTime: 2020-08-16 10:38:35 Description: https://leetcode-cn.com/problems/unique-number-of-occurrences/ FilePath: \\leetcode-googtech\\#102. Binary Tree Level Order Traversal\\1207.独一无二的出现次数.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1207 lang=python # # [1207] 独一无二的出现次数 # # @lc code=start class Solution(object): def uniqueOccurrences(self, arr): \"\"\" :type arr: List[int] :rtype: bool \"\"\" # 统计每个数值出现的次数 eleCounts = collections.Counter(arr) # 将统计结果去重,然后与原统计结果相比较 return len(set(eleCounts.values())) == len(eleCounts) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1221.分割平衡字符串/1221.分割平衡字符串.html":{"url":"LeetCode刷题之旅及题目解析/1221.分割平衡字符串/1221.分割平衡字符串.html","title":"1221.分割平衡字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1221. 分割平衡字符串 Java Python @lc app=leetcode.cn id=1221 lang=python [1221] 分割平衡字符串 @lc code=start 1221. 分割平衡字符串 https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 11:46:02 * @LastEditTime: 2020-08-15 11:58:35 * @Description: https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/ * @FilePath: \\leetcode-googtech\\#1221. Split a String in Balanced Strings\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1221 lang=java * * [1221] 分割平衡字符串 */ // @lc code=start class Solution { // 利用栈 public int balancedStringSplit(String s) { int result = 0; // 初始化辅助栈 Stack stack = new Stack<>(); // 遍历栈中字符串中的字符 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-15 11:54:14 LastEditTime: 2020-08-15 11:58:43 Description: https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/ FilePath: \\leetcode-googtech\\#1221. Split a String in Balanced Strings\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1221 lang=python # # [1221] 分割平衡字符串 # # @lc code=start class Solution(object): # 贪心算法 def balancedStringSplit(self, s): \"\"\" :type s: str :rtype: int \"\"\" balance, result = 0, 0 for ch in s: if ch == 'L': balance += 1 elif ch == 'R': balance -= 1 if balance == 0: result += 1 return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1281.整数的各位积和之差/1281.整数的各位积和之差.html":{"url":"LeetCode刷题之旅及题目解析/1281.整数的各位积和之差/1281.整数的各位积和之差.html","title":"1281.整数的各位积和之差","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1281. 整数的各位积和之差 Java Python @lc app=leetcode.cn id=1281 lang=python [1281] 整数的各位积和之差 @lc code=start 1281. 整数的各位积和之差 https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 21:10:15 * @LastEditTime: 2020-08-15 21:15:56 * @Description: https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/ * @FilePath: \\leetcode-googtech\\#1281. Subtract the Product and Sum of Digits of an Integer\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1281 lang=java * * [1281] 整数的各位积和之差 */ // @lc code=start class Solution { public int subtractProductAndSum(int n) { int p = 1, s = 0; // n % 10 即获取数值最后一位数字, n / 10 即删去数值的最后一位数字 while(n != 0) { p *= n % 10; s += n % 10; n /= 10; } return p - s; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-15 20:59:46 LastEditTime: 2020-08-15 21:15:09 Description: https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/ FilePath: \\leetcode-googtech\\#1281. Subtract the Product and Sum of Digits of an Integer\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1281 lang=python # # [1281] 整数的各位积和之差 # # @lc code=start class Solution(object): def subtractProductAndSum(self, n): \"\"\" :type n: int :rtype: int \"\"\" # 先将 n 转换为字符串类型,然后再其转换为列表类型并赋值给alist alist = list(str(n)) # 初始化乘积与和的值 p, s = 1, 0 # 遍历列表元素,将元素逐个转换为整型并求出乘积和与相加和 for element in alist: p *= int(element) s += int(element) # 返回结果 return p - s # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1290.二进制链表转整数/1290.二进制链表转整数.html":{"url":"LeetCode刷题之旅及题目解析/1290.二进制链表转整数/1290.二进制链表转整数.html","title":"1290.二进制链表转整数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1290. 二进制链表转整数 Java Python @lc app=leetcode.cn id=1290 lang=python [1290] 二进制链表转整数 @lc code=start 1290. 二进制链表转整数 https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 17:21:48 * @LastEditTime: 2020-08-14 17:27:42 * @Description: https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/ * @FilePath: \\leetcode-googtech\\#1290. Convert Binary Number in a Linked List to Integer\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1290 lang=java * * [1290] 二进制链表转整数 */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 二进制转换为十进制: 整数部分的数值依次乘以2的幂次并逐个相加 public int getDecimalValue(ListNode head) { int result = 0; while(head != null) { result = result * 2 + head.val; head = head.next; } return result; } } // @lc code=end Python ''' Author: Goog Tech Date: 2020-08-14 17:16:18 LastEditTime: 2020-08-14 17:27:49 Description: https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/ FilePath: \\leetcode-googtech\\#1290. Convert Binary Number in a Linked List to Integer\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1290 lang=python # # [1290] 二进制链表转整数 # # @lc code=start # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # 二进制转换为十进制: 整数部分的数值依次乘以2的幂次并逐个相加 def getDecimalValue(self, head): \"\"\" :type head: ListNode :rtype: int \"\"\" currentNode = head result = 0 while currentNode: result = result * 2 + currentNode.val currentNode = currentNode.next return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1295.统计位数为偶数的数字/1295.统计位数为偶数的数字.html":{"url":"LeetCode刷题之旅及题目解析/1295.统计位数为偶数的数字/1295.统计位数为偶数的数字.html","title":"1295.统计位数为偶数的数字","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1295. 统计位数为偶数的数字 Java Python 1295. 统计位数为偶数的数字 https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/ Java /* * @Author: Goog Tech * @Date: 2020-08-21 15:15:57 * @LastEditTime: 2020-08-21 15:16:19 * @Description: https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/ * @FilePath: \\leetcode-googtech\\#1295. Find Numbers with Even Number of Digits\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 先将整型数组中的元素逐个转换为字符串,然后计算每个字符串的长度即可 public int findNumbers(int[] nums) { int count = 0; for(int num : nums) count += String.valueOf(num).length() % 2 == 0 ? 1 : 0; return count; } } Python ''' Author: Goog Tech Date: 2020-08-21 15:16:04 LastEditTime: 2020-08-21 15:16:30 Description: https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/ FilePath: \\leetcode-googtech\\#1295. Find Numbers with Even Number of Digits\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 先将整型数组中的元素逐个转换为字符串,然后计算每个字符串的长度即可 def findNumbers(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" count = 0 for num in nums: if len(str(num)) % 2 == 0: count += 1 return count Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1299.将每个元素替换为右侧最大元素/1299.将每个元素替换为右侧最大元素.html":{"url":"LeetCode刷题之旅及题目解析/1299.将每个元素替换为右侧最大元素/1299.将每个元素替换为右侧最大元素.html","title":"1299.将每个元素替换为右侧最大元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1299. 将每个元素替换为右侧最大元素 Java Python 1299. 将每个元素替换为右侧最大元素 https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/ Java /* * @Author: Goog Tech * @Date: 2020-08-22 09:30:44 * @LastEditTime: 2020-08-22 09:31:02 * @Description: https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/ * @FilePath: \\leetcode-googtech\\#1299. Replace Elements with Greatest Element on Right Side\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int[] replaceElements(int[] arr) { // 初始化最大值 int max = -1; // 从后往前遍历数组元素 for(int i = arr.length - 1; i >= 0; i--) { // 定义一个临时变量用于跟踪最大值 int temp = arr[i]; // 将每个元素用它右边最大的元素替换 arr[i] = max; // 若当前元素大于最大值则重新初始化最大值 if(temp > max) { max = temp; } } // 返回结果数组 return arr; } } Python ''' Author: Goog Tech Date: 2020-08-22 09:30:51 LastEditTime: 2020-08-22 09:31:23 Description: https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/ FilePath: \\leetcode-googtech\\#1299. Replace Elements with Greatest Element on Right Side\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def replaceElements(self, arr): \"\"\" :type arr: List[int] :rtype: List[int] \"\"\" # 判断数组是否为空 if not arr: return 0 # 初始化结果数组 result = [] # 从后往前遍历数组元素 for i in range(len(arr) - 1): # 依次获取第i个下标元素之后的最大元素值,然后将其添加到结果数组中 maxValue = max(arr[i+1:]) result.append(maxValue) # 将-1作为结果数组的最后一个元素 result.append(-1) # 返回结果数组 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1302.层数最深叶子节点的和/1302.层数最深叶子节点的和.html":{"url":"LeetCode刷题之旅及题目解析/1302.层数最深叶子节点的和/1302.层数最深叶子节点的和.html","title":"1302.层数最深叶子节点的和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1302. 层数最深叶子节点的和 Java Python 1302. 层数最深叶子节点的和 https://leetcode-cn.com/problems/deepest-leaves-sum/ Java /* * @Author: Goog Tech * @Date: 2020-09-11 15:42:07 * @LastEditTime: 2020-09-11 15:42:32 * @Description: https://leetcode-cn.com/problems/deepest-leaves-sum/ * @FilePath: \\leetcode-googtech\\#1302. Deepest Leaves Sum\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 解题思路: 利用辅助队列进行深度优先搜索,每次将上一次结果清零. 解题步骤如下所示: // 1. 一层层地遍历二叉树中的节点,将其逐个存储到 queue 中,并计算出每层节点之和 // 2. 若还有下一层,则将存储在辅助队列中的上层节点全部清零 // 3. 最后一次遍历后所得到的 sum 既是最深叶子节点的和 public int deepestLeavesSum(TreeNode root) { // 判断根节点是否为空 if(root == null) return 0; // 初始化辅助队列,其用于存储二叉树中每层的节点 Queue queue = new LinkedList<>(); // 将根节点入队 queue.offer(root); // 初始化最深叶子节点的和 int sum = 0; // 判断当前辅助队列,即二叉树的下一层是否为空 while(!queue.isEmpty()) { // 若二叉树还有下一层,则重新初始化最深叶子节点的和 sum = 0; // 遍历存储在队列中的上层节点,并将其逐个出队 for(int i = queue.size(); i > 0; i--) { TreeNode currentNode = queue.poll(); // 记录当前层节点的和 sum += currentNode.val; // 将下一层节点入队 if(currentNode.left != null) queue.offer(currentNode.left); if(currentNode.right != null) queue.offer(currentNode.right); } } // 返回最深叶子节点的和 return sum; } } Python ''' Author: Goog Tech Date: 2020-09-11 15:42:12 LastEditTime: 2020-09-11 15:42:48 Description: https://leetcode-cn.com/problems/deepest-leaves-sum/ FilePath: \\leetcode-googtech\\#1302. Deepest Leaves Sum\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 维护两个全局变量 maxDepth 和 total # maxDepth 用于记录搜索到的节点的最大深度值, total 则用于记录层数最深的叶子节点的和 def __init__(self): self.total = 0 self.maxDepth = -1 # 深度优先遍历 # 从根节点开始进行搜索,在搜索的同时记录当前节点的深度 def deepestLeavesSum(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(node, depth): # 判断当前节点是否为空 if not node: return # 若当前节点的深度 depth 大于 maxDepth,则重新对两个全局变量进行初始化 if depth > self.maxDepth: self.maxDepth, self.total = depth, node.val # 若等于则将当前叶子节点 node 的权值累加到 total 中 # 若小于则忽略,进而继续进行深度搜索 elif depth == self.maxDepth: self.total += node.val # 对当前节点的左右子树继续进行深度遍历 dfs(node.left, depth + 1) dfs(node.right, depth + 1) # 传入二叉树的根节点及初始深度值 dfs(root, 0) # DFS 结束后,深度最大的叶子节点的权值之和即存储在 total 中 return self.total Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1305.两棵二叉搜索树中的所有元素/1305.两棵二叉搜索树中的所有元素.html":{"url":"LeetCode刷题之旅及题目解析/1305.两棵二叉搜索树中的所有元素/1305.两棵二叉搜索树中的所有元素.html","title":"1305.两棵二叉搜索树中的所有元素","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1305. 两棵二叉搜索树中的所有元素 Java Python 1305. 两棵二叉搜索树中的所有元素 https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/ Java /* * @Author: Goog Tech * @Date: 2020-09-10 17:19:58 * @LastEditTime: 2020-09-10 17:20:20 * @Description: https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/ * @FilePath: \\leetcode-googtech\\#1305. All Elements in Two Binary Search Trees\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { List result = new ArrayList<>(); public List getAllElements(TreeNode root1, TreeNode root2) { get(root1); get(root2); Collections.sort(result); return result; } // 利用递归对搜索二叉树进行中序遍历 // 利用搜索二叉树的特性,该递归算法返回树中所有节点值的升序序列 private void get(TreeNode root) { if(root != null) { result.add(root.val); get(root.left); get(root.right); } } } Python ''' Author: Goog Tech Date: 2020-09-10 17:20:02 LastEditTime: 2020-09-10 17:20:53 Description: https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/ FilePath: \\leetcode-googtech\\#1305. All Elements in Two Binary Search Trees\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归式中序遍历 + 双指针排序 def getAllElements(self, root1, root2): \"\"\" :type root1: TreeNode :type root2: TreeNode :rtype: List[int] \"\"\" # 分别获取两个搜索二叉树中的所有节点值 t1, t2 = self.sortTree(root1), self.sortTree(root2) # 初始化结果列表及双指针 result, p1, p2 = [], 0, 0 # 循环遍历两列表中的节点值 while p1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1309.解码字母到整数映射/1309.解码字母到整数映射.html":{"url":"LeetCode刷题之旅及题目解析/1309.解码字母到整数映射/1309.解码字母到整数映射.html","title":"1309.解码字母到整数映射","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1309. 解码字母到整数映射 Java Python 1309. 解码字母到整数映射 https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 15:51:55 * @LastEditTime: 2020-08-29 15:52:08 * @Description: https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/ * @FilePath: \\leetcode-googtech\\#1309. Decrypt String from Alphabet to Integer Mapping\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public String freqAlphabets(String s) { StringBuilder sb = new StringBuilder(); int i = 0; // 循环遍历字符串 while(i Python ''' Author: Goog Tech Date: 2020-08-29 15:51:59 LastEditTime: 2020-08-29 15:52:29 Description: https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/ FilePath: \\leetcode-googtech\\#1309. Decrypt String from Alphabet to Integer Mapping\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def freqAlphabets(self, s): \"\"\" :type s: str :rtype: str \"\"\" # 初始化字符串指针,字符串长度,结果列表 i, length, result = 0, len(s), [] # 循环遍历字符串 while i Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1315.祖父节点值为偶数的节点和/1315.祖父节点值为偶数的节点和.html":{"url":"LeetCode刷题之旅及题目解析/1315.祖父节点值为偶数的节点和/1315.祖父节点值为偶数的节点和.html","title":"1315.祖父节点值为偶数的节点和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1315. 祖父节点值为偶数的节点和 Java Python 1315. 祖父节点值为偶数的节点和 https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/ Java /* * @Author: Goog Tech * @Date: 2020-09-15 10:53:49 * @LastEditTime: 2020-09-15 10:54:29 * @Description: https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/ * @FilePath: \\leetcode-googtech\\#1315. Sum of Nodes with Even-Valued Grandparent\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // DFS : 深度优先遍历 public int sumEvenGrandparent(TreeNode root) { return dfs(root, -1, -1); } private int dfs(TreeNode node, int parent, int grandparent) { if(node == null) return 0; int result = 0; if(grandparent % 2 == 0) result += node.val; result += dfs(node.left, node.val, parent); result += dfs(node.right, node.val, parent); return result; } } Python ''' Author: Goog Tech Date: 2020-09-15 10:53:53 LastEditTime: 2020-09-15 10:54:21 Description: https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/ FilePath: \\leetcode-googtech\\#1315. Sum of Nodes with Even-Valued Grandparent\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # DFS : 深度优先遍历 def sumEvenGrandparent(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(node, parent, grandparent): if not node: return 0 result = 0 if grandparent % 2 == 0: result += node.val result += dfs(node.left, node.val, parent) result += dfs(node.right, node.val, parent) return result return dfs(root, -1, -1) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1323.6和9组成的最大数字/1323.6和9组成的最大数字.html":{"url":"LeetCode刷题之旅及题目解析/1323.6和9组成的最大数字/1323.6和9组成的最大数字.html","title":"1323.6和9组成的最大数字","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1323. 6 和 9 组成的最大数字 Java Python 1323. 6 和 9 组成的最大数字 https://leetcode-cn.com/problems/maximum-69-number/ Java /* * @Author: Goog Tech * @Date: 2020-08-21 17:41:16 * @LastEditTime: 2020-08-21 17:41:59 * @Description: https://leetcode-cn.com/problems/maximum-69-number/ * @FilePath: \\leetcode-googtech\\#1323. Maximum 69 Number\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int maximum69Number (int num) { return Integer.valueOf(String.valueOf(num).replaceFirst(\"6\", \"9\")); } } Python ''' Author: Goog Tech Date: 2020-08-21 17:41:24 LastEditTime: 2020-08-21 17:41:49 Description: https://leetcode-cn.com/problems/maximum-69-number/ FilePath: \\leetcode-googtech\\#1323. Maximum 69 Number\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def maximum69Number (self, num): \"\"\" :type num: int :rtype: int \"\"\" return int(str(num).replace(\"6\", \"9\", 1)) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1332.删除回文子序列/1332.删除回文子序列.html":{"url":"LeetCode刷题之旅及题目解析/1332.删除回文子序列/1332.删除回文子序列.html","title":"1332.删除回文子序列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1332. 删除回文子序列 Java Python 1332. 删除回文子序列 https://leetcode-cn.com/problems/remove-palindromic-subsequences/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 17:22:24 * @LastEditTime: 2020-08-29 17:22:39 * @Description: https://leetcode-cn.com/problems/remove-palindromic-subsequences/ * @FilePath: \\leetcode-googtech\\#1332. Remove Palindromic Subsequences\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 1.空字符串 删除 0 次 // 2.回文字符窜 删除 1 次 // 3.非回文字符串 删除 2 次 (一次删除全部a , 一次删除全部b) // 注: 回文子序列不是回文子字符串,比如\"aababdaba\",其中\"aaaaa\"就是它的回文子序列 public int removePalindromeSub(String s) { if(\"\".equals(s)) return 0; return s.equals(new StringBuilder(s).reverse().toString()) == true ? 1 : 2; } } Python ''' Author: Goog Tech Date: 2020-08-29 17:22:29 LastEditTime: 2020-08-29 17:24:35 Description: https://leetcode-cn.com/problems/remove-palindromic-subsequences/ FilePath: \\leetcode-googtech\\#1332. Remove Palindromic Subsequences\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 1.空字符串 删除 0 次 # 2.回文字符窜 删除 1 次 # 3.非回文字符串 删除 2 次 (一次删除全部a , 一次删除全部b) # 注: 回文子序列不是回文子字符串,比如\"aababdaba\",其中\"aaaaa\"就是它的回文子序列 def removePalindromeSub(self, s): \"\"\" :type s: str :rtype: int \"\"\" return 0 if not s else 1 if s[::-1] == s else 2 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1342.将数字变成0的操作次数/1342.将数字变成0的操作次数.html":{"url":"LeetCode刷题之旅及题目解析/1342.将数字变成0的操作次数/1342.将数字变成0的操作次数.html","title":"1342.将数字变成 0 的操作次数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1342. 将数字变成 0 的操作次数 Java Python 1342. 将数字变成 0 的操作次数 https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/ Java /* * @Author: Goog Tech * @Date: 2020-08-21 15:00:22 * @LastEditTime: 2020-08-21 15:00:39 * @Description: https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/ * @FilePath: \\leetcode-googtech\\#1342. Number of Steps to Reduce a Number to Zero\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int numberOfSteps (int num) { int steps = 0; while(num > 0) { num = num % 2 == 0 ? num / 2 : num - 1; steps++; } return steps; } } Python ''' Author: Goog Tech Date: 2020-08-21 15:00:28 LastEditTime: 2020-08-21 15:00:57 Description: https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/ FilePath: \\leetcode-googtech\\#1342. Number of Steps to Reduce a Number to Zero\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def numberOfSteps (self, num): \"\"\" :type num: int :rtype: int \"\"\" steps = 0 while num > 0: num = num / 2 if num % 2 == 0 else num - 1 steps += 1 return steps Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1374.生成每种字符都是奇数个的字符串/1374.生成每种字符都是奇数个的字符串.html":{"url":"LeetCode刷题之旅及题目解析/1374.生成每种字符都是奇数个的字符串/1374.生成每种字符都是奇数个的字符串.html","title":"1374.生成每种字符都是奇数个的字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1374. 生成每种字符都是奇数个的字符串 Java Python 1374. 生成每种字符都是奇数个的字符串 https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 16:02:28 * @LastEditTime: 2020-08-29 16:02:51 * @Description: https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/ * @FilePath: \\leetcode-googtech\\#1374. Generate a String With Characters That Have Odd Counts\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public String generateTheString(int n) { StringBuilder sb = new StringBuilder(); if(n % 2 == 0) { sb.append('a'); n--; } for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-29 16:02:32 LastEditTime: 2020-08-29 16:02:44 Description: https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/ FilePath: \\leetcode-googtech\\#1374. Generate a String With Characters That Have Odd Counts\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def generateTheString(self, n): \"\"\" :type n: int :rtype: str \"\"\" return \"a\" * n if n % 2 != 0 else \"a\" * (n - 1) + \"b\"; Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1381.设计一个支持增量操作的栈/1381.设计一个支持增量操作的栈.html":{"url":"LeetCode刷题之旅及题目解析/1381.设计一个支持增量操作的栈/1381.设计一个支持增量操作的栈.html","title":"1381.设计一个支持增量操作的栈","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1381. 设计一个支持增量操作的栈 Java Python 1381. 设计一个支持增量操作的栈 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/ Java /* * @Author: Goog Tech * @Date: 2020-09-02 21:59:27 * @LastEditTime: 2020-09-02 21:59:46 * @Description: https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/ * @FilePath: \\leetcode-googtech\\#1381. Design a Stack With Increment Operation\\Solution.java * @WebSite: https://algorithm.show/ */ // 使用数组模拟栈结构 class CustomStack { int[] stack; int index; public CustomStack(int maxSize) { stack = new int[maxSize]; index = -1; } public void push(int x) { if(index == stack.length - 1) return; stack[++index] = x; } public int pop() { return index == -1 ? -1 : stack[index--]; } public void increment(int k, int val) { for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-02 21:59:31 LastEditTime: 2020-09-02 22:00:04 Description: https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/ FilePath: \\leetcode-googtech\\#1381. Design a Stack With Increment Operation\\Solution.py WebSite: https://algorithm.show/ ''' class CustomStack(object): def __init__(self, maxSize): \"\"\" :type maxSize: int \"\"\" self.stack = [] * maxSize self.maxSize = maxSize def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" if len(self.stack) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1436.旅行终点站/1436.旅行终点站.html":{"url":"LeetCode刷题之旅及题目解析/1436.旅行终点站/1436.旅行终点站.html","title":"1436.旅行终点站","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1436. 旅行终点站 Java Python 1436. 旅行终点站 https://leetcode-cn.com/problems/destination-city/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 11:53:34 * @LastEditTime: 2020-08-29 11:53:52 * @Description: https://leetcode-cn.com/problems/destination-city/ * @FilePath: \\leetcode-googtech\\#1436. Destination City\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public String destCity(List> paths) { // 初始化用于存储起点名称的 HashSet 集合 HashSet startStops = new HashSet<>(); // 循环遍历旅行线路集合,获取每个路径的起点名 for(List path : paths) { startStops.add(path.get(0)); } // 再次遍历旅行线路集合,获取每个路径的终点名 for(List path : paths) { String dest = path.get(1); // 若起点名集合中不包含该终点名,则说明该点就是旅行终点站 if(!startStops.contains(dest)) { return dest; } } // 无果 return \"\"; } } Python ''' Author: Goog Tech Date: 2020-08-29 11:53:45 LastEditTime: 2020-08-29 11:54:09 Description: https://leetcode-cn.com/problems/destination-city/ FilePath: \\leetcode-googtech\\#1436. Destination City\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def destCity(self, paths): \"\"\" :type paths: List[List[str]] :rtype: str \"\"\" # 初始化用于存储起点与终点名称的列表 start, end = [], [] # 遍历旅行线路集合,分别将起点与终点名存储到列表中 for path in paths: start.append(path[0]) end.append(path[1]) # 遍历终点名称列表 for des in end: # 逐个判断当前终点名是否被包含在起点名称列表中 if des not in start: # 若不包含则说明该点就是旅行终点站 return des Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1441.用栈操作构建数组/1441.用栈操作构建数组.html":{"url":"LeetCode刷题之旅及题目解析/1441.用栈操作构建数组/1441.用栈操作构建数组.html","title":"1441.用栈操作构建数组","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1441. 用栈操作构建数组 Java Python 1441. 用栈操作构建数组 https://leetcode-cn.com/problems/build-an-array-with-stack-operations/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 20:10:12 * @LastEditTime: 2020-09-01 20:10:32 * @Description: https://leetcode-cn.com/problems/build-an-array-with-stack-operations/ * @FilePath: \\leetcode-googtech\\#1441. Build an Array With Stack Operations\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public List buildArray(int[] target, int n) { // 初始化结果列表 List result = new LinkedList<>(); // 初始化数组下标 int i = 0; // 遍历 1 到 N 之间所有的数值 for(int j = 1; j Python ''' Author: Goog Tech Date: 2020-09-01 20:10:17 LastEditTime: 2020-09-01 20:10:39 Description: https://leetcode-cn.com/problems/build-an-array-with-stack-operations/ FilePath: \\leetcode-googtech\\#1441. Build an Array With Stack Operations\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def buildArray(self, target, n): \"\"\" :type target: List[int] :type n: int :rtype: List[str] \"\"\" # 初始化结果列表 result = [] # 遍历 1 到 n 之间所有的数值 for num in range(1, target[-1] + 1): # 将 Push 字符存储到结果列表中 result.append('Push') # 若当前数值 num 在数组 target 不存在,则说明数组中缺失数值 num if num not in target: # 进而将 Pop 字符添加到结果列表中 result.append('Pop') # 返回结果列表 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1448.统计二叉树中好节点的数目/1448.统计二叉树中好节点的数目.html":{"url":"LeetCode刷题之旅及题目解析/1448.统计二叉树中好节点的数目/1448.统计二叉树中好节点的数目.html","title":"1448.统计二叉树中好节点的数目","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1448. 统计二叉树中好节点的数目 Java Python 1448. 统计二叉树中好节点的数目 https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/ Java /* * @Author: Goog Tech * @Date: 2020-09-23 21:53:11 * @LastEditTime: 2020-09-23 21:54:08 * @Description: https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/ * @FilePath: \\leetcode-googtech\\#1448. Count Good Nodes in Binary Tree\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private int result = 0; // DFS : 深度优先搜索 public int goodNodes(TreeNode root) { dfs(root, root.val); return result; } private void dfs(TreeNode node, int max) { if(node == null) return; if(node.val >= max) { max = node.val; result++; } dfs(node.left, max); dfs(node.right, max); } } Python ''' Author: Goog Tech Date: 2020-09-23 21:53:15 LastEditTime: 2020-09-23 21:54:24 Description: https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/ FilePath: \\leetcode-googtech\\#1448. Count Good Nodes in Binary Tree\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): # DFS : 深度优先遍历 def goodNodes(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" self.result = 0 def dfs(node, maxValue): if not node: return if node.val >= maxValue: maxValue = node.val self.result += 1 dfs(node.left, maxValue) dfs(node.right, maxValue) dfs(root, float('-inf')) return self.result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1455.检查单词是否为句中其他单词的前缀/1455.检查单词是否为句中其他单词的前缀.html":{"url":"LeetCode刷题之旅及题目解析/1455.检查单词是否为句中其他单词的前缀/1455.检查单词是否为句中其他单词的前缀.html","title":"1455.检查单词是否为句中其他单词的前缀","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1455. 检查单词是否为句中其他单词的前缀 Java Python 1455. 检查单词是否为句中其他单词的前缀 https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 17:48:14 * @LastEditTime: 2020-08-29 17:48:33 * @Description: https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/ * @FilePath: \\leetcode-googtech\\#1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int isPrefixOfWord(String sentence, String searchWord) { // 切割字符串并将其转化为字符数组 String[] strs = sentence.split(\" \"); // 获取检索词的长度 int length = searchWord.length(); // 遍历字符数组 for(int i = 0; i = length && strs[i].substring(0, length).equals(searchWord)) { // 若相同则返回句子 sentence 中该单词所对应的下标(下标从 1 开始) return i + 1; } } // 无果 return -1; } } Python ''' Author: Goog Tech Date: 2020-08-29 17:48:18 LastEditTime: 2020-08-29 17:48:41 Description: https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/ FilePath: \\leetcode-googtech\\#1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def isPrefixOfWord(self, sentence, searchWord): \"\"\" :type sentence: str :type searchWord: str :rtype: int \"\"\" # 切割字符串并将其转化为字符数组 words = sentence.split(' ') # 遍历字符数组 for i in range(len(words)): # 判断当前字符元素的长度是否大于检索词的长度,并且切割后的字符元素是否与检索词相同 if len(words[i]) >= len(searchWord) and words[i][0 : len(searchWord)] == searchWord: # 若相同则返回句子 sentence 中该单词所对应的下标(下标从 1 开始) return i + 1 # 无果 return -1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1464.数组中两元素的最大乘积/1464.数组中两元素的最大乘积.html":{"url":"LeetCode刷题之旅及题目解析/1464.数组中两元素的最大乘积/1464.数组中两元素的最大乘积.html","title":"1464.数组中两元素的最大乘积","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1464. 数组中两元素的最大乘积 Java Python 1464. 数组中两元素的最大乘积 https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 14:44:31 * @LastEditTime: 2020-08-15 14:45:04 * @Description: https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/ * @FilePath: \\leetcode-googtech\\#1464. Maximum Product of Two Elements in an Array\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int maxProduct(int[] nums) { Arrays.sort(nums); return (nums[nums.length - 1] - 1) * (nums[nums.length - 2] - 1); } } Python ''' Author: Goog Tech Date: 2020-08-15 14:44:38 LastEditTime: 2020-08-15 14:45:11 Description: https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/ FilePath: \\leetcode-googtech\\#1464. Maximum Product of Two Elements in an Array\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def maxProduct(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums.sort() return (nums[len(nums) - 1] - 1) * (nums[len(nums) - 2] - 1) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1470.重新排列数组/1470.重新排列数组.html":{"url":"LeetCode刷题之旅及题目解析/1470.重新排列数组/1470.重新排列数组.html","title":"1470.重新排列数组","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1470. 重新排列数组 Java Python 1470. 重新排列数组 https://leetcode-cn.com/problems/shuffle-the-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 21:57:50 * @LastEditTime: 2020-08-15 21:58:08 * @Description: https://leetcode-cn.com/problems/shuffle-the-array/ * @FilePath: \\leetcode-googtech\\#1470. Shuffle the Array\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int[] shuffle(int[] nums, int n) { if(nums.length == 2) return nums; int[] result = new int[n Python ''' Author: Goog Tech Date: 2020-08-15 21:57:56 LastEditTime: 2020-08-15 21:59:18 Description: https://leetcode-cn.com/problems/shuffle-the-array/ FilePath: \\leetcode-googtech\\#1470. Shuffle the Array\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def shuffle(self, nums, n): \"\"\" :type nums: List[int] :type n: int :rtype: List[int] \"\"\" nums1, nums2, nums3 = nums[:n], nums[n:], [] for i in range(n): nums3.append(nums1[i]) nums3.append(nums2[i]) return nums3 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1480.一维数组的动态和/1480.一维数组的动态和.html":{"url":"LeetCode刷题之旅及题目解析/1480.一维数组的动态和/1480.一维数组的动态和.html","title":"1480.一维数组的动态和","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1480. 一维数组的动态和 Java Python @lc app=leetcode.cn id=1480 lang=python [1480] 一维数组的动态和 @lc code=start 1480. 一维数组的动态和 https://leetcode-cn.com/problems/running-sum-of-1d-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 12:12:07 * @LastEditTime: 2020-08-15 12:16:24 * @Description: https://leetcode-cn.com/problems/running-sum-of-1d-array/ * @FilePath: \\leetcode-googtech\\#1480. Running Sum of 1d Array\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1480 lang=java * * [1480] 一维数组的动态和 */ // @lc code=start class Solution { // 双指针法 public int[] runningSum(int[] nums) { for(int i = 0, j = 0; j Python ''' Author: Goog Tech Date: 2020-08-15 12:03:38 LastEditTime: 2020-08-15 12:16:49 Description: https://leetcode-cn.com/problems/running-sum-of-1d-array/ FilePath: \\leetcode-googtech\\#1480. Running Sum of 1d Array\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1480 lang=python # # [1480] 一维数组的动态和 # # @lc code=start class Solution(object): # 动态规划法 def runningSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" # 从第二个元素开始遍历数组, 即当前位置等于当前位置的值加上上一个位置的值 for i in range(1, len(nums)): nums[i] = nums[i - 1] + nums[i] return nums # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1486.数组异或操作/1486.数组异或操作.html":{"url":"LeetCode刷题之旅及题目解析/1486.数组异或操作/1486.数组异或操作.html","title":"1486.数组异或操作","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1486. 数组异或操作 Java Python @lc app=leetcode.cn id=1486 lang=python [1486] 数组异或操作 @lc code=start 1486. 数组异或操作 https://leetcode-cn.com/problems/xor-operation-in-an-array/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 21:24:49 * @LastEditTime: 2020-08-15 21:32:09 * @Description: https://leetcode-cn.com/problems/xor-operation-in-an-array/ * @FilePath: \\leetcode-googtech\\#1486. XOR Operation in an Array\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1486 lang=java * * [1486] 数组异或操作 */ // @lc code=start class Solution { public int xorOperation(int n, int start) { int result = 0; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-15 21:26:33 LastEditTime: 2020-08-15 21:32:16 Description: https://leetcode-cn.com/problems/xor-operation-in-an-array/ FilePath: \\leetcode-googtech\\#1486. XOR Operation in an Array\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1486 lang=python # # [1486] 数组异或操作 # # @lc code=start class Solution(object): def xorOperation(self, n, start): \"\"\" :type n: int :type start: int :rtype: int \"\"\" result = 0 for i in range(n): result ^= (start + 2 * i); return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1491.去掉最低工资和最高工资后的工资平均值/1491.去掉最低工资和最高工资后的工资平均值.html":{"url":"LeetCode刷题之旅及题目解析/1491.去掉最低工资和最高工资后的工资平均值/1491.去掉最低工资和最高工资后的工资平均值.html","title":"1491.去掉最低工资和最高工资后的工资平均值","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1491. 去掉最低工资和最高工资后的工资平均值 Java Python 1491. 去掉最低工资和最高工资后的工资平均值 https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/ Java /* * @Author: Goog Tech * @Date: 2020-07-22 17:09:50 * @Description: https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/ * @FilePath: \\leetcode-googtech\\#1491. Average Salary Excluding the Minimum and Maximum Salary\\Solution.java */ class Solution { public double average(final int[] salary) { double min = salary[0]; double max = salary[0]; double sum = 0.0; // 遍历相加数组中的元素,并找出最值 for(int i = 0;i Python ''' @Author: Goog Tech @Date: 2020-07-22 17:10:01 @Description: https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/ @FilePath: \\leetcode-googtech\\#1491. Average Salary Excluding the Minimum and Maximum Salary\\Solution.py ''' class Solution(object): def average(self, salary): \"\"\" :type salary: List[int] :rtype: float \"\"\" maxValue = max(salary) minValue = min(salary) total = sum(salary) - maxValue - minValue return total / (len(salary)-2.0) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1502.判断能否形成等差数列/1502.判断能否形成等差数列.html":{"url":"LeetCode刷题之旅及题目解析/1502.判断能否形成等差数列/1502.判断能否形成等差数列.html","title":"1502.判断能否形成等差数列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1502. 判断能否形成等差数列 Java Python @lc app=leetcode.cn id=1502 lang=python [1502] 判断能否形成等差数列 @lc code=start 1502. 判断能否形成等差数列 https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 08:52:53 * @LastEditTime: 2020-08-15 08:55:56 * @Description: https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/ * @FilePath: \\leetcode-googtech\\#1502. Can Make Arithmetic Progression From Sequence\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1502 lang=java * * [1502] 判断能否形成等差数列 */ // @lc code=start class Solution { // 对原序列排序后,若其元素满足 An x 2 = An-1 + An+1 则判定其为等差数列 public boolean canMakeArithmeticProgression(int[] arr) { Arrays.sort(arr); for(int i = 1; i Python ''' Author: Goog Tech Date: 2020-08-15 08:45:00 LastEditTime: 2020-08-15 09:01:59 Description: https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/ FilePath: \\leetcode-googtech\\#1502. Can Make Arithmetic Progression From Sequence\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1502 lang=python # # [1502] 判断能否形成等差数列 # # @lc code=start class Solution(object): # 对原序列排序后,若其元素满足 An x 2 = An-1 + An+1 则判定其为等差数列 def canMakeArithmeticProgression(self, arr): \"\"\" :type arr: List[int] :rtype: bool \"\"\" arr.sort() for i in range(1, len(arr) - 1): if arr[i] * 2 != arr[i - 1] + arr[i + 1]: return False return True # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1512.好数对的数目/1512.好数对的数目.html":{"url":"LeetCode刷题之旅及题目解析/1512.好数对的数目/1512.好数对的数目.html","title":"1512.好数对的数目","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1512. 好数对的数目 Java Python @lc app=leetcode.cn id=1512 lang=python [1512] 好数对的数目 @lc code=start 1512. 好数对的数目 https://leetcode-cn.com/problems/number-of-good-pairs/ Java /* * @Author: Goog Tech * @Date: 2020-08-15 20:22:57 * @LastEditTime: 2020-08-15 20:29:21 * @Description: https://leetcode-cn.com/problems/number-of-good-pairs/ * @FilePath: \\leetcode-googtech\\#1512. Number of Good Pairs\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=1512 lang=java * * [1512] 好数对的数目 */ // @lc code=start class Solution { public int numIdenticalPairs(int[] nums) { int result = 0; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-15 20:25:55 LastEditTime: 2020-08-15 20:29:12 Description: https://leetcode-cn.com/problems/number-of-good-pairs/ FilePath: \\leetcode-googtech\\#1512. Number of Good Pairs\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=1512 lang=python # # [1512] 好数对的数目 # # @lc code=start class Solution(object): def numIdenticalPairs(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" result = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] == nums[j]: result += 1 return result # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1518.换酒问题/1518.换酒问题.html":{"url":"LeetCode刷题之旅及题目解析/1518.换酒问题/1518.换酒问题.html","title":"1518.换酒问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1518. 换酒问题 Java Python 1518. 换酒问题 https://leetcode-cn.com/problems/water-bottles/ Java /* * @Author: Goog Tech * @Date: 2020-09-02 21:55:37 * @LastEditTime: 2020-09-02 21:55:43 * @Description: https://leetcode-cn.com/problems/water-bottles/ * @FilePath: \\leetcode-googtech\\#1518. Water Bottles\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public int numWaterBottles(int numBottles, int numExchange) { int emptyBottles = numBottles; while(emptyBottles >= numExchange) { numBottles = numBottles + emptyBottles / numExchange; emptyBottles = emptyBottles / numExchange + emptyBottles % numExchange; } return numBottles; } } Python class Solution(object): def numWaterBottles(self, numBottles, numExchange): \"\"\" :type numBottles: int :type numExchange: int :rtype: int \"\"\" ''' 待解. . . ''' Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1528.重新排列字符串/1528.重新排列字符串.html":{"url":"LeetCode刷题之旅及题目解析/1528.重新排列字符串/1528.重新排列字符串.html","title":"1528.重新排列字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1528. 重新排列字符串 Java Python @lc app=leetcode.cn id=5472 lang=python [5472] 重新排列字符串 @lc code=start 1528. 重新排列字符串 https://leetcode-cn.com/problems/shuffle-string/ Java /* * @Author: Goog Tech * @Date: 2020-08-14 13:47:08 * @LastEditTime: 2020-08-14 13:54:14 * @Description: https://leetcode-cn.com/problems/shuffle-string/ * @FilePath: \\leetcode-googtech\\#1528. Shuffle String\\Solution.java * @WebSite: https://algorithm.show/ */ /* * @lc app=leetcode.cn id=5472 lang=java * * [5472] 重新排列字符串 */ // @lc code=start class Solution { public String restoreString(String s, int[] indices) { // 创建一个与字符串相同长度的数组 int length = s.length(); char[] result = new char[length]; // 循环填充数组,其中indices[i]作为索引,s.charAt(i)作为索引值 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-14 13:24:04 LastEditTime: 2020-08-14 13:54:33 Description: https://leetcode-cn.com/problems/shuffle-string/ FilePath: \\leetcode-googtech\\#1528. Shuffle String\\Solution.py WebSite: https://algorithm.show/ ''' # # @lc app=leetcode.cn id=5472 lang=python # # [5472] 重新排列字符串 # # @lc code=start class Solution(object): def restoreString(self, s, indices): \"\"\" :type s: str :type indices: List[int] :rtype: str \"\"\" # 创建一个长度为len(s)的数组 result = [\"\" for i in range(len(s))] # 循环填充数组,其中indices[i]作为索引,s[i]作为索引值 for i in range(len(s)): result[indices[i]] = s[i] # 将数组转换为字符串并返回 return \"\".join(result) # @lc code=end Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1544.整理字符串/1544.整理字符串.html":{"url":"LeetCode刷题之旅及题目解析/1544.整理字符串/1544.整理字符串.html","title":"1544.整理字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1544. 整理字符串 Java Python 1544. 整理字符串 https://leetcode-cn.com/problems/make-the-string-great/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 23:41:35 * @LastEditTime: 2020-09-01 23:41:53 * @Description: https://leetcode-cn.com/problems/make-the-string-great/ * @FilePath: \\leetcode-googtech\\#1544. Make The String Great\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public String makeGood(String s) { // 若当前字符串仅有一个字符则直接返回其本身即可 if(s.length() == 1) return s; // 初始化辅助栈 Stack stack = new Stack<>(); // 将字符串中第一个字符压入栈中 stack.push(s.charAt(0)); // 逐个遍历字符串中的字符 for(int i = 1; i Python ''' Author: Goog Tech Date: 2020-09-01 23:41:39 LastEditTime: 2020-09-01 23:42:04 Description: https://leetcode-cn.com/problems/make-the-string-great/ FilePath: \\leetcode-googtech\\#1544. Make The String Great\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def makeGood(self, s): \"\"\" :type s: str :rtype: str \"\"\" # 初始化辅助栈 stack = [] # 逐个遍历字符串中的字符 for ch in s: # 判断栈是否为空,或当前字符与栈顶元素是否为相同字母( 相同字母大小写的 ASCII 码相差 32 ) if not stack or abs(ord(stack[-1]) - ord(ch)) != 32: # 若满足条件则将当前字母压入栈中 stack.append(ch) # 反之则弹出栈顶元素 else: stack.pop() # 逐个遍历栈中元素并将其转换为字符串,最后其返回结果 return \"\".join(ch for ch in stack) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"LeetCode刷题之旅及题目解析/1557.可以到达所有点的最少点数目/1557.可以到达所有点的最少点数目.html":{"url":"LeetCode刷题之旅及题目解析/1557.可以到达所有点的最少点数目/1557.可以到达所有点的最少点数目.html","title":"1557.可以到达所有点的最少点数目","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1557. 可以到达所有点的最少点数目 Java Python 1557. 可以到达所有点的最少点数目 https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes/ Java /* * @Author: Goog Tech * @Date: 2020-09-15 16:12:07 * @LastEditTime: 2020-09-15 16:12:27 * @Description: https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes/ * @FilePath: \\leetcode-googtech\\#1557. Minimum Number of Vertices to Reach All Nodes\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 图数据结构 // 解题思路 : 遍历所有的边,使用集合存储所有有向边的终点, // 集合中的所有节点即为入度不为零的节点,剩下的所有节点即为入度为零,即没有前驱的节点. public List findSmallestSetOfVertices(int n, List> edges) { List resultList = new ArrayList<>(); Set endingSet = new HashSet<>(); for(List edge : edges) endingSet.add(edge.get(1)); for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-15 16:12:13 LastEditTime: 2020-09-15 16:12:39 Description: https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes/ FilePath: \\leetcode-googtech\\#1557. Minimum Number of Vertices to Reach All Nodes\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 图数据结构 # 解题思路 : 遍历所有的边,使用集合存储所有有向边的终点, # 集合中的所有节点即为入度不为零的节点,剩下的所有节点即为入度为零,即没有前驱的节点. def findSmallestSetOfVertices(self, n, edges): \"\"\" :type n: int :type edges: List[List[int]] :rtype: List[int] \"\"\" endingSet = set(y for x, y in edges) return [i for i in range(n) if i not in endingSet] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/":{"url":"面试题/","title":"面试题","keywords":"","body":" 📝 面试题目 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题01/":{"url":"面试题/面试题01/","title":"面试题01","keywords":"","body":" 📝 面试题01 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题01/02.判定是否互为字符重排/02.判定是否互为字符重排.html":{"url":"面试题/面试题01/02.判定是否互为字符重排/02.判定是否互为字符重排.html","title":"02.判定是否互为字符重排","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 2. 判定是否互为字符重排 Java Python 02. 判定是否互为字符重排 https://leetcode-cn.com/problems/check-permutation-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-08-29 16:59:28 * @LastEditTime: 2020-08-29 16:59:55 * @Description: https://leetcode-cn.com/problems/check-permutation-lcci/ * @FilePath: \\leetcode-googtech\\面试题01\\#02. 判定是否互为字符重排\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { public boolean CheckPermutation(String s1, String s2) { if(s1 == s2) return true; if(s1 == null || s2 == null || s1.length() != s2.length()) return false; char[] c1 = s1.toCharArray(); char[] c2 = s2.toCharArray(); Arrays.sort(c1); Arrays.sort(c2); for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-29 16:59:34 LastEditTime: 2020-08-29 16:59:48 Description: https://leetcode-cn.com/problems/check-permutation-lcci/ FilePath: \\leetcode-googtech\\面试题01\\#02. 判定是否互为字符重排\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def CheckPermutation(self, s1, s2): \"\"\" :type s1: str :type s2: str :rtype: bool \"\"\" return len(s1) == len(s2) and set(s1) == set(s2) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题02/":{"url":"面试题/面试题02/","title":"面试题02","keywords":"","body":" 📝 面试题02 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题02/01.移除重复节点/01.移除重复节点.html":{"url":"面试题/面试题02/01.移除重复节点/01.移除重复节点.html","title":"01.移除重复节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 移除重复节点 Java Python 01. 移除重复节点 https://leetcode-cn.com/problems/remove-duplicate-node-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-08-31 14:02:08 * @LastEditTime: 2020-08-31 14:02:46 * @Description: https://leetcode-cn.com/problems/remove-duplicate-node-lcci/ * @FilePath: \\leetcode-googtech\\面试题02\\#01. 移除重复节点\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeDuplicateNodes(ListNode head) { // 判断头节点是否为空 if(head == null) return null; // 为了移动指针时不破坏链表结构,初始化虚拟头节点以及 pre 哨兵节点 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode pre = dummyHead; // 通过移动 pre 节点指针循环遍历链表 while(pre.next != null) { // 获取 pre 哨兵节点的下一个节点 ListNode currentNode = pre.next; // 通过移动 currentNode 节点指针循环遍历链表 while(currentNode.next != null) { // 若当前 pre 的节点值与其后的 currentNode 节点的值相同, // 则将 currentNode 节点指针指向其后的第二个节点,即删除 currentNode 的后一个节点 if(pre.next.val == currentNode.next.val) { currentNode.next = currentNode.next.next; // 反之继续向后移动 currentNode 节点指针,继续寻找重复元素 }else { currentNode = currentNode.next; } } // 向后移动 pre 指针节点,继续判断 pre.next 节点是否与其下一个节点 currentNode.next 的值相同 pre = pre.next; } // 返回移除重复元素后的链表头节点 return dummyHead.next; } } Python ''' Author: Goog Tech Date: 2020-08-31 14:02:17 LastEditTime: 2020-08-31 14:03:04 Description: https://leetcode-cn.com/problems/remove-duplicate-node-lcci/ FilePath: \\leetcode-googtech\\面试题02\\#01. 移除重复节点\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def removeDuplicateNodes(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 初始化 hashSet 集合 hashSet = set() # 为了移动指针时不破坏链表结构,初始化虚拟头节点以及 prev 哨兵节点 prev = ListNode(-1) prev.next = head # 循环遍历链表 while prev.next: # 若遇到重复值则将当前节点 prev 的 next 指向 next.next,即删除其后的节点 if prev.next.val in hashSet: prev.next = prev.next.next # 反之利用 set 储存已有的节点值,并继续向后移动 prev 节点指针,寻找重复值 else: hashSet.add(prev.next.val) prev = prev.next # 返回移除重复元素后的链表头节点 return head Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题02/02.返回倒数第k个节点/02.返回倒数第k个节点.html":{"url":"面试题/面试题02/02.返回倒数第k个节点/02.返回倒数第k个节点.html","title":"02.返回倒数第k个节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 2. 返回倒数第 k 个节点 Java Python 02. 返回倒数第 k 个节点 https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-07-16 18:22:02 * @Description: https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/ * @FilePath: \\leetcode-googtech\\面试题02\\#02. 返回倒数第 k 个节点\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int kthToLast(ListNode head, int k) { // 初始化前继节点与后继节点 ListNode previous = head; ListNode laterNode = head; // 后移后继节点,直到与前继节点距离相差为k for(int i=0;i2->3->4->5 和 k = 2 输出： 4 说明： 给定的 k 保证是有效的。 */ Python ''' @Author: Goog Tech @Date: 2020-07-16 18:22:09 @Description: https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/ @FilePath: \\leetcode-googtech\\面试题02\\#02. 返回倒数第 k 个节点\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def kthToLast(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: int \"\"\" alist = [] # 逐个将ListNode节点转为为list元素 while head != None: alist.append(head.val) head = head.next # 获取list中指定索引值 return alist[-k] \"\"\" 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例： 输入： 1->2->3->4->5 和 k = 2 输出： 4 说明： 给定的 k 保证是有效的。 \"\"\" Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题02/03.删除中间节点/03.删除中间节点.html":{"url":"面试题/面试题02/03.删除中间节点/03.删除中间节点.html","title":"03.删除中间节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 3. 删除中间节点 Java Python 03. 删除中间节点 https://leetcode-cn.com/problems/delete-middle-node-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-07-19 22:29:43 * @Description: https://leetcode-cn.com/problems/delete-middle-node-lcci/ * @FilePath: \\leetcode-googtech\\面试题02\\#03. 删除中间节点\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { // 更新待删除节点的值及指针 node.val = node.next.val; node.next = node.next.next; } } Python ''' @Author: Goog Tech @Date: 2020-07-19 22:29:49 @Description: https://leetcode-cn.com/problems/delete-middle-node-lcci/ @FilePath: \\leetcode-googtech\\面试题02\\#03. 删除中间节点\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" # 更新待删除节点的值及指针 node.val = node.next.val node.next = node.next.next Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题02/06.回文链表/06.回文链表.html":{"url":"面试题/面试题02/06.回文链表/06.回文链表.html","title":"06.回文链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 6. 回文链表 Java Python 06. 回文链表 https://leetcode-cn.com/problems/palindrome-linked-list-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-08-31 15:10:42 * @LastEditTime: 2020-08-31 15:10:55 * @Description: https://leetcode-cn.com/problems/palindrome-linked-list-lcci/ * @FilePath: \\leetcode-googtech\\面试题02\\#06. 回文链表\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 双指针法 public boolean isPalindrome(ListNode head) { List list = new ArrayList<>(); // 遍历链表元素并将其存储到数组列表中 ListNode currentNode = head; while(currentNode != null) { list.add(currentNode.val); currentNode = currentNode.next; } // 同时移动头指针和尾指针,并判断所指元素是否相同 int front = 0, rear = list.size() - 1; while(rear > front) { if(!list.get(front).equals(list.get(rear))) { return false; } front++; rear--; } return true; } } Python ''' Author: Goog Tech Date: 2020-08-31 15:10:47 LastEditTime: 2020-08-31 15:12:02 Description: https://leetcode-cn.com/problems/palindrome-linked-list-lcci/ FilePath: \\leetcode-googtech\\面试题02\\#06. 回文链表\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" values = [] currentNode = head while currentNode is not None: values.append(currentNode.val) currentNode = currentNode.next return values == values[::-1] # values[::-1] : 将 values 数组中的元素顺序取反 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题02/07.链表相交/07.链表相交.html":{"url":"面试题/面试题02/07.链表相交/07.链表相交.html","title":"07.链表相交","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 7. 链表相交 Java Python 07. 链表相交 https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-07-21 20:46:33 * @Description: https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/ * @Reference: https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/shuang-zhi-zhen-zou-liang-bian-zou-dao-di-er-bian-/ * @FilePath: \\leetcode-googtech\\面试题02\\#07. 链表相交\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { // 双指针法:一个指向A链表,一个指向B链表 // 长链表A和短链表B加起来长度为L,那么让两个指针走相同的长度, // 如果不能相遇则证明没有交点,反之有交点. 例如: AO + OC + BO == BO + OC + AO public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null){ return null; } ListNode pA = headA,pB = headB; while(pA!=pB){ pA = pA.next == null? headB : pA.next; pB = pB.next == null? headA : pB.next; } return pA; } } Python ''' @Author: Goog Tech @Date: 2020-07-21 20:46:44 @Description: https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/ @Reference: https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/shuang-zhi-zhen-zou-liang-bian-zou-dao-di-er-bian-/ @FilePath: \\leetcode-googtech\\面试题02\\#07. 链表相交\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" \"\"\" 双指针题法: 让两个指针分别从A和B点往C点走 两个指针分别走到C后，又各自从另外一个指针的起点，也就是A指针第二次走从B点开始走，B指针同理. 这样，A指针走的路径长度 AO + OC + BO 必定等于B指针走的路径长度 BO + OC + AO， 这也就意味着这两个指针第二轮走必定会在O点相遇，相遇后也即到达了退出循环的条件，反之无交点. \"\"\" pA,pB = headA,headB while pA!=pB: pA = pA.next if pA else headB pB = pB.next if pB else headA return pA Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题03/":{"url":"面试题/面试题03/","title":"面试题03","keywords":"","body":" 📝 面试题03 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题03/02.栈的最小值/02.栈的最小值.html":{"url":"面试题/面试题03/02.栈的最小值/02.栈的最小值.html","title":"02.栈的最小值","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 2. 栈的最小值 Java Python 02. 栈的最小值 https://leetcode-cn.com/problems/min-stack-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 21:57:05 * @LastEditTime: 2020-09-01 22:07:53 * @Description: https://leetcode-cn.com/problems/min-stack/ * @FilePath: \\leetcode-googtech\\面试题03\\#02. 栈的最小值\\Solution.java * @WebSite: https://algorithm.show/ */ class MinStack { // 声明两个辅助栈,其中 stack 用于存储元素,而 minStack 仅用于存储 stack 中的最小元素 private Stack stack; private Stack minStack; /** initialize your data structure here. */ public MinStack() { // 初始化辅助栈 stack = new Stack<>(); minStack = new Stack<>(); } public void push(int x) { // 将元素压入 stack 栈中 stack.push(x); // 若当前 minStack 为空或其顶部元素小于或等于当前压入的元素 x,则将 x 压入 minStack 栈中 if(minStack.isEmpty() || x Python ''' Author: Goog Tech Date: 2020-09-01 21:57:09 LastEditTime: 2020-09-01 22:08:14 Description: https://leetcode-cn.com/problems/min-stack/ FilePath: \\leetcode-googtech\\面试题03\\#02. 栈的最小值\\Solution.py WebSite: https://algorithm.show/ ''' class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" # 初始化两个辅助栈,其中 stack 用于存储元素,而 minStack 仅用于存储 stack 中的最小元素 self.stack = [] self.minStack = [] def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" # 将元素压入 stack 栈中 self.stack.append(x) # 若当前 minStack 为空或其顶部元素小于或等于当前压入的元素 x,则将 x 压入 minStack 栈中 if not self.minStack or x Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题03/04.化栈为队/04.化栈为队.html":{"url":"面试题/面试题03/04.化栈为队/04.化栈为队.html","title":"04.化栈为队","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 4. 化栈为队 Java Python 04. 化栈为队 https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-08-31 16:17:16 * @LastEditTime: 2020-08-31 16:20:02 * @Description: https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/ * @FilePath: \\leetcode-googtech\\面试题03\\#04. 化栈为队\\Solution.java * @WebSite: https://algorithm.show/ */ // 解题思路: 每次入队时把数据压入 StackWrite, // 每次读数据时先将 StackWrite 中的数据压入到 StackRead, // 这时 StackRead 中的栈顶元素就是我们所期望的队首元素咯 // refer to: https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/comments/319121 class MyQueue { // 声明两个辅助栈,其分别用于存储与读取数据 Stack stackWrite; Stack stackRead; /** Initialize your data structure here. */ public MyQueue() { stackWrite = new Stack<>(); stackRead = new Stack<>(); } /** Push element x to the back of queue. */ public void push(int x) { stackWrite.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { // 在出队的时要注意一点: 如果 StackRead 中有数据,那么就直接取 StackRead 的栈顶元素 // 如果 StackRead 为空则先将 StackWrite 中的元素压入 StackRead 中,再取 StackRead 的栈顶元素 peek(); return stackRead.pop(); } /** Get the front element. */ public int peek() { if(!stackRead.isEmpty()) return stackRead.peek(); while(!stackWrite.isEmpty()) stackRead.push(stackWrite.pop()); return stackRead.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stackRead.isEmpty() && stackWrite.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ Python ''' Author: Goog Tech Date: 2020-08-31 16:17:22 LastEditTime: 2020-08-31 16:19:33 Description: https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/ FilePath: \\leetcode-googtech\\面试题03\\#04. 化栈为队\\Solution.py WebSite: https://algorithm.show/ ''' # 解题思路: 每次入队时把数据压入 StackWrite, # 每次读数据时先将 StackWrite 中的数据压入到 StackRead, # 这时 StackRead 中的栈顶元素就是我们所期望的队首元素咯 # refer to: https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/comments/319121 class MyQueue(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" # 声明两个辅助栈,其分别用于存储与读取数据 self.stackWrite = [] self.stackRead = [] def push(self, x): \"\"\" Push element x to the back of queue. :type x: int :rtype: None \"\"\" self.stackWrite.append(x) def pop(self): \"\"\" Removes the element from in front of queue and returns that element. :rtype: int \"\"\" # 在出队的时要注意一点: 如果 StackRead 中有数据,那么就直接取 StackRead 的栈顶元素 # 如果 StackRead 为空则先将 StackWrite 中的元素压入 StackRead 中,再取 StackRead 的栈顶元素 # if len(self.stackRead) == 0: # while self.stackWrite: self.stackRead.append(self.stackWrite.pop()) self.peek() return self.stackRead.pop() def peek(self): \"\"\" Get the front element. :rtype: int \"\"\" if len(self.stackRead) == 0: while self.stackWrite: self.stackRead.append(self.stackWrite.pop()) return self.stackRead[-1] def empty(self): \"\"\" Returns whether the queue is empty. :rtype: bool \"\"\" return True if not self.stackWrite and not self.stackRead else False # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty() Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题04/":{"url":"面试题/面试题04/","title":"面试题04","keywords":"","body":" 📝 面试题04 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题04/02.最小高度树/02.最小高度树.html":{"url":"面试题/面试题04/02.最小高度树/02.最小高度树.html","title":"02.最小高度树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 2. 最小高度树 Java Python 02. 最小高度树 https://leetcode-cn.com/problems/minimum-height-tree-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-09-11 08:40:06 * @LastEditTime: 2020-09-11 08:41:06 * @Description: https://leetcode-cn.com/problems/minimum-height-tree-lcci/ * @FilePath: \\leetcode-googtech\\面试题04\\#02. 最小高度树\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 将数组中间的元素作为根节点,然后以中间为分界点分别对左边及右边的子数组进行递归, // 最后返回的是左右子树的根节点,然后令其等于 root.left 及 root.right 即可. public TreeNode sortedArrayToBST(int[] nums) { if(nums.length == 0) return null; TreeNode root = new TreeNode(nums[nums.length / 2]); root.left = sortedArrayToBST(Arrays.copyOfRange(nums, 0, nums.length / 2)); root.right = sortedArrayToBST(Arrays.copyOfRange(nums, nums.length / 2 + 1, nums.length)); return root; } } Python ''' Author: Goog Tech Date: 2020-09-11 08:40:19 LastEditTime: 2020-09-11 08:41:44 Description: https://leetcode-cn.com/problems/minimum-height-tree-lcci/ FilePath: \\leetcode-googtech\\面试题04\\#02. 最小高度树\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归法 # 将数组中间的元素作为根节点,然后以中间为分界点分别对左边及右边的子数组进行递归, # 最后返回的是左右子树的根节点,然后令其等于 root.left 及 root.right 即可. def sortedArrayToBST(self, nums): \"\"\" :type nums: List[int] :rtype: TreeNode \"\"\" if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid + 1:]) return root Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题04/03.特定深度节点链表/03.特定深度节点链表.html":{"url":"面试题/面试题04/03.特定深度节点链表/03.特定深度节点链表.html","title":"03.特定深度节点链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 3. 特定深度节点链表 Java Python 03. 特定深度节点链表 https://leetcode-cn.com/problems/list-of-depth-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-09-17 12:30:07 * @LastEditTime: 2020-09-17 12:32:43 * @Description: https://leetcode-cn.com/problems/list-of-depth-lcci/ * @FilePath: \\leetcode-googtech\\面试题04\\#03. 特定深度节点链表\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // BFS : 广度优先搜索,即层次遍历 public ListNode[] listOfDepth(TreeNode tree) { // 判断头节点是否为空 if(tree == null) return new ListNode[0]; // 初始化辅助队列,并将根节点入队 Queue queue = new LinkedList<>(); queue.add(tree); // 初始化链表集合 List list = new ArrayList<>(); // 初始化链表虚拟头节点 ListNode dummyHead = new ListNode(-1); while(!queue.isEmpty()) { // 初始化链表虚拟头节点的指针 ListNode prev = dummyHead; // 获取当前队列中的节点数,即二叉树当前深度所有的节点数 int size = queue.size(); // 遍历队列中的节点 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-09-17 12:30:16 LastEditTime: 2020-09-17 12:31:02 Description: https://leetcode-cn.com/problems/list-of-depth-lcci/ FilePath: \\leetcode-googtech\\面试题04\\#03. 特定深度节点链表\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # BFS : 广度优先搜索,即层次遍历 def listOfDepth(self, tree): \"\"\" :type tree: TreeNode :rtype: List[ListNode] \"\"\" # 判断头节点是否为空 if not tree: return [] # 初始化模拟队列及结果列表 queue, result = [tree], [] # 判断队列是否为空 while queue: # 初始化链表虚拟头节点及其指针 dummyHead = ListNode(None) prev = dummyHead # 遍历辅助队列,其存储着二叉树当前深度的所有节点 for i in range(len(queue)): # 获取队首节点 node = queue.pop(0) # 将链表虚拟头节点的指针指向当前出队节点,即将其作为下一个节点 prev.next = ListNode(node.val) prev = prev.next # 若当前出队节点的左右孩子不为空,则将其入队,进而对下个深度的节点进行遍历 if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 将二叉树当前深度的节点所构成的链表添加到结果列表中 result.append(dummyHead.next) # 返回结果列表 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题10/":{"url":"面试题/面试题10/","title":"面试题10","keywords":"","body":" 📝 面试题10 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题10/01.合并排序的数组/01.合并排序的数组.html":{"url":"面试题/面试题10/01.合并排序的数组/01.合并排序的数组.html","title":"01.合并排序的数组","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 合并排序的数组 Java Python 01. 合并排序的数组 https://leetcode-cn.com/problems/sorted-merge-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 14:51:00 * @LastEditTime: 2020-08-30 14:51:48 * @Description: https://leetcode-cn.com/problems/sorted-merge-lcci/ * @FilePath: \\leetcode-googtech\\面试题10\\#01. 合并排序的数组\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public void merge(int[] A, int m, int[] B, int n) { // 初始化两数组的尾指针与数组总长度的下标值 int i = m - 1, j = n - 1, index = m + n - 1; // 通过移动 B 数组指针循环遍历 A 与 B 数组中的元素 while(j >= 0) { // 判断 A 数组尾指针是否移动完毕或当前 B 数组中的元素是否大于 A 中元素 if(i = A[i]) { // 若是则将当前 B 数组中的元素添加到 A 数组中 A[index--] = B[j--]; } else { // 反之将当前 A 数组中的元素添加到 A 数组中 A[index--] = A[i--]; } } } } Python ''' Author: Goog Tech Date: 2020-08-30 14:51:10 LastEditTime: 2020-08-30 14:51:57 Description: https://leetcode-cn.com/problems/sorted-merge-lcci/ FilePath: \\leetcode-googtech\\面试题10\\#01. 合并排序的数组\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): def merge(self, A, m, B, n): \"\"\" :type A: List[int] :type m: int :type B: List[int] :type n: int :rtype: None Do not return anything, modify A in-place instead. \"\"\" # 首先通过遍历将 B 数组中的元素添加到 A 数组中,然后对 A 数组中的元素进行排序 for i in range(n): A[m + i] = B[i] A.sort() Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题17/":{"url":"面试题/面试题17/","title":"面试题17","keywords":"","body":" 📝 面试题17 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题17/11.单词距离/11.单词距离.html":{"url":"面试题/面试题17/11.单词距离/11.单词距离.html","title":"11.单词距离","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 11. 单词距离 Java Python 11. 单词距离 https://leetcode-cn.com/problems/find-closest-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 22:45:37 * @LastEditTime: 2020-08-30 22:45:49 * @Description: https://leetcode-cn.com/problems/find-closest-lcci/ * @FilePath: \\leetcode-googtech\\面试题17\\#11. 单词距离\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 双指针法 public int findClosest(String[] words, String word1, String word2) { // 初始化双指针以及最短距离值 int indexWord1 = -1, indexWord2 = -1, minDistance = 0; // 逐个遍历字符串数组中的单词 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-30 22:45:41 LastEditTime: 2020-08-30 22:46:02 Description: https://leetcode-cn.com/problems/find-closest-lcci/ FilePath: \\leetcode-googtech\\面试题17\\#11. 单词距离\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 双指针法 def findClosest(self, words, word1, word2): \"\"\" :type words: List[str] :type word1: str :type word2: str :rtype: int \"\"\" # 初始化双指针以及最短距离值 indexWorld1, indexWorld2, minDistance = -1, -1, 0 # 逐个遍历字符串数组中的单词 for i in range(len(words)): # 若当前单词与 word1 / word2 相同,则将其下标值赋值给 indexWord1 / indexWord2 if words[i] == word1: indexWorld1 = i if words[i] == word2: indexWorld2 = i # 判断双指针是否发生了变化 if indexWorld1 != -1 and indexWorld2 != -1: # 若最短距离值仍未零,则取双指针差值后的绝对值,并将其赋值给 minDistance if minDistance == 0: minDistance = abs(indexWorld1 - indexWorld2) # 若最短距离不为零,则取双指针差值后的绝对值,并将其与上个 minDistance 比较,取其最小值 minDistance = min(minDistance, abs(indexWorld1 - indexWorld2)) # 返回最小距离值 return minDistance Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"面试题/面试题17/16.按摩师/16.按摩师.html":{"url":"面试题/面试题17/16.按摩师/16.按摩师.html","title":"16.按摩师","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 16. 按摩师 Java Python 16. 按摩师 https://leetcode-cn.com/problems/the-masseuse-lcci/ Java /* * @Author: Goog Tech * @Date: 2020-09-23 21:58:42 * @LastEditTime: 2020-09-23 21:59:04 * @Description: https://leetcode-cn.com/problems/the-masseuse-lcci/ * @FilePath: \\leetcode-googtech\\面试题17\\#16. 按摩师\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // DP : 动态规划 // 设第 n 号的最大时长为 dp[n],解题思路如下: // 1. 若选择第 n 号的话,由于不能接受相邻的预约,所以 dp[n] = dp[n - 2] + nums[n] (即总时长等于 n - 2 号的总时长 + 第 n 号的时长) // 2. 反之若不选择 n 号的话,那么 dp[n] = dp[n - 1](即总时长为 n - 1 号的最大时长) public int massage(int[] nums) { int n = nums.length; if(n == 0) return 0; if(n == 1) return nums[0]; int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i = 2; i Python ''' Author: Goog Tech Date: 2020-09-23 21:58:46 LastEditTime: 2020-09-23 21:59:20 Description: https://leetcode-cn.com/problems/the-masseuse-lcci/ FilePath: \\leetcode-googtech\\面试题17\\#16. 按摩师\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # DP : 动态规划 # 设第 n 号的最大时长为 dp[n],解题思路如下: # 1. 若选择第 n 号的话,由于不能接受相邻的预约,所以 dp[n] = dp[n - 2] + nums[n] (即总时长等于 n - 2 号的总时长 + 第 n 号的时长) # 2. 反之若不选择 n 号的话,那么 dp[n] = dp[n - 1](即总时长为 n - 1 号的最大时长) def massage(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if not nums: return 0 length = len(nums) if length == 1: return nums[0] dp = [0] * length dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, length): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[length - 1] Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/":{"url":"剑指Offer/","title":"剑指 Offer","keywords":"","body":" 📝 剑指 Offer Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/03.数组中重复的数字/03.数组中重复的数字.html":{"url":"剑指Offer/03.数组中重复的数字/03.数组中重复的数字.html","title":"03.数组中重复的数字","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 3. 数组中重复的数字 Java Python 03. 数组中重复的数字 https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ Java class Solution { // 先排序后查找 public int findRepeatNumber(int[] nums) { Arrays.sort(nums); for(int i = 1; i Python class Solution(object): # 利用哈希表 def findRepeatNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" hashSet = set() for num in nums: if num in hashSet: return num hashSet.add(num) return -1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/04.二维数组中的查找/04.二维数组中的查找.html":{"url":"剑指Offer/04.二维数组中的查找/04.二维数组中的查找.html","title":"04.二维数组中的查找","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 4. 二维数组中的查找 Java Python 04. 二维数组中的查找 https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-30 18:00:35 * @LastEditTime: 2020-08-30 18:00:46 * @Description: https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#04. 二维数组中的查找\\Solution.java * @WebSite: https://algorithm.show/ */ class Solution { // 从右上角开始走，利用这个顺序关系可以在 O(m + n) 的复杂度下解决这个题: // 1. 如果当前位置元素比 target 小,则 row++ // 2. 如果当前位置元素比 target大,则 col-- // 3. 如果相等则返回 true // 4. 如果越界了还没找到则说明不存在,返回 false public boolean findNumberIn2DArray(int[][] matrix, int target) { if(matrix == null || matrix.length == 0) return false; int row = 0, col = matrix[0].length - 1; while(row = 0) { if(matrix[row][col] > target) { col--; }else if(matrix[row][col] Python ''' Author: Goog Tech Date: 2020-08-30 18:00:40 LastEditTime: 2020-08-30 18:01:01 Description: https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#04. 二维数组中的查找\\Solution.py WebSite: https://algorithm.show/ ''' class Solution(object): # 从右上角开始走，利用这个顺序关系可以在 O(m + n) 的复杂度下解决这个题: # 1. 如果当前位置元素比 target 小,则 row++ # 2. 如果当前位置元素比 target大,则 col-- # 3. 如果相等则返回 true # 4. 如果越界了还没找到则说明不存在,返回 false def findNumberIn2DArray(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if len(matrix) == 0 or len(matrix[0]) == 0: return False n, m = len(matrix), len(matrix[0]) row, column = 0, m - 1 while row = 0: if matrix[row][column] == target: return True elif matrix[row][column] > target: column -= 1 else: row += 1 return False Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/05.替换空格/05.替换空格.html":{"url":"剑指Offer/05.替换空格/05.替换空格.html","title":"05.替换空格","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 5. 替换空格 Java Python 05. 替换空格 https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/ Java /* * @Author: Good Tech * @Date: 2020-08-04 16:02:27 * @LastEditTime: 2020-08-04 16:03:46 * @Description: https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#05. 替换空格\\Solution.java */ class Solution { public String replaceSpace(String s) { StringBuilder result = new StringBuilder(); // 遍历字符串s中的每个字符 for(Character c : s.toCharArray()) { // 当 c 为空格时,向result后添加字符串\"%20\" if(c == ' ') { result.append(\"%20\"); // 当 c 不为空格时,向result后添加字符c }else { result.append(c); } } // 将result转换为字符串并返回 return result.toString(); } } Python ''' Author: Goog Tech Date: 2020-08-04 16:02:32 LastEditTime: 2020-08-04 16:03:10 Description: https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#05. 替换空格\\Solution.py ''' class Solution(object): def replaceSpace(self, s): \"\"\" :type s: str :rtype: str \"\"\" result = [] # 遍历列表 s 中的每一个字符 for c in s: # 当 c 为空格时,将\"%20\"添加到result中 if c == ' ': result.append(\"%20\") # 当 c 不为空时,将'c'添加到result中 else: result.append(c) # 将列表result转换为字符串并返回 return ''.join(result) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/06.从尾到头打印链表/06.从尾到头打印链表.html":{"url":"剑指Offer/06.从尾到头打印链表/06.从尾到头打印链表.html","title":"06.从尾到头打印链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 6. 从尾到头打印链表 Java Python 06. 从尾到头打印链表 https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-07-16 17:42:14 * @Description: https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#06. 从尾到头打印链表\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int[] reversePrint(ListNode head) { // 首先遍历链表来获取链表的长度值 ListNode currentNode = head; int len = 0; while(currentNode!=null){ len++; currentNode = currentNode.next; } // 其次倒叙遍历链表并将节点逐个插入数组 currentNode = head; int [] result = new int[len]; for(int i = len - 1;i >=0; i--){ result[i] = head.val; head = head.next; } return result; } } /* 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1: 输入：head = [1,3,2] 输出：[2,3,1] 限制: 0 Python ''' @Author: Goog Tech @Date: 2020-07-16 17:42:24 @Description: https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ @FilePath: \\leetcode-googtech\\剑指 Offer\\#06. 从尾到头打印链表\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reversePrint(self, head): \"\"\" :type head: ListNode :rtype: List[int] \"\"\" # 初始化栈 stack = [] # 入栈 while head: stack.append(head.val) head = head.next result = [] # 出栈 while stack: result.append(stack.pop()) return result \"\"\" 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1: 输入：head = [1,3,2] 输出：[2,3,1] 限制: 0 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/15.二进制中1的个数/15.二进制中1的个数.html":{"url":"剑指Offer/15.二进制中1的个数/15.二进制中1的个数.html","title":"15.二进制中1的个数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 15. 二进制中 1 的个数 Java Python 15. 二进制中 1 的个数 https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/ Java public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { // 使用与(&)运算,即两位同时为1时结果才为1 return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1)); } } Python class Solution(object): def hammingWeight(self, n): \"\"\" :type n: int :rtype: int \"\"\" count = 0 # bin() 函数返回一个 int 或者长整型 long int 的二进制表示 for i in str(bin(n)): if i == '1': count += 1 return count Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/17.打印从1到最大的n位数/17.打印从1到最大的n位数.html":{"url":"剑指Offer/17.打印从1到最大的n位数/17.打印从1到最大的n位数.html","title":"17.打印从1到最大的n位数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 17. 打印从1到最大的n位数 Java Python 17. 打印从1到最大的n位数 https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 13:56:01 * @LastEditTime: 2020-08-09 13:56:26 * @Description: https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#17.打印从1到最大的n位数\\Solution.java */ class Solution { public int[] printNumbers(int n) { // 计算待输出的长度,Math.pow()函数返回基数(base)的指数(exponent)次幂,例如10的2次方为100 double length = Math.pow(10, n) - 1; // 初始化结果数组 int[] result = new int[(int)length]; // 将数值存储大到结果数组中 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-09 13:56:06 LastEditTime: 2020-08-09 13:57:03 Description: https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#17.打印从1到最大的n位数\\Solution.py ''' class Solution(object): def printNumbers(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\" return range(1, 10 ** n); Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/18.删除链表的节点/18.删除链表的节点.html":{"url":"剑指Offer/18.删除链表的节点/18.删除链表的节点.html","title":"18.删除链表的节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 18. 删除链表的节点 Java Python 18. 删除链表的节点 https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-07-17 06:54:07 * @Description: https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#18. 删除链表的节点\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode deleteNode(ListNode head, int val) { // 判断头节点是否为空 if(head==null){ return head; } // 初始化待删除节点与其前置节点 ListNode deletedNode = head; ListNode previousNode = null; // 判断待删除节点是否为头节点 if(deletedNode.val==val){ return head.next; } // 寻找待删除节点 while(deletedNode.val!=val){ previousNode = deletedNode; deletedNode = deletedNode.next; } // 通过更新指针来移除待删节点 // 待删节点的前置节点的指针指向待删除节点的后一个节点 previousNode.next = deletedNode.next; return head; } } Python ''' @Author: Goog Tech @Date: 2020-07-17 07:17:03 @Description: https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/python-dan-zhi-zhen-by-hongge/ @FilePath: \\leetcode-googtech\\剑指 Offer\\#18. 删除链表的节点\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteNode(self, head, val): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" currentNode = head # 判断头节点是否为空 if not head: return head # 判断待删节点是否为头节点 if head.val == val: return head.next # 判断当前节点的下一个节点的下一个节点是否为待删节点 while currentNode.next: if currentNode.next.val == val: currentNode.next = currentNode.next.next break currentNode = currentNode.next return head Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/21.调整数组顺序使奇数位于偶数前面/21.调整数组顺序使奇数位于偶数前面.html":{"url":"剑指Offer/21.调整数组顺序使奇数位于偶数前面/21.调整数组顺序使奇数位于偶数前面.html","title":"21.调整数组顺序使奇数位于偶数前面","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 21. 调整数组顺序使奇数位于偶数前面 Java Python 21. 调整数组顺序使奇数位于偶数前面 https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/ Java class Solution { // 双指针法 public int[] exchange(int[] nums) { // 初始化头尾指针 int left = 0, right = nums.length - 1; // 通过移动头尾指针来循环遍历数组元素 while(left Python class Solution(object): def exchange(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" i = 0 # 循环遍历数组元素 for j in range(len(nums)): # 若当前元素为奇数,则交换奇偶元素的位置 if nums[j] % 2 != 0: nums[i], nums[j] = nums[j], nums[i] i += 1 # 返回结果 return nums Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/22.链表中倒数第k个节点/22.链表中倒数第k个节点.html":{"url":"剑指Offer/22.链表中倒数第k个节点/22.链表中倒数第k个节点.html","title":"22.链表中倒数第k个节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 22. 链表中倒数第k个节点 Java Python 22. 链表中倒数第k个节点 https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-07-19 22:06:49 * @Description: https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#22. 链表中倒数第k个节点\\Solution.java */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 快慢指针法 public ListNode getKthFromEnd(ListNode head, int k) { ListNode slowNode = head,fastNode = head; // 先让快指针走k步 for(int i=0;i Python ''' @Author: Goog Tech @Date: 2020-07-19 22:06:56 @Description: https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ @FilePath: \\leetcode-googtech\\剑指 Offer\\#22. 链表中倒数第k个节点\\Solution.py ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # 快慢指针法 def getKthFromEnd(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" fastNode = slowNode = head # 先让快指针走k步 while k>0: fastNode = fastNode.next k-=1 # 然后两个指针同步走 # 当快指针走到头时,慢指针就是链表倒数第k个节点 while fastNode: fastNode = fastNode.next slowNode = slowNode.next return slowNode Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/24.反转链表/24.反转链表.html":{"url":"剑指Offer/24.反转链表/24.反转链表.html","title":"24.反转链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 24.反转链表 Java Python 24.反转链表 https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-18 09:51:34 * @LastEditTime: 2020-08-18 10:11:26 * @Description: https://leetcode-cn.com/problems/reverse-linked-list/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#24. 反转链表\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 双指针迭代法 public ListNode reverseList(ListNode head) { // 初始化前后指针,其中临时指针用于辅助当前指针移动 ListNode previousNode = null, currentNode = head, tempNode = null; // 循环遍历链表 while(currentNode != null) { // 记录当前节点的下一个节点 tempNode = currentNode.next; // 将当前节点指向前节点previousNode currentNode.next = previousNode; // 继续向后移动前后节点 previousNode = currentNode; currentNode = tempNode; } // 当迭代完毕时currentNode指向null,而previousNode指向最后一个节点 return previousNode; } } Python ''' Author: Goog Tech Date: 2020-08-18 09:44:05 LastEditTime: 2020-08-18 10:11:58 Description: https://leetcode-cn.com/problems/reverse-linked-list/ FilePath: \\leetcode-googtech\\剑指 Offer\\#24. 反转链表\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # 双指针迭代法 def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 初始化前后指针,临时指针用于辅助currentNode指针移动 previousNode, currentNode, tempNode = None, head, None # 遍历链表 while currentNode: # 记录当前指针的下一个节点 tempNode = currentNode.next # 将当前节点指向前节点previousNode currentNode.next = previousNode # 继续向后移动前后指针 previousNode = currentNode currentNode = tempNode # 当迭代完毕时currentNode指向null,而previousNode指向最后一个节点 return previousNode Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/25.合并两个排序的链表/25.合并两个排序的链表.html":{"url":"剑指Offer/25.合并两个排序的链表/25.合并两个排序的链表.html","title":"25.合并两个排序的链表","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 25. 合并两个排序的链表 Java Python 25. 合并两个排序的链表 https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-18 15:19:44 * @LastEditTime: 2020-08-18 15:21:19 * @Description: https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#25. 合并两个排序的链表\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { // 迭代法 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 判断链表头节点是否为空 if(l1 == null) return l2; if(l2 == null) return l1; // 初始化哨兵节点及头指针 ListNode previousHead = new ListNode(-1); ListNode currentNode = previousHead; // 遍历链表并逐个比较两节点值的大小,并通过移动哨兵节点头指针来构建新链表 while(l1 !=null && l2 != null) { if(l1.val >= l2.val) { currentNode.next = l2; l2 = l2.next; }else { currentNode.next = l1; l1 = l1.next; } // 每一次比较后哨兵节点指针都需要往后移动一位 currentNode = currentNode.next; } // l1与l2合并结束后,最多还剩一个链表是非空的,这时只需将链表尾指针指向未合完的链表即可 currentNode.next = l2 == null ? l1 : l2; // 返回哨兵节点所指的已排序好的链表的头节点 return previousHead.next; } } Python ''' Author: Goog Tech Date: 2020-08-18 15:19:51 LastEditTime: 2020-08-18 15:20:33 Description: https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#25. 合并两个排序的链表\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): # 迭代法 def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" # 判断头节点是否为空 if not l1 or not l2: return l2 or l1 # 初始化哨兵节点及其头指针 previousHead = ListNode(-1) currentNode = previousHead # 遍历链表并逐个比较两节点值的大小,并通过移动哨兵节点指针来构建新链表 while l1 and l2: if l1.val >= l2.val: currentNode.next, l2 = l2, l2.next else: currentNode.next, l1 = l1, l1.next # 每次比较后都需要将哨兵节点指针往后移动一位 currentNode = currentNode.next # l1与l2合并结束后,最后还剩一个链表是非空的,这时只需将链表尾指针指向未合完的链表即可 currentNode.next = l2 if l2 is not None else l1 # 返回哨兵节点所指的已排序好的链表的头节点 return previousHead.next Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/27.二叉树的镜像/27.二叉树的镜像.html":{"url":"剑指Offer/27.二叉树的镜像/27.二叉树的镜像.html","title":"27.二叉树的镜像","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 27. 二叉树的镜像 Java Python 27. 二叉树的镜像 https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 10:55:34 * @LastEditTime: 2020-08-09 10:56:24 * @Description: https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#27.二叉树的镜像\\Solution.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mirrorTree(TreeNode root) { // 判断根节点是否为空 if(root == null) return null; // 初始化二叉树镜像 TreeNode result = new TreeNode(root.val); // 递归交换左右子树的孩子节点 result.left = mirrorTree(root.right); result.right = mirrorTree(root.left); // 返回结果 return result; } } Python ''' Author: Goog Tech Date: 2020-08-09 10:55:41 LastEditTime: 2020-08-09 10:56:48 Description: https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#27.二叉树的镜像\\Solution.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def mirrorTree(self, root): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" # 判断根节点是否为空 if not root: return root # 交换左右子树的孩子节点 root.left, root.right = root.right, root.left # 递归根节点的左右子树 self.mirrorTree(root.left) self.mirrorTree(root.right) # 返回结果 return root Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/28.对称的二叉树/28.对称的二叉树.html":{"url":"剑指Offer/28.对称的二叉树/28.对称的二叉树.html","title":"28.对称的二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 28. 对称的二叉树 Java Python 28. 对称的二叉树 https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-19 11:49:46 * @LastEditTime: 2020-08-19 11:53:48 * @Description: https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#28.对称的二叉树\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归法 public boolean isSymmetric(TreeNode root) { // 若根节点不为空则递归遍历左右子树根节点的孩子节点 if(root == null) return true; return dfs(root.left, root.right); } private boolean dfs(TreeNode left, TreeNode right) { // 若左右子树中的两孩子节点都为空则对称 if(left == null && right == null) return true; // 若左右子树的两孩子节点其中有一个为空或这两节点的值不相同,则不对称 if(left == null || right == null || left.val != right.val) return false; // 继续递归比较左右子树的孩子节点 return dfs(left.left, right.right) && dfs(left.right, right.left); } } Python ''' Author: Goog Tech Date: 2020-08-19 11:49:51 LastEditTime: 2020-08-19 11:53:57 Description: https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#28.对称的二叉树\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归法 def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" # 判断头节点是否为空 if not root: return True # 递归遍历根节点的左右子树的孩子节点 def dfs(left, right): # 若左右子树的两孩子节点都为空,则对称 if not left and not right: return True # 若左右子树的两孩子节点其中有一个为空或这两节点的值不相同,则不对称 if not left or not right or left.val != right.val: return False # 继续递归比较左右子树的孩子节点 return dfs(left.left, right.right) and dfs(left.right, right.left) # 传入左右子树的根节点 return dfs(root.left, root.right) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/30.包含min函数的栈/30.包含min函数的栈.html":{"url":"剑指Offer/30.包含min函数的栈/30.包含min函数的栈.html","title":"30.包含min函数的栈","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 30. 包含min函数的栈 Java Python 30. 包含min函数的栈 https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-09-01 21:57:05 * @LastEditTime: 2020-09-01 22:28:10 * @Description: https://leetcode-cn.com/problems/min-stack/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#30. 包含min函数的栈\\Solution.java * @WebSite: https://algorithm.show/ */ class MinStack { // 声明两个辅助栈,其中 stack 用于存储元素,而 minStack 仅用于存储 stack 中的最小元素 private Stack stack; private Stack minStack; /** initialize your data structure here. */ public MinStack() { // 初始化辅助栈 stack = new Stack<>(); minStack = new Stack<>(); } public void push(int x) { // 将元素压入 stack 栈中 stack.push(x); // 若当前 minStack 为空或其顶部元素小于或等于当前压入的元素 x,则将 x 压入 minStack 栈中 if(minStack.isEmpty() || x Python ''' Author: Goog Tech Date: 2020-09-01 21:57:09 LastEditTime: 2020-09-01 22:28:26 Description: https://leetcode-cn.com/problems/min-stack/ FilePath: \\leetcode-googtech\\剑指 Offer\\#30. 包含min函数的栈\\Solution.py WebSite: https://algorithm.show/ ''' class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" # 初始化两个辅助栈,其中 stack 用于存储元素,而 minStack 仅用于存储 stack 中的最小元素 self.stack = [] self.minStack = [] def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" # 将元素压入 stack 栈中 self.stack.append(x) # 若当前 minStack 为空或其顶部元素小于或等于当前压入的元素 x,则将 x 压入 minStack 栈中 if not self.minStack or x Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/32-I.从上到下打印二叉树/32-I.从上到下打印二叉树.html":{"url":"剑指Offer/32-I.从上到下打印二叉树/32-I.从上到下打印二叉树.html","title":"32-I.从上到下打印二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 剑指 Offer 32 - I. 从上到下打印二叉树 Java Python 剑指 Offer 32 - I. 从上到下打印二叉树 https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 16:43:22 * @LastEditTime: 2020-08-04 16:44:19 * @Description: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#32 - I. 从上到下打印二叉树\\Solution.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // BFS public int[] levelOrder(TreeNode root) { // 判断头节点是否为空 if(root == null) return new int[0]; // 初始化辅助队列,通过BFS实现层次遍历二叉树 Queue queue = new LinkedList<>(); // 初始化动态数组,用于存储节点值 ArrayList list = new ArrayList<>(); // 根节点先入队 queue.add(root); // 循环弹出队首节点,将其值存储到list,后将其孩子节点入队 while(!queue.isEmpty()) { TreeNode currentNode = queue.poll(); list.add(currentNode.val); if(currentNode.left != null) { queue.add(currentNode.left); } if(currentNode.right != null) { queue.add(currentNode.right); } } // 将 ArrayList 转换为 int 数组并返回 int [] result = new int[list.size()]; for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-04 16:43:28 LastEditTime: 2020-08-04 16:46:33 Description: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#32 - I. 从上到下打印二叉树\\Solution.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" # 判断头节点是否为空 if not root: return [] # 初始化结果列表及辅助队列 result, queue = [], [root] # 循环弹出队首元素,将其值存储到result并将其孩子节点入队 while queue: currentNode = queue.pop(0) result.append(currentNode.val) if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) # 返回结果列表 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/32-II.从上到下打印二叉树II/32-II.从上到下打印二叉树II.html":{"url":"剑指Offer/32-II.从上到下打印二叉树II/32-II.从上到下打印二叉树II.html","title":"32-II.从上到下打印二叉树II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 32 - II. 从上到下打印二叉树 II Java Python 32 - II. 从上到下打印二叉树 II https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-20 11:06:00 * @LastEditTime: 2020-08-20 11:06:34 * @Description: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#32 - II. 从上到下打印二叉树 II\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // BFS: 使用队列实现二叉树的层次遍历 public List> levelOrder(TreeNode root) { // 初始化用于存储结果的 list 集合 List> result = new ArrayList<>(); // 初始化辅助队列 Queue queue = new LinkedList<>(); // 判断头节点是否为空 if(root != null) queue.add(root); // 循环遍历队列 while(!queue.isEmpty()) { // root非空时,第一层的节点数为一 int n = queue.size(); // 初始化用于存储每层节点的 list 集合 List list = new ArrayList<>(); // 进行 n 次循环,确保当前层的节点全部出队列 for(int i = 0; i Python ''' Author: Goog Tech Date: 2020-08-20 11:06:05 LastEditTime: 2020-08-20 11:07:08 Description: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#32 - II. 从上到下打印二叉树 II\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # Breadth Fist Search: 使用队列实现二叉树的层次遍历 def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" # 初始化 result 其用于存储每层的节点列表 result = [] # 初始化辅助队列,并将根节点入队 queue = [root] # 判断头节点是否为空 if not root: return result # 循环遍历队列 while queue: # root非空时,第一层的节点数为一 length = len(queue) # 初始化 alist 其用于存储当前层的节点 alist = [] # 进行 n 次遍历,确保当前层的节点数全部出队列 for i in range(length): # 将队首节点出队 node = queue.pop(0) # 将当前层的节点存储到 alist 集合中 alist.append(node.val) # 把当前节点所有的左右孩子节点全部加入队列,进而确保当前队列的 length 就是下一层的节点数 if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 将每层的节点列表加入到结果列表中 result.append(alist) # 返回结果 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/32-III.从上到下打印二叉树III/32-III.从上到下打印二叉树III.html":{"url":"剑指Offer/32-III.从上到下打印二叉树III/32-III.从上到下打印二叉树III.html","title":"32-III.从上到下打印二叉树III","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 32 - III. 从上到下打印二叉树 III Java Python 32 - III. 从上到下打印二叉树 III https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-09-23 20:59:41 * @LastEditTime: 2020-09-23 21:01:26 * @Description: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#32 - III. 从上到下打印二叉树 III\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { List> result = new ArrayList<>(); // 递归算法 public List> levelOrder(TreeNode root) { helper(root, 0); return result; } private void helper(TreeNode root, int level) { // 判断当前节点是否为空 if(root == null) return; // 若 result 结果集合的大小与二叉树的深度值 level 相等,则说明此时遍历到了一个新层 if(result.size() == level) result.add(new ArrayList<>()); // 若当前深度值 level 为偶数则将当前深度的节点值从右向左顺序存储,反之从左到右顺序存储 if(level % 2 == 0) result.get(level).add(root.val); else result.get(level).add(0, root.val); // 递归遍历二叉树的左右子树 helper(root.left, level + 1); helper(root.right, level + 1); } } Python ''' Author: Goog Tech Date: 2020-09-23 20:59:45 LastEditTime: 2020-09-23 21:00:19 Description: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#32 - III. 从上到下打印二叉树 III\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # BFS : 广度优先遍历 # Python 中使用 collections 中的 deque() 作为双端队列,其中 popleft() 方法的时间复杂度为O(1), # 而列表 list 的 pop(0) 方法的时间复杂度为 O(N). # 注: Java 中将链表 LinkedList 作为双端队列使用. def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" # 判断根节点是否为空 if not root: return [] # 初始化列表及双端队列,并将 root 转化为列表后入队 result, deque = [], collections.deque([root]) # 循环遍历辅助队列中的节点 while deque: # 初始化临时辅助队列,其用于存储二叉树当前层的节点 temp = collections.deque() # 遍历队列中的节点 for _ in range(len(deque)): # 将队首节点出队 node = deque.popleft() # 若结果列表中的列表个数为偶数,则从右向左存储当前层节点 if len(result) % 2: temp.appendleft(node.val) # 反之则从左向右存储当前层节点 else: temp.append(node.val) # 将当前出队节点的左右孩子节点入队 if node.left: deque.append(node.left) if node.right: deque.append(node.right) # 将当前深度的节点列表存储到结果列表中 result.append(list(temp)) # 返回结果列表 return result Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/50.第一个只出现一次的字符/50.第一个只出现一次的字符.html":{"url":"剑指Offer/50.第一个只出现一次的字符/50.第一个只出现一次的字符.html","title":"50.第一个只出现一次的字符","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 50. 第一个只出现一次的字符 Java Python 50. 第一个只出现一次的字符 https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/ Java class Solution { // 哈希表 public char firstUniqChar(String s) { // 初始化hashMap HashMap dic = new HashMap<>(); // 将字符串转换为字符数组 char[] chars = s.toCharArray(); // 遍历字符数组,并将字符逐个存储到hashMap集合中 // 其键用于存储字符,而值为布尔值,其用于存储字符出现的次数是否为1 for(char c : chars) dic.put(c, !dic.containsKey(c)); // 再次遍历字符数组,取出第一个只出现一次的字符 for(char c : chars) if(dic.get(c)) return c; // 若无果则返回空格 return ' '; } } Python class Solution(object): # 哈希表 def firstUniqChar(self, s): \"\"\" :type s: str :rtype: str \"\"\" dic = {} # Python 代码中的 not c in dic 整体为一个布尔值 # c in dic 为判断字典中是否含有键 c for c in s: dic[c] = not c in dic for c in s: if dic[c]: return c return ' ' Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/52.两个链表的第一个公共节点/52.两个链表的第一个公共节点.html":{"url":"剑指Offer/52.两个链表的第一个公共节点/52.两个链表的第一个公共节点.html","title":"52.两个链表的第一个公共节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 52. 两个链表的第一个公共节点 Java Python 52. 两个链表的第一个公共节点 https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/ Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { // 双指针法 public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 判断头节点是否为空 if(headA == null || headB == null) return null; // 题目要求: 勿破坏原链表结构 ListNode nodeA = headA, nodeB = headB; // 循环遍历链表 while(nodeA != nodeB) { // 若nodeA到了末尾,则令nodeA = headB,然后继续遍历 nodeA = nodeA == null ? headB : nodeA.next; // 若nodeB到了末尾,则令nodeB = headA,然后继续遍历 nodeB = nodeB == null ? headA : nodeB.next; } // 返回结果 return nodeA; } } Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" # 判断头节点是否为空 if not headA or not headB: return None # 题目要求: 勿破坏原链表结构 nodeA, nodeB = headA, headB # 循环遍历链表 while(nodeA != nodeB): # 如果nodeA到了末尾,则令nodeA = headB,然后继续遍历 nodeA = nodeA.next if nodeA else headB # 若nodeB到了末尾,则令nodeB = headA,然后继续遍历 nodeB = nodeB.next if nodeB else headA # 返回结果 return nodeA Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/54.二叉搜索树的第k大节点/54.二叉搜索树的第k大节点.html":{"url":"剑指Offer/54.二叉搜索树的第k大节点/54.二叉搜索树的第k大节点.html","title":"54.二叉搜索树的第k大节点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 54. 二叉搜索树的第k大节点 Java Python 54. 二叉搜索树的第k大节点 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-18 11:52:55 * @LastEditTime: 2020-08-18 11:53:28 * @Description: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#54.二叉搜索树的第k大节点\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 二叉搜索树的特性: 左孩子节点 list = new ArrayList<>(); helper(root, list); // 返回第 k 大的节点 return list.get(list.size() - k); } // 中序遍历二叉搜索树: 左->根->右, 可得到一个从小到大的序列 private void helper(TreeNode root, List list) { if (root == null) return; if (root.left != null) helper(root.left, list); list.add(root.val); if (root.right != null) helper(root.right, list); } // 优化上述解法的空间复杂度 private int result = 0, count = 0; public int kthLargest(TreeNode root, int k) { if(root == null || k 根->左, 可得到一个从大到小的序列 private void helper(TreeNode root, int k) { if(root.right != null) helper(root.right, k); // 若当前遍历的节点个数等于 k 值即表明当前节点为第 k 大的节点 if(++count == k) { result = root.val; return; } if(root.left != null) helper(root.left, k); } } Python ''' Author: Goog Tech Date: 2020-08-18 11:53:01 LastEditTime: 2020-08-18 11:53:37 Description: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#54.二叉搜索树的第k大节点\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 中序遍历的逆序: 右->根->左, 可得到一个从大到小的序列 def kthLargest(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" alist = [] def inorder(root, k): if not root or k Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/55-I.二叉树的深度/55-I.二叉树的深度.html":{"url":"剑指Offer/55-I.二叉树的深度/55-I.二叉树的深度.html","title":"55-I.二叉树的深度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 55-I. 二叉树的深度 Java Python 55-I. 二叉树的深度 https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-07-21 21:15:19 * @Description: https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#55 - I. 二叉树的深度\\Solution.java */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 后序遍历(DFS): 递归法 public int maxDepth(final TreeNode root) { if (root == null) { return 0; } // 递归获取左右子树的深度 final int leftDepth = maxDepth(root.left) + 1; final int rightDepth = maxDepth(root.right) + 1; // 利获取最大子树深度 return leftDepth > rightDepth ? leftDepth:rightDepth; } } Python ''' @Author: Goog Tech @Date: 2020-07-21 21:15:26 @Description: https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/ @FilePath: \\leetcode-googtech\\剑指 Offer\\#55 - I. 二叉树的深度\\Solution.py ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 后序遍历(DFS): 递归法 def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/55-II.平衡二叉树/55-II.平衡二叉树.html":{"url":"剑指Offer/55-II.平衡二叉树/55-II.平衡二叉树.html","title":"55-II.平衡二叉树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 55 - II. 平衡二叉树 Java Python 55 - II. 平衡二叉树 https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-09-17 10:02:35 * @LastEditTime: 2020-09-17 10:03:10 * @Description: https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#55 - II. 平衡二叉树\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { boolean result = true; // BFS : 深度优先遍历 public boolean isBalanced(TreeNode root) { dfs(root); return result; } private int dfs(TreeNode root) { if(root == null) return 0; int lDepth = dfs(root.left); int rDepth = dfs(root.right); if(Math.abs(lDepth - rDepth) > 1) result = false; return Math.max(lDepth, rDepth) + 1; } } Python ''' Author: Goog Tech Date: 2020-09-17 10:02:46 LastEditTime: 2020-09-17 10:03:33 Description: https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#55 - II. 平衡二叉树\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # 递归的三个条件 : 左平衡,右平衡,当前节点平衡. class Solution: def isBalanced(self, root: TreeNode) -> bool: if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.height(root.left) - self.height(root.right)) int: if not root: return 0 return max(self.height(root.left), self.height(root.right)) + 1 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/57.和为s的两个数字/57.和为s的两个数字.html":{"url":"剑指Offer/57.和为s的两个数字/57.和为s的两个数字.html","title":"57.和为s的两个数字","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 57. 和为s的两个数字 Java Python 57. 和为s的两个数字 https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 15:28:20 * @LastEditTime: 2020-08-04 15:36:01 * @Description: https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#57. 和为s的两个数字\\Solution.java */ class Solution { /** * 双指针法 * * 1. 初始化双指针,使其分别指向数组的左右两端 * 2. 遍历数组元素,当双指针相遇时终止循环 * a. 计算 total = nums[left] + nums[right] * b. 若 total > target,则指针right向左移动 * c. 若 total target) { right--; // 返回结果数组 }else { return new int[] { nums[left], nums[right] }; } } // 无结果 return new int[] {-1, -1}; } } Python ''' Author: Goog Tech Date: 2020-08-04 15:28:26 LastEditTime: 2020-08-04 15:34:24 Description: https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#57. 和为s的两个数字\\Solution.py ''' class Solution(object): ''' 双指针法 1. 初始化双指针,使其分别指向数组的左右两端 2. 遍历数组元素,当双指针相遇时终止循环 a. 计算 total = nums[left] + nums[right] b. 若 total > target,则指针right向左移动 c. 若 total target: right -= 1 # 右指针左移 else: left += 1 # 左指针右移 return [] # 无结果 Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/58-I.翻转单词顺序/58-I.翻转单词顺序.html":{"url":"剑指Offer/58-I.翻转单词顺序/58-I.翻转单词顺序.html","title":"58-I.翻转单词顺序","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 58 - I. 翻转单词顺序 Java Python 58 - I. 翻转单词顺序 https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/ Java class Solution { /** * 双指针法 * * 1.倒序遍历字符串s,记录单词左右索引边界left,right. * 2.每确定一个单词的边界,则将其添加到单词列表result中. * 3.最后将单词列表拼接为字符串并去除头尾空格,将其返回即可. */ public String reverseWords(String s) { // 删除字符串的首尾空格 s = s.trim(); // 初始化双指针,使得left与right指向字符串尾字符 int right = s.length() - 1,left = right; StringBuilder result = new StringBuilder(); // 通过移动左指针来检查字符串中是否含有单词 while(left >= 0) { // left指针向左移动: 寻找第一个空格 while(left >= 0 && s.charAt(left) != ' ') left--; // 将单词添加到result中,并在其后添加空格 result.append(s.substring(left + 1, right + 1) + \" \"); // 跳过单词之间的空格 while(left >= 0 && s.charAt(left) == ' ') left --; // 使得right指向下一个单词的尾字符 right = left; } // 将结果转换为字符串并删除头尾空格 return result.toString().trim(); }; } Python class Solution(object): # 双指针法 def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\" result = [] # 去除字符串中的首尾空格 s = s.strip() # 初始化双指针,使得left与right指向字符串的尾字符 left = right = len(s) - 1 # 通过移动左指针来检查字符串中是否含有单词 while left >= 0: # left指针向左移动: 寻找第一个空格 while left >= 0 and s[left] != ' ': left -= 1 # 将单词添加到结果列表 result.append(s[left + 1 : right + 1]) # 跳过单词之间的空格 while left >= 0 and s[left] == ' ': left -= 1 # 使得right指向下个单词的尾字符 right = left # 将结果列表用空格拼接为字符串并返回 return ' '.join(result) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/58-II.左旋转字符串/58-II.左旋转字符串.html":{"url":"剑指Offer/58-II.左旋转字符串/58-II.左旋转字符串.html","title":"58-II.左旋转字符串","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 58 - II. 左旋转字符串 Java Python 58 - II. 左旋转字符串 https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-04 10:18:08 * @LastEditTime: 2020-08-04 10:21:11 * @Description: https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#58 - II. 左旋转字符串\\Solution.java */ class Solution { // 方法一: 字符串切片 public String reverseLeftWords(String s, int n) { return s.substring(n) + s.substring(0, n); } // 方法二: 列表遍历拼接 public String reverseLeftWords(String s, int n) { StringBuilder result = new StringBuilder(); // 先将第n + 1位至末位的字符添加到result中 for(int i = n; i Python ''' Author: Goog Tech Date: 2020-08-04 10:18:18 LastEditTime: 2020-08-04 10:20:58 Description: https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#58 - II. 左旋转字符串\\Solution.py ''' class Solution(object): # 方法一: 字符串切片 def reverseLeftWords(self, s, n): \"\"\" :type s: str :type n: int :rtype: str \"\"\" return s[n:] + s[:n] # 方法二: 列表遍历拼接 def reverseLeftWords(self, s, n): result = [] # 先将第n + 1位至末位的字符添加到result中 for i in range(n, len(s)): result.append(s[i]) # 再将首位至第n位的字符添加到result中 for i in range(n): result.append(s[i]) # 将result转换为字符串返回 return ''.join(result) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/64.求1+2+…+n/64.求1+2+…+n.html":{"url":"剑指Offer/64.求1+2+…+n/64.求1+2+…+n.html","title":"64.求1+2+…+n","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 64. 求1+2+…+n Java Python 64. 求1+2+…+n https://leetcode-cn.com/problems/qiu-12n-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-08-09 14:15:51 * @LastEditTime: 2020-08-09 14:16:22 * @Description: https://leetcode-cn.com/problems/qiu-12n-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#64.求1+2+…+n\\Solution.java */ class Solution { // 递归法 public int sumNums(int n) { // 将判断是否为递归的条件看作A,将递归的主体函数看作B // 即在 A && B 中,只有 A 为 true 时才执行B哟 boolean flag = n > 0 && (n += sumNums(n - 1)) > 0; return n; } } Python ''' Author: Goog Tech Date: 2020-08-09 14:15:58 LastEditTime: 2020-08-09 14:16:47 Description: https://leetcode-cn.com/problems/qiu-12n-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#64.求1+2+…+n\\Solution.py ''' class Solution(object): def sumNums(self, n): \"\"\" :type n: int :rtype: int \"\"\" return sum(range(n + 1)) Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/68-I.二叉搜索树的最近公共祖先/68-I.二叉搜索树的最近公共祖先.html":{"url":"剑指Offer/68-I.二叉搜索树的最近公共祖先/68-I.二叉搜索树的最近公共祖先.html","title":"68-I.二叉搜索树的最近公共祖先","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 68 - I. 二叉搜索树的最近公共祖先 Java Python 68 - I. 二叉搜索树的最近公共祖先 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-09-27 19:25:19 * @LastEditTime: 2020-09-27 19:25:39 * @Description: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#68 - I. 二叉搜索树的最近公共祖先\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归解法 // 利用搜索二叉树中每个节点都具备特性: 大于左子树上任意一个节点的值，小于右子树上任意一个节点的值 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 判断当前节点是否为空 if(root == null) return null; // 若当前节点的值大于 q 与 p 的节点值,则说明 q 与 p 都在左子树 if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q); // 若当前节点的值小于 q 与 p 的节点值,则说明 q 与 p 都在右子树 if(root.val Python ''' Author: Goog Tech Date: 2020-09-27 19:25:26 LastEditTime: 2020-09-27 19:26:16 Description: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#68 - I. 二叉搜索树的最近公共祖先\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归解法 # 利用搜索二叉树中每个节点都具备特性: 大于左子树上任意一个节点的值，小于右子树上任意一个节点的值 def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" # 判断当前节点是否为空 if not root: return None # 若当前节点的值大于 q 与 p 的节点值,则说明 q 与 p 都在左子树 if root.val > p.val and root.val > q.val: return self.lowestCommonAncestor(root.left, p, q) # 若当前节点的值小于 q 与 p 的节点值,则说明 q 与 p 都在右子树 elif root.val Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"剑指Offer/68-II.二叉树的最近公共祖先/68-II.二叉树的最近公共祖先.html":{"url":"剑指Offer/68-II.二叉树的最近公共祖先/68-II.二叉树的最近公共祖先.html","title":"68-II.二叉树的最近公共祖先","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 68 - II. 二叉树的最近公共祖先 Java Python 68 - II. 二叉树的最近公共祖先 https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/ Java /* * @Author: Goog Tech * @Date: 2020-09-27 17:32:00 * @LastEditTime: 2020-09-27 17:34:05 * @Description: https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/ * @FilePath: \\leetcode-googtech\\剑指 Offer\\#68 - II. 二叉树的最近公共祖先\\Solution.java * @WebSite: https://algorithm.show/ */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { // 递归解法 &#x1F635; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 若当前节点为空或等于 q 或 p,则直接返回 root if(root == null || root.val == p.val || root.val == q.val) return root; // 递归左右子树节点 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 若 left 和 right 都为空,则说明 q 与 p 分别在 root 的异侧,因此 root 为最近公共节点 // 反之都为空则说明 root 的左右子树都不包含 q 与 p,进而返回 null 即可 if(left != null && right != null) return root; // 若 left 为空而 right 不为空,则说明 p 与 q 都不在 root 的左子树中,直接返回 right 即可 return left == null ? right : left; } } Python ''' Author: Goog Tech Date: 2020-09-27 17:32:11 LastEditTime: 2020-09-27 17:33:49 Description: https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/ FilePath: \\leetcode-googtech\\剑指 Offer\\#68 - II. 二叉树的最近公共祖先\\Solution.py WebSite: https://algorithm.show/ ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): # 递归解法 &#x1F635; def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" if not root or root.val == p.val or root.val == q.val: return root; left = self.lowestCommonAncestor(root.left, q, p) right = self.lowestCommonAncestor(root.right, q, p) if left and right: return root return right if left is None else left Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"cpp-tutorial/":{"url":"cpp-tutorial/","title":"C++ 极速入门","keywords":"","body":" 📝 C++ 极速入门 ❗ 如需修改、转发、引用. . . 请标明出处, 谢谢~ HTML 在线查看 : c-to-cpp-in-two-hours.html PDF 在线查看及下载 : [c-to-cpp-in-two-hours.pdf](https://algorithm.show/cpp-tutorial/c-to-cpp-in-two-hours/c-to-cpp-in-two-hours.pdf) > Word 在线查看及下载 : [c-to-cpp-in-two-hours.docx](https://algorithm.show/cpp-tutorial/c-to-cpp-in-two-hours/c-to-cpp-in-two-hours.docx) > MarkDown 在线查看及下载 : [c-to-cpp-in-two-hours.md](https://algorithm.show/cpp-tutorial/c-to-cpp-in-two-hours/c-to-cpp-in-two-hours.md) --> Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "},"DSA-tutorial/":{"url":"DSA-tutorial/","title":"数据结构基础练习题","keywords":"","body":" 📝 数据结构与算法 ❗ 如需修改、转发、引用. . . 请标明出处, 谢谢~ HTML 在线查看 : DSA-basic-question.html PDF 在线查看及下载 : [DSA-basic-question.pdf](https://algorithm.show/DSA-tutorial/DSA-basic-question/DSA-basic-question.pdf) > Word 在线查看及下载 : [DSA-basic-question.docx](https://algorithm.show/DSA-tutorial/DSA-basic-question/DSA-basic-question.docx) > MarkDown 在线查看及下载 : [DSA-basic-question.md](https://algorithm.show/DSA-tutorial/DSA-basic-question/DSA-basic-question.md) --> Copyright © GoogTech 2021 all right reserved，powered by GitbookLast update time : 2021-09-15 01:55:05 "}}